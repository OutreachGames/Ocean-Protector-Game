--OVERVIEW:
--setups and controls main HUD

-- dependencies
local HSH = require ("modules.hashes_md")
local MY_GOO = require ("gui.gooey_theme_md")

-- constants

local CV_item_groups = {
	item_ph = {
		group_name = "/group_item_ph",
		plot_y_range = {7.5, 8.2},
		plot_y_label = "Ocean pH"
	},
	item_plankton = {
		group_name = "/group_item_plankton",
		plot_y_range = {0.0, 1.0},
		plot_y_label = "Plankton Health"
	},
	item_coral = {
		group_name = "/group_item_coral",
		plot_y_range = {0.0, 1.0},
		plot_y_label = "Coral Health"
	},
	item_fish = {
		group_name = "/group_item_fish",
		plot_y_range = {0.0, 1.0},
		plot_y_label = "Fish Health"
	},
	item_mollusks = {
		group_name = "/group_item_mollusks",
		plot_y_range = {0.0, 1.0},
		plot_y_label = "Mollusk Health"
	},
	item_crustaceans = {
		group_name = "/group_item_crustaceans",
		plot_y_range = {0.0, 1.0},
		plot_y_label = "Crustacean Health"
	},
	item_humans = {
		group_name = "/group_item_humans",
		plot_y_range = {0.0, 1.0},
		plot_y_label = "Human Health"
	}
}


-- functions

-- HUD Screen: Decision
local function Screen_Decision_Reset(self, enabled_setting, run_sizing, reset_tracker_variables)

	-- reset Decision screen of HUD

	-- default args
	if enabled_setting == nil then
		enabled_setting = false
	end
	if reset_tracker_variables == nil then
		reset_tracker_variables = false
	end

	-- set enabled status
	local constant = self.hud_decision_constant
	local controller_node = gui.get_node(constant.node_controller)

	-- run enabling status and possibly sizing
	local function func_done(self, node)

		gui.set_enabled(node, enabled_setting)

	end

	if run_sizing then
		if enabled_setting then
			func_done(self, controller_node)
			gui.set_scale(controller_node, MY_GOO.MINIMIZE)
			gui.animate(controller_node, "scale", MY_GOO.MAXIMIZE, gui.EASING_OUTBACK, 0.50, 0)
		else
			--gui.set_scale(controller_node, MY_GOO.MAXIMIZE)
			gui.animate(controller_node, "scale", MY_GOO.MINIMIZE, gui.EASING_INBACK, 0.50, 0, func_done)
		end
	else
		func_done(self, controller_node)
	end

	-- exit if not resetting answer option tracker variables
	if not reset_tracker_variables then return end

	-- reset tracking table
	self.hud_decision_dynamic.screen_isactive = enabled_setting
	self.hud_decision_dynamic.goo_option_selected = 0
	self.hud_decision_dynamic.goo_sumbit_isactive = false

	-- actually reset radio nodes, including resetting text color
	for _,v_nodeid in ipairs(constant.goo_option_names) do
		gui.set_color(gui.get_node(v_nodeid..constant.goo_option_label_basename), MY_GOO.COLOR_TEXT_DEFAULT)
		MY_GOO.radio(v_nodeid).set_selected(false)
	end

	-- set tint on button to dark/locked
	gui.set_color(gui.get_node(constant.node_submit_box_name), MY_GOO.COLOR_LOCKED)
	gui.set_color(gui.get_node(constant.node_submit_text_name), MY_GOO.COLOR_LOCKED)

	--#TODO enable and set text accordingly

end

local function Screen_Decision_Initialize(self, enabled_status)

	-- set contants and setup dynamic values and components

	local basename = "hud_decision"

	self.hud_decision_constant = nil
	self.hud_decision_dynamic = nil

	-- set constants
	self.hud_decision_constant = {
		hud_basename = basename,
		node_controller = basename .. "/gnode_controller",
		goo_option_names = {
			basename.."/group_option_1",
			basename.."/group_option_2",
			basename.."/group_option_3"
		},
		goo_option_label_basename = "/gui_radio_label",
		goo_submit_name = basename.."/group_button_submit",
		node_submit_box_name = basename.."/group_button_submit/gui_button_core",
		node_submit_text_name = basename.."/group_button_submit/gui_button_label",
	}

	-- set dynamics
	self.hud_decision_dynamic = {}
	local run_sizer = false
	local reset_answers = true
	Screen_Decision_Reset(self, enabled_status, run_sizer, reset_answers)

end

local function Screen_Decision_Input(self, action_id, action)

	-- runs 'On Input' for Decision screen on HUD

	-- early out if not allowed to use
	if not self.hud_decision_dynamic.screen_isactive or self.hud_plot_dynamic.screen_isactive then
		return
	end

	local Info = self.hud_decision_constant

	local function func_radiogroup(local_group_id, local_action_id, local_action)

		-- handles all the radio functionality

		local function radio_base(index)

			-- run the logic when radio selected

			-- set the selected index and allow the submit button
			self.hud_decision_dynamic.goo_option_selected = index
			self.hud_decision_dynamic.goo_sumbit_isactive = true
			gui.set_color(gui.get_node(Info.node_submit_box_name), MY_GOO.COLOR_DEFAULT)
			gui.set_color(gui.get_node(Info.node_submit_text_name), MY_GOO.COLOR_TEXT_DEFAULT)

			-- visually highlight which choice was selected
			local other_nodes = {1, 2, 3}
			other_nodes[index] = nil

			-- note that trying to use the bright white makes text darker actually
			gui.set_color(gui.get_node(Info.goo_option_names[index]..Info.goo_option_label_basename), MY_GOO.COLOR_TEXT_DEFAULT)
			for _,v_otherindex in pairs(other_nodes) do
				gui.set_color(gui.get_node(Info.goo_option_names[v_otherindex]..Info.goo_option_label_basename), MY_GOO.COLOR_TEXT_UNSELECTED)
			end

			print("radio "..index.." selected")
		end

		local function func_radio_1(radio)
			radio_base(1)
		end
		local function func_radio_2(radio)
			radio_base(2)
		end
		local function func_radio_3(radio)
			radio_base(3)
		end

		MY_GOO.radio(Info.goo_option_names[1], local_group_id, local_action_id, local_action, func_radio_1)
		MY_GOO.radio(Info.goo_option_names[2], local_group_id, local_action_id, local_action, func_radio_2)
		MY_GOO.radio(Info.goo_option_names[3], local_group_id, local_action_id, local_action, func_radio_3)

	end

	local function func_submit(button)

		-- handle all the button functionality
		local run_sizer = true
		local reset_values = true
		--^ need to have tracker as off so if plot checks it properly knows what the status is
		-- if plot thinks decisions is still on it can re-enable decision 
		--#TODO save the values to master table before clearing them!
		Screen_Decision_Reset(self, false, run_sizer, reset_values)

		print("Submit Button was pressed")

	end

	MY_GOO.radiogroup("radiogroup_answer_options", action_id, action, func_radiogroup)

	if self.hud_decision_dynamic.goo_sumbit_isactive then
		MY_GOO.button_simple(Info.goo_submit_name, action_id, action, func_submit)
	end

end


-- HUD Screen: Graph Plot 
local function Screen_Plot_Reset(self, enabled_setting, item_group_key, run_sizing)

	-- reset Graph Plot screen of HUD

	-- default args
	if enabled_setting == nil then
		enabled_setting = false
	end

	-- set enabled status
	local constant = self.hud_plot_constant
	local controller_node = gui.get_node(constant.node_controller)

	-- run enabling status and possibly sizing
	local function func_done(self, node)

		gui.set_enabled(node, enabled_setting)

		-- if enabling 
			-- if decision tracker is active then disable decision node
		-- if disabling
			-- if decision tracker is active then enable decision node
		local run_decision_sizer = false
		local reset_values = false
		if enabled_setting then
			if self.hud_decision_dynamic.screen_isactive then
				Screen_Decision_Reset(self, false, run_decision_sizer, reset_values)
			end
		else
			if self.hud_decision_dynamic.screen_isactive then
				Screen_Decision_Reset(self, true, run_decision_sizer, reset_values)
			end
		end

	end

	if run_sizing then
		if enabled_setting then
			func_done(self, controller_node)
			gui.set_scale(controller_node, MY_GOO.MINIMIZE)
			gui.animate(controller_node, "scale", MY_GOO.MAXIMIZE, gui.EASING_OUTBACK, 0.50, 0)
		else
			--gui.set_scale(controller_node, MY_GOO.MAXIMIZE)
			gui.animate(controller_node, "scale", MY_GOO.MINIMIZE, gui.EASING_INBACK, 0.50, 0, func_done)
		end
	else
		func_done(self, controller_node)
	end

	-- reset tracker variables
	self.hud_plot_dynamic.screen_isactive = enabled_setting

	-- if enabling then update graph
	if not enabled_setting or item_group_key == nil then return end

	-- set the axis and labels depending on the specified item group
	local item_info = CV_item_groups[item_group_key]
	if item_info == nil then
		print("Error, the following key does not exist in the item groups list: "..item_group_key.."\n")
		return
	end

	-- set title
	local title = item_info.plot_y_label .. " through Time"
	title = string.gsub(title, " ", "   ")
	gui.set_text(gui.get_node(constant.node_title_name), title)

	-- set y axis label and ticks
	local y_label = string.gsub(item_info.plot_y_label, " ", "   ")
	gui.set_text(gui.get_node(constant.node_y_label), y_label)

	-- set plot height and toggle
	local ytick_start = item_info.plot_y_range[1]
	local ytick_step = (item_info.plot_y_range[2] - ytick_start) / (constant.number_y_ticks - 1)

	for i,v_node_y_tickname in ipairs(constant.node_y_ticks) do
		local tick_label = string.format("%.2f", ytick_start + (ytick_step*(i-1)))
		gui.set_text(gui.get_node(v_node_y_tickname), tick_label)
	end

	--#TODO enable and set graph bars accordingly

end

local function Screen_Plot_Initialize(self, enabled_status)

	-- set contants and setup dynamic values and components

	local basename = "hud_timeplot"
	local plot_base = "/group_plot"
	local num_y_ticks = 6

	self.hud_plot_constant = nil
	self.hud_plot_dynamic = nil

	-- set constants
	self.hud_plot_constant = {
		hud_basename = basename,
		node_controller = basename .. "/gnode_controller",
		goo_exit_name = basename .. "/group_button_submit",
		node_title_name = basename .. plot_base .. "/gui_text_title",
		node_y_label = basename .. plot_base .. "/gui_text_label_yaxis",
		node_y_ticks = {},
		number_y_ticks = num_y_ticks
	}

	-- add ytick labels
	local ytick_base = basename .. plot_base .. "/gui_text_label_ytick_" -- save this for 'Find All' searches: "gui_text_label_ytick_0"
	for i=1,num_y_ticks do
		self.hud_plot_constant.node_y_ticks[i] = ytick_base..tostring(i-1)
	end

	-- set dynamics
	self.hud_plot_dynamic = {}
	Screen_Plot_Reset(self, enabled_status)

end

local function Screen_Plot_Input(self, action_id, action)

	-- runs 'On Input' for Decision screen on HUD

	-- early out if not allowed to use
	if not self.hud_plot_dynamic.screen_isactive then
		return
	end

	local Info = self.hud_plot_constant

	local function func_exit(button)

		-- handle all the button functionality

		-- set that this screen is no longer interactive
		Screen_Plot_Reset(self, false, nil, true)

		print("Exit Button was pressed")

	end

	MY_GOO.button_simple(Info.goo_exit_name, action_id, action, func_exit)

end


-- HUD Screen: Data
local function Screen_Data_Reset(self, enabled_setting)

	-- reset Data screen of HUD

	-- default args
	if enabled_setting == nil then
		enabled_setting = false
	end

	-- set enabled status
	local constant = self.hud_data_constant
	gui.set_enabled(gui.get_node(constant.node_controller), enabled_setting)

	-- reset tracking table
	self.hud_data_dynamic.screen_isactive = enabled_setting
	self.hud_data_dynamic.is_maximized = true
	self.hud_data_dynamic.goo_items_areactive = true

	--#TODO enable and set bars accordingly

end

local function Screen_Data_Initialize(self, enabled_status)

	-- set contants and setup dynamic values and components

	local basename = "hud_data"

	self.hud_data_constant = nil
	self.hud_data_dynamic = nil

	-- set constants
	self.hud_data_constant = {
		hud_basename = basename,
		node_frame_core = basename .. "/group_frame/gui_frame_core",
		node_controller = basename .. "/gnode_controller",
		node_subcontroller = basename .. "/gnode_subcontroller",
		node_max_length = basename .. "/tracker_max_length",
		node_min_length = basename .. "/tracker_min_length",
		goo_minimizer = basename .. "/group_button_sizer",
		goo_item_gotograph = "/group_button_goto",
		goo_group_names = {},
		goo_group_goto_buttons = {},
	}

	-- add button strings contcatenated
	for k,v in pairs(CV_item_groups) do
		local name = basename .. v.group_name
		self.hud_data_constant.goo_group_names[k] = name
		self.hud_data_constant.goo_group_goto_buttons[k] = name .. self.hud_data_constant.goo_item_gotograph
	end

	-- set dynamics
	self.hud_data_dynamic = {}
	Screen_Data_Reset(self, enabled_status)

end

local function Screen_Data_Input(self, action_id, action)

	-- runs 'On Input' for Data screen on HUD

	-- early out if not allowed to use
	if not self.hud_data_dynamic.screen_isactive then
		return
	end

	local Info = self.hud_data_constant

	-- sizer button
	local function func_button_sizer(button)

		-- handle all the button functionality

		local function func_shrink(self, subcontroller_node)
			gui.set_enabled(subcontroller_node, false)
		end

		local function func_expand(self, subcontroller_node)
			gui.set_enabled(subcontroller_node, true)
		end

		-- if is currently maximized then shrink
		-- if is not currently maximized then expand

		local is_now_maximized
		local subcontroller_node = gui.get_node(Info.node_subcontroller)

		local frame_node = gui.get_node(Info.node_frame_core)

		if self.hud_data_dynamic.is_maximized then
			-- run shrink and disable
			is_now_maximized = false
			gui.animate(frame_node, "size.y", gui.get_size(gui.get_node(Info.node_min_length)).y, gui.EASING_INBACK, 0.4)
			gui.animate(subcontroller_node, "scale", MY_GOO.MINIMIZE, gui.EASING_INBACK, 0.35, 0, func_shrink)
		else
			-- run expand and enable
			is_now_maximized = true
			-- needs to be enabled to have size change, 
			-- but since default is large, will already be set small when disabled
			gui.set_enabled(subcontroller_node, true)
			gui.animate(frame_node, "size.y", gui.get_size(gui.get_node(Info.node_max_length)).y, gui.EASING_OUTBACK, 0.4)
			gui.animate(subcontroller_node, "scale", MY_GOO.MAXIMIZE, gui.EASING_OUTBACK, 0.35, 0, func_expand)
		end

		-- update booleans
		self.hud_data_dynamic.goo_items_areactive = is_now_maximized
		self.hud_data_dynamic.is_maximized = is_now_maximized

		print("Sizer was toggled. Is now maximized is "..tostring(is_now_maximized))

	end

	MY_GOO.checkbox_sizer(Info.goo_minimizer, action_id, action, func_button_sizer)


	-- goto buttons
	local function func_goto_core(table_key)

		-- handle all functionality for the goto graph buttons

		-- if active then just overwrite 
		-- if not active then expand
		local needs_expanding = not self.hud_plot_dynamic.screen_isactive

		Screen_Plot_Reset(self, true, table_key, needs_expanding)

		print("Goto button was pressed for "..table_key)

	end

	local function func_goto_ph(button)
		func_goto_core("item_ph")
	end
	local function func_goto_plankton(button)
		func_goto_core("item_plankton")
	end
	local function func_goto_coral(button)
		func_goto_core("item_coral")
	end
	local function func_goto_fish(button)
		func_goto_core("item_fish")
	end
	local function func_goto_mollusks(button)
		func_goto_core("item_mollusks")
	end
	local function func_goto_crustaceans(button)
		func_goto_core("item_crustaceans")
	end
	local function func_goto_humans(button)
		func_goto_core("item_humans")
	end

	if self.hud_data_dynamic.goo_items_areactive then
		local gotos = Info.goo_group_goto_buttons
		MY_GOO.button_goto(gotos.item_ph, action_id, action, func_goto_ph)
		MY_GOO.button_goto(gotos.item_plankton, action_id, action, func_goto_plankton)
		MY_GOO.button_goto(gotos.item_coral, action_id, action, func_goto_coral)
		MY_GOO.button_goto(gotos.item_fish, action_id, action, func_goto_fish)
		MY_GOO.button_goto(gotos.item_mollusks, action_id, action, func_goto_mollusks)
		MY_GOO.button_goto(gotos.item_crustaceans, action_id, action, func_goto_crustaceans)
		MY_GOO.button_goto(gotos.item_humans, action_id, action, func_goto_humans)
	end

end


-- HUD Process: Observe Items
-- #TODO add process to click on and save data on items


-- Screen Fader
local function Run_Fader(self, fade_out, time)

	-- run either fade in or fade out

	-- setup variables
	local fader_node = gui.get_node("gnode_screen_fader")
	local alpha, disable_at_end
	if fade_out then
		gui.set_enabled(fader_node, true)
		alpha = 1.0
		disable_at_end = false
	else
		alpha = 0.0
		disable_at_end = true
	end

	time = time or 2.0

	-- cancel any current fades
	gui.cancel_animation(fader_node, "color.w")

	-- declare callback for readability and thought of optimization
	local function func_set_status()
		if disable_at_end then
			gui.set_enabled(fader_node, false)
		end
	end

	-- run fader animation
	gui.animate(fader_node, "color.w", alpha, go.EASING_LINEAR, time, 0, func_set_status)

end



function init(self)

	MY_GOO.acquire_input()
	Screen_Decision_Initialize(self, true)
	Screen_Data_Initialize(self, true)
	Screen_Plot_Initialize(self, false)

	self.input_is_possible = true

end

function on_message(self, message_id, message, sender)

	if message_id == HSH.msg_fade_out or message_id == HSH.msg_fade_in then
		Run_Fader(self, message_id == HSH.msg_fade_out, message.minfo_fade_duration)
	end

end

function on_input(self, action_id, action)

	if not self.input_is_possible then return end

	Screen_Decision_Input(self, action_id, action)
	Screen_Data_Input(self, action_id, action)
	Screen_Plot_Input(self, action_id, action)

end
