--OVERVIEW:
--setups and controls main HUD

-- dependencies
local HSH = require ("modules.hashes_md")
local MY_GOO = require ("gui.gooey_theme_md")
local STR = require ("modules.screenplay_md")
local EXT = require ("modules.extend_md")
local INFO = require("modules.item_info_md")

-- constants
local CV_item_groups = {}

local CV_gameplay_loop = {
	status_running_main = 1,
	status_running_debrief = 2,
	status_unknown = 3
}


-- functions

local function Initialize_Local_Info_Tbl()

	for k_item_name,v_item_info in pairs(INFO.item_info) do
		if v_item_info.gui_info ~= nil then
			CV_item_groups[k_item_name] = v_item_info.gui_info
		end
	end

end

local function Items_Set_Color_Tracking(self, item_name, needs_to_be_clicked)

	-- set color in data view for color and bar

	--"hud_data/group_item_ph/gnode_controller"
	local data_info = self.hud_data_constant
	local item_base_groupname = data_info.goo_group_names[item_name]
	if item_base_groupname == nil then
		print("Error item name of <"..tostring(item_name).."> is not present in HUD Data Constant table ...\n")
		return
	end

	local color_text, color_bar

	if needs_to_be_clicked then
		color_text = MY_GOO.COLOR_NEEDS_SELECTED
		color_bar = MY_GOO.COLOR_NEEDS_SELECTED
	else
		color_text = MY_GOO.COLOR_TEXT_DEFAULT
		color_bar = MY_GOO.COLOR_DEFAULT
	end

	gui.set_color(gui.get_node(item_base_groupname..data_info.basename_item_bar_progress), color_bar)
	gui.set_color(gui.get_node(item_base_groupname..data_info.basename_item_bar_label), color_text)

end

local function Items_Click_Status_Reset(self, items_to_click_info)

	-- update tracker lists of what items need to be clicked and which items have been clicked

	self.items_all_clicked = true

	self.items_that_need_clicked_list = nil
	self.items_that_need_clicked_list = {}

	self.items_that_need_clicked_sum = 0
	self.items_that_were_clicked_sum = 0

	-- default is reset all items
	if items_to_click_info == "all_items_need_clicked" then
		--print("Default arg used, all items are going to be required to be clicked on...\n")
		items_to_click_info = {}
		for k,_ in pairs(CV_item_groups) do
			items_to_click_info[k] = {
				item_name = k,
				show_debrief_text = "",
				show_data_popup = nil,
				allow_duplicate_clicks = false,
				item_was_clicked = false
			}
		end
	end

	-- if there are items to add to 'needs click' list then add them
	-- also save that we have not clicked them all yet
	local sum_to_click = 0
	if type(items_to_click_info) == "table" then

		self.items_that_need_clicked_list = items_to_click_info

		-- count up items and set color
		for k_itemname,_ in pairs(items_to_click_info) do
			sum_to_click = sum_to_click + 1
			Items_Set_Color_Tracking(self, k_itemname, true)
		end

		-- saved click tracker variables
		if sum_to_click > 0 then
			self.items_all_clicked = false
			self.items_that_need_clicked_sum = sum_to_click
		end

	end

	print("Sum to click is "..sum_to_click.."\n")

end

local function Get_Current_Stage_and_Substage(self)

	-- returns two string values for current stage and substage

	local event_info = self.gameplay_loop_order[self.gameplay_loop_i_key]

	if event_info == nil then
		print("Note: no valid event info exists for game loop key <"..tostring(self.gameplay_loop_i_key).."> \n")
		return nil, nil
	end

	local stage_key = event_info.stage_name_key
	local substage_key = event_info.substage_name_key

	return stage_key, substage_key

end

local function Loop_StatusType_is_Main(self)

	return self.gameplay_loop_status == CV_gameplay_loop.status_running_main

end

local function Loop_StatusType_is_Debrief(self)

	return self.gameplay_loop_status == CV_gameplay_loop.status_running_debrief

end

local function Loop_CompletionType_is_Primary(self, match_type)

	return match_type == self.gameplay_loop_completion_type_primary

end

local function Loop_CompletionType_is_Secondary(self, match_type)

	return match_type == self.gameplay_loop_completion_type_secondary

end

local function Valid_Event_Check_Full(self, match_loop_type)

	-- returns true if loop status type is main or debrief and if given completion type is primary or secondary, false otherwise 

	local status_valid = Loop_StatusType_is_Main(self) or Loop_StatusType_is_Debrief(self)

	local primary_or_secondary_valid = Loop_CompletionType_is_Primary(self, match_loop_type) or Loop_CompletionType_is_Secondary(self, match_loop_type)

	return (status_valid and primary_or_secondary_valid)

end

local function Player_Data_Table_AddEntry(self, item_key, new_value)

	-- adds an i-based entry to player save table for given item key 

	local num_items = #self.player_data_tbl.item_data_tbl[item_key]

	self.player_data_tbl.item_data_tbl[item_key][num_items + 1] = {item_tracker_score = new_value}

	--print("Adding new player data entry for item key <"..item_key.."> with value <"..tostring(new_value).."> \n")

end

local function Player_Data_Table_GetEntry(self, item_key, i_key)

	-- gets an i-based entry from player save table for given item key and i-key

	if self.player_data_tbl == nil then
		print("Error: Unable to get entry in player data table because player data table does not exist \n")
	end
	if self.player_data_tbl.item_data_tbl == nil then
		print("Error: Unable to get entry in item data table of player data table because item data table does not exist \n")
	end

	local item_data = self.player_data_tbl.item_data_tbl[item_key]
	if item_data == nil then return nil end

	-- default i-key is last in list
	i_key = i_key or #item_data

	return item_data[i_key]

end


-- HUD Screen: Data (Section 1)
local function Screen_Data_TrackerUpdate(self)

	-- update progress bars

	local constant = self.hud_data_constant
	for k_itemname,v_gui_groupname in pairs(constant.goo_group_names) do

		--#TODO enable controller if key exists and has data, otherwise disable
		--# recall that updating works on disabled node

		-- get nodes
		local max_length_node = gui.get_node(v_gui_groupname..constant.basename_item_bar_max_x)
		local max_size = gui.get_size(max_length_node)
		-- get health percent
		local entry_health_data = Player_Data_Table_GetEntry(self, k_itemname)
		if entry_health_data == nil then
			print("Error current entry health data for Player Data Table Get Entry is nil, not updating...\n")
			return
		end
		local new_health_value = EXT:math_clamp(entry_health_data.item_tracker_score, 0, 1)
		-- set as new size
		local progress_node = gui.get_node(v_gui_groupname..constant.basename_item_bar_progress)
		local new_size = gui.get_size(progress_node)
		new_size.x = EXT:math_round(max_size.x * new_health_value, 0)
		gui.set_size(progress_node, new_size)

	end

end

-- HUD Screens: Graph Plot (Section 1)
local function Plot_Data_TrackerUpdate(self, item_key)

	-- updates bar heights for plot given item
	-- reminder all items use the same plot, so only one can be open at a time

	local constant = self.hud_plot_constant
	for i=1, constant.max_number_bars do

		-- get nodes to update/show or hide
		local plot_id = constant.basename_individual_bar_group..i
		local progress_node = gui.get_node(plot_id..constant.basename_individual_bar_progress)
		local label_node = gui.get_node(plot_id..constant.basename_individual_bar_label)
		local set_visible

		-- if there is an i-match then make visible text and bar progress, otherwise hide visibility
		local entry_health_data = Player_Data_Table_GetEntry(self, item_key, i)
		if entry_health_data ~= nil then
			-- get node sizes 
			local max_y_length_node = gui.get_node(plot_id..constant.basename_individual_bar_max_y)
			local max_size = gui.get_size(max_y_length_node)
			local new_size = gui.get_size(progress_node)
			-- get health percent
			local new_health_value = EXT:math_clamp(entry_health_data.item_tracker_score, 0, 1)
			new_size.y = EXT:math_round(max_size.y * new_health_value, 0)
			-- set as new size and enable visibility
			gui.set_size(progress_node, new_size)
			gui.set_text(label_node, tostring(i) or "1")
			set_visible = true
		else
			set_visible = false
		end

		-- visibility accordingly
		gui.set_visible(label_node, set_visible)
		gui.set_visible(progress_node, set_visible)

	end

end

--HUD Process: Reset Player Data Table
local function Player_Data_Table_Reset(self, update_hud_screens)

	-- resets player data

	self.player_data_tbl = nil
	self.player_data_tbl = {}
	self.player_data_tbl.item_data_tbl = {}

	-- go through item keys and initialize table and add first entry of fully healthy
	for k_itemname,_ in pairs(CV_item_groups) do
		self.player_data_tbl.item_data_tbl[k_itemname] = {}
		Player_Data_Table_AddEntry(self, k_itemname, 1.0)
	end

	-- we do not need to add reset of graph and data bars to full here, b/c it's done elsewhere:
	-- the init function intializes the plot and data screens, 
	-- and each of this initialization functions run the reset function for each
	-- which runs the health bar reset to whatever the value in this health tracker table is
	-- plus hud screens may not have been initialized yet

	-- if this is running in repeat game section though, might need to re-run data item reset?
	if update_hud_screens then
		Screen_Data_TrackerUpdate(self)
		if self.hud_plot_dynamic.screen_isactive then
			Plot_Data_TrackerUpdate(self, self.hud_plot_dynamic.active_itemkey)
		end
	end

end


-- HUD Process: Observe Items (Section 1)
local function On_GO_Items_Clicked_Reset(self, enabled_setting)

	if enabled_setting == nil then
		enabled_setting = false
	end

	self.hud_can_select_go_items = enabled_setting

end

local function On_GO_Items_Clicked_Basic_Valid(self)

	-- failsafe for do not run if we are looking at decisions or plots
	-- the reset function of these should have 
	-- already set the clickable boolean, but this is a failsafe
	if self.hud_decision_dynamic.screen_isactive or self.hud_plot_dynamic.screen_isactive or self.hud_popup_dynamic.screen_isactive then
		return false
	end

	if self.hud_can_select_go_items then
		return true
	else
		return false
	end

end


-- HUD Process: Update Items 
local function Player_Data_Table_RunScoreInput(self, score_tbl)

	-- takes a table and updates scores accordingly
	for k_itemname,_ in pairs(self.player_data_tbl.item_data_tbl) do
		-- get previous entry and new delta 
		local previous_entry = Player_Data_Table_GetEntry(self, k_itemname) or {}
		local previous_score = previous_entry.item_tracker_score or 0
		local update_score = score_tbl[k_itemname] or score_tbl[1] or 0
		--print("Update score for new entry is <"..tostring(update_score).."> \n")

		-- new value is previous + delta 
		local new_value = previous_score + update_score

		--#TODO testing only, remove when done testing!
		new_value = math.random(80,120)/100 * new_value

		Player_Data_Table_AddEntry(self, k_itemname, new_value)

		-- #TODO update where this goes, since usually won't seen updates until clicking on item
		-- update trackers
		Screen_Data_TrackerUpdate(self)
	end

	-- #TODO update where this goes, since usually won't seen updates until clicking on item
	Plot_Data_TrackerUpdate(self, self.hud_plot_dynamic.active_itemkey)

end


-- HUD Screen: Goals
local function Screen_Goals_Reset(self, enabled_setting, run_sizing, text)

	-- reset Goals screen of HUD

	-- default args
	if enabled_setting == nil then
		enabled_setting = false
	end

	-- set enabled status
	local constant = self.hud_goals_constant
	local controller_node = gui.get_node(constant.node_controller)

	-- run enabling status and possibly sizing
	local function func_done(self, node)

		gui.set_enabled(node, enabled_setting)

		-- enable and set text if new
		local text_node = gui.get_node(constant.node_text_body)
		if text ~= nil then
			gui.set_text(text_node, text)
		end

		-- try to resize hud screen so text fits
		local shown_text = gui.get_text(text_node)
		local str_length = #shown_text

		-- 220ish is base with 2 lines and 330ish is with 5 lines, 100/3
		local line_per_extra_y = 28
		local min_frame_y = 220
		local str_length_per_line = 15
		local base_num_lines = 2

		local num_extra_lines = math.max((str_length/str_length_per_line) - base_num_lines, 0)
		local new_y_frame = math.max(min_frame_y + (num_extra_lines*line_per_extra_y), min_frame_y)

		local frame_node = gui.get_node(constant.node_frame_core)
		gui.set_size(frame_node, vmath.vector3(gui.get_size(frame_node).x, new_y_frame, 0))

	end

	if run_sizing then
		if enabled_setting then
			func_done(self, controller_node)
			gui.set_scale(controller_node, MY_GOO.MINIMIZE)
			gui.animate(controller_node, "scale", MY_GOO.MAXIMIZE, gui.EASING_OUTBACK, 0.50, 0)
		else
			--gui.set_scale(controller_node, MY_GOO.MAXIMIZE)
			gui.animate(controller_node, "scale", MY_GOO.MINIMIZE, gui.EASING_INBACK, 0.50, 0, func_done)
		end
	else
		func_done(self, controller_node)
	end

	-- reset tracking table
	self.hud_goals_dynamic.screen_isactive = enabled_setting
	self.hud_goals_dynamic.is_maximized = true

end

local function Screen_Goals_Initialize(self, enabled_status)

	-- set contants and setup dynamic values and components

	local basename = "hud_goals"

	self.hud_goals_constant = nil
	self.hud_goals_dynamic = nil

	-- set constants
	self.hud_goals_constant = {
		hud_basename = basename,
		node_controller = basename .. "/gnode_controller",
		node_text_title = basename .. "/gnode_header_text",
		node_text_body = basename .. "/gnode_body_text",
		node_frame_core = basename .. "/group_frame/gui_frame_core"
	}

	-- set dynamics
	self.hud_goals_dynamic = {}
	Screen_Goals_Reset(self, enabled_status)

end

local function Screen_Goals_Input(self, action_id, action)

	-- runs 'On Input' for Goals screen on HUD

	-- early out if not allowed to use
	if not self.hud_goals_dynamic.screen_isactive then
		return
	end

	local Info = self.hud_goals_constant

end


-- HUD Screen: Popup 
local function Screen_Popup_Reset(self, enabled_setting, run_sizing, reset_values, body_text, title_text, size_type)

	-- reset Popup screen of HUD

	-- default args
	if enabled_setting == nil then
		enabled_setting = false
	end
	if reset_values == nil then
		reset_values = false
	end

	-- set enabled status
	local constant = self.hud_popup_constant
	local controller_node = gui.get_node(constant.node_controller)

	-- run enabling status and possibly sizing
	local function func_done(self, node)

		gui.set_enabled(node, enabled_setting)

	end

	if run_sizing then
		if enabled_setting then
			func_done(self, controller_node)
			gui.set_scale(controller_node, MY_GOO.MINIMIZE)

			--try to auto size if none specified
			if size_type == nil then
				local _, counted_newlines = body_text:gsub('\n', '\n')
				local num_lines_guess = math.max(counted_newlines, #body_text/80)
				if num_lines_guess > 8 then
					size_type = "size_large"
				elseif num_lines_guess > 3 then
					size_type = "size_medium"
				else
					size_type = "size_small"
				end
			end

			local y_ranges = {
				size_small = {250, 119, 108},
				size_medium = {400, 258, -51},
				size_large = {600, 468, -251}
			}

			local yvals = y_ranges[size_type]

			local node_body_frame = gui.get_node(constant.node_frame_body)
			local node_body_text = gui.get_node(constant.node_text_body)
			local node_button_frame = gui.get_node(constant.node_continue_frame)
			gui.set_size(node_body_frame, vmath.vector3(gui.get_size(node_body_frame).x, yvals[1], 0))
			gui.set_size(node_body_text, vmath.vector3(gui.get_size(node_body_text).x, yvals[2], 0))
			gui.set_position(node_button_frame, vmath.vector3(gui.get_position(node_button_frame).x, yvals[3], 0))

			gui.animate(controller_node, "scale", MY_GOO.MAXIMIZE, gui.EASING_OUTBACK, 0.50, 0)
		else
			--gui.set_scale(controller_node, MY_GOO.MAXIMIZE)
			gui.animate(controller_node, "scale", MY_GOO.MINIMIZE, gui.EASING_INBACK, 0.50, 0, func_done)
		end
	else
		func_done(self, controller_node)
	end

	-- exit if not resetting answer option tracker variables
	if not reset_values then return end

	-- reset tracking table
	self.hud_popup_dynamic.screen_isactive = enabled_setting
	self.hud_popup_dynamic.is_maximized = true

	-- enable and set text, but only if enabling
	if enabled_setting then
		if body_text ~= nil then
			gui.set_text(gui.get_node(constant.node_text_body), body_text)
		end
		title_text = title_text or "New Information"
		if title_text ~= nil then
			gui.set_text(gui.get_node(constant.node_text_title), title_text)
		end
	end

end

local function Screen_Popup_Initialize(self, enabled_status)

	-- set contants and setup dynamic values and components

	local basename = "hud_newinfo"

	self.hud_popup_constant = nil
	self.hud_popup_dynamic = nil

	-- set constants
	self.hud_popup_constant = {
		hud_basename = basename,
		node_controller = basename .. "/gnode_controller",
		node_text_title = basename .. "/group_header/gui_frame_text",
		node_text_body = basename .. "/gnode_info_text",
		node_frame_body = basename .. "/group_body/gui_frame_core",
		node_continue_frame = basename .. "/group_button_submit/gui_button_core",
		node_continue_text = basename .. "group_button_submit/gui_button_label",
		goo_continue_name = basename .. "/group_button_submit"
	}

	-- set dynamics
	self.hud_popup_dynamic = {}
	local run_sizing = false
	local reset_values = true
	Screen_Popup_Reset(self, enabled_status, run_sizing, reset_values)

end

local function Screen_Popup_Input(self, action_id, action)

	-- runs 'On Input' for Decision screen on HUD

	-- early out if not allowed to use
	if not self.hud_popup_dynamic.screen_isactive or self.hud_decision_dynamic.screen_isactive or self.hud_plot_dynamic.screen_isactive then
		return
	end

	local Info = self.hud_popup_constant

	local function func_continue(button)

		-- handle all the button functionality

		-- set that this screen is no longer interactive
		local run_sizing = false
		local reset_values = true
		Screen_Popup_Reset(self, false, run_sizing, reset_values)

		print("Continue Button was pressed")

		local new_info_loop_type = STR.CV.goal_completed_types.class_new_information

		if Valid_Event_Check_Full(self, new_info_loop_type) then

			-- if primary loop type is new_info and not in debrief then run debrief check
			-- if that is not the case, then it means we got to this new_info via
			-- some kind of debrief, whether it is a debrief of a new_info, decision, or item_click
			if Loop_CompletionType_is_Primary(self, new_info_loop_type) and Loop_StatusType_is_Main(self) then

				local stage_key, substage_key = Get_Current_Stage_and_Substage(self)
				local debrief_text = STR:Get_NewInfo_Text_Debrief(stage_key, substage_key)

				-- if there is debrief for this new_info screen then run it, 
				-- otherwise finish up 
				if debrief_text ~= nil and debrief_text ~= "" then
					self.gameplay_loop_status = CV_gameplay_loop.status_running_debrief
					self.gameplay_loop_completion_type_secondary = STR.CV.goal_completed_types.class_new_information
					local run_sizing_debrief = true
					local update_values_to_debrief = true
					Screen_Popup_Reset(self, true, run_sizing_debrief, update_values_to_debrief, debrief_text)
				else
					STR:Run_NewInfo_Text_OutcomeFunc(stage_key, substage_key)
					msg.post(".", HSH.msg_request_game_progress)
				end

			else
				-- in some form of debrief 
				-- if debrief of new_info then run new_info completion function if any exists before just progressing. 
				-- this is b/c the event type we came from to this stage 
				-- is not a new_info and already had it's outcome func ran 
				--#TODO update here with additional types, might not always want to run progress
				local progress_to_next_stage = false

				if Loop_CompletionType_is_Primary(self, new_info_loop_type) then
					local stage_key, substage_key = Get_Current_Stage_and_Substage(self)
					STR:Run_NewInfo_Text_OutcomeFunc(stage_key, substage_key)
					progress_to_next_stage = true
				elseif Loop_CompletionType_is_Primary(self, STR.CV.goal_completed_types.class_click_items) then
					if self.items_all_clicked then
						progress_to_next_stage = true
					end
				else
					progress_to_next_stage = true
				end

				if progress_to_next_stage then
					msg.post(".", HSH.msg_request_game_progress)
				end
			end

		end

	end

	MY_GOO.button_simple(Info.goo_continue_name, action_id, action, func_continue)

end


-- HUD Screen: Decision
local function Screen_Decision_Reset(self, enabled_setting, run_sizing, reset_tracker_variables, num_options, question_text, answer_text_tbl)

	-- reset Decision screen of HUD

	-- default args
	if enabled_setting == nil then
		enabled_setting = false
	end
	if reset_tracker_variables == nil then
		reset_tracker_variables = false
	end
	if num_options == nil then
		num_options = 3
	end

	-- set enabled status
	local constant = self.hud_decision_constant
	local controller_node = gui.get_node(constant.node_controller)

	-- run enabling status and possibly sizing
	local function func_done(self, node)

		gui.set_enabled(node, enabled_setting)

		-- get which buttons to enable/disable when starting up/enabling
		-- disable all buttons to start except for those that will be used
		if enabled_setting then
			for i_node_num,v_node_id in ipairs(constant.goo_option_names) do
				local status = false
				if i_node_num <= num_options then
					status = true
				end
				gui.set_enabled(gui.get_node(v_node_id..constant.goo_option_core_basename), status)
				gui.set_enabled(gui.get_node(v_node_id..constant.goo_option_label_basename), status)
			end

			-- set base position and height of frame and submit button depending on number of options
			local pos_update = constant.goo_option_placement[num_options]
			gui.set_position(node, vmath.vector3(gui.get_position(node).x, pos_update.frame_position_y, 0))

			local frame_node = gui.get_node(constant.node_frame)
			gui.set_size(frame_node, vmath.vector3(gui.get_size(frame_node).x, pos_update.frame_ylength, 0))

			local button_node = gui.get_node(constant.node_submit_box_name)
			local current_pos_button = gui.get_position(button_node)
			gui.set_position(button_node, vmath.vector3(current_pos_button.x, pos_update.submit_position_y, 0))

		end

	end

	if run_sizing then
		if enabled_setting then
			func_done(self, controller_node)
			gui.set_scale(controller_node, MY_GOO.MINIMIZE)
			gui.animate(controller_node, "scale", MY_GOO.MAXIMIZE, gui.EASING_OUTBACK, 0.50, 0)
		else
			--gui.set_scale(controller_node, MY_GOO.MAXIMIZE)
			gui.animate(controller_node, "scale", MY_GOO.MINIMIZE, gui.EASING_INBACK, 0.50, 0, func_done)
		end
	else
		func_done(self, controller_node)
	end

	-- exit if not resetting answer option tracker variables
	if not reset_tracker_variables then return end

	-- reset tracking table
	self.hud_decision_dynamic.screen_isactive = enabled_setting
	self.hud_decision_dynamic.goo_option_selected = 0
	self.hud_decision_dynamic.goo_sumbit_isactive = false
	self.hud_decision_dynamic.number_answer_options = num_options

	-- actually reset radio nodes, including resetting text color
	for _,v_nodeid in ipairs(constant.goo_option_names) do
		gui.set_color(gui.get_node(v_nodeid..constant.goo_option_label_basename), MY_GOO.COLOR_TEXT_DEFAULT)
		MY_GOO.radio(v_nodeid).set_selected(false)
	end

	-- set tint on button to dark/locked
	gui.set_color(gui.get_node(constant.node_submit_box_name), MY_GOO.COLOR_LOCKED)
	gui.set_color(gui.get_node(constant.node_submit_text_name), MY_GOO.COLOR_LOCKED)

	-- set text 
	if question_text ~= nil then
		gui.set_text(gui.get_node(constant.node_question_text), question_text)
	end

	-- update answer option text and save keys in same order
	self.hud_decision_dynamic.answer_choice_keys = nil
	self.hud_decision_dynamic.answer_choice_keys = {}
	if type(answer_text_tbl) == "table" then
		for i,v_info in ipairs(answer_text_tbl) do
			local q_node_name = constant.goo_option_names[i]..constant.goo_option_label_basename
			gui.set_text(gui.get_node(q_node_name), v_info.choice_text_answer)
			print("Setting node <"..q_node_name.."> to text <"..v_info.choice_text_answer.."> \n")
			self.hud_decision_dynamic.answer_choice_keys[i] = v_info.user_choice_key
		end
	end

end

local function Screen_Decision_Initialize(self, enabled_status)

	-- set contants and setup dynamic values and components

	local basename = "hud_decision"

	self.hud_decision_constant = nil
	self.hud_decision_dynamic = nil

	-- set constants
	self.hud_decision_constant = {
		hud_basename = basename,
		node_controller = basename .. "/gnode_controller",
		node_frame = basename .. "/group_body/gui_frame_core",
		node_question_text = basename .. "/gnode_question_text",
		goo_option_placement = {
			{frame_ylength = 740, frame_position_y = 450, submit_position_y = -368},
			{frame_ylength = 740, frame_position_y = 450, submit_position_y = -368},
			{frame_ylength = 740, frame_position_y = 450, submit_position_y = -368},
			{frame_ylength = 868, frame_position_y = 536, submit_position_y = -495}
		},
		goo_option_names = {
			basename.."/group_option_1",
			basename.."/group_option_2",
			basename.."/group_option_3",
			basename.."/group_option_4"
		},
		goo_option_label_basename = "/gui_radio_label",
		goo_option_core_basename = "/gui_radio_core",
		goo_submit_name = basename.."/group_button_submit",
		node_submit_box_name = basename.."/group_button_submit/gui_button_core",
		node_submit_text_name = basename.."/group_button_submit/gui_button_label",
	}

	-- set dynamics
	self.hud_decision_dynamic = {}
	local run_sizer = false
	local reset_answers = true
	Screen_Decision_Reset(self, enabled_status, run_sizer, reset_answers)

end

local function Screen_Decision_Input(self, action_id, action)

	-- runs 'On Input' for Decision screen on HUD

	-- early out if not allowed to use
	if not self.hud_decision_dynamic.screen_isactive or self.hud_plot_dynamic.screen_isactive then
		return
	end

	local Info = self.hud_decision_constant
	local num_options = self.hud_decision_dynamic.number_answer_options

	local function func_radiogroup(local_group_id, local_action_id, local_action)

		-- handles all the radio functionality

		local function radio_base(index)

			-- run the logic when radio selected

			-- set the selected index and allow the submit button
			self.hud_decision_dynamic.goo_option_selected = index
			self.hud_decision_dynamic.goo_sumbit_isactive = true
			gui.set_color(gui.get_node(Info.node_submit_box_name), MY_GOO.COLOR_DEFAULT)
			gui.set_color(gui.get_node(Info.node_submit_text_name), MY_GOO.COLOR_TEXT_DEFAULT)

			-- visually highlight which choice was selected
			local other_nodes = {1, 2, 3}
			other_nodes[index] = nil

			-- note that trying to use the bright white makes text darker actually
			gui.set_color(gui.get_node(Info.goo_option_names[index]..Info.goo_option_label_basename), MY_GOO.COLOR_TEXT_DEFAULT)
			for _,v_otherindex in pairs(other_nodes) do
				gui.set_color(gui.get_node(Info.goo_option_names[v_otherindex]..Info.goo_option_label_basename), MY_GOO.COLOR_TEXT_UNSELECTED)
			end

			print("radio "..index.." selected")
		end

		local function func_radio_1(radio)
			radio_base(1)
		end
		local function func_radio_2(radio)
			radio_base(2)
		end
		local function func_radio_3(radio)
			radio_base(3)
		end
		local function func_radio_4(radio)
			radio_base(4)
		end

		if num_options >= 1 then
			MY_GOO.radio(Info.goo_option_names[1], local_group_id, local_action_id, local_action, func_radio_1)
		end
		if num_options >= 2 then
			MY_GOO.radio(Info.goo_option_names[2], local_group_id, local_action_id, local_action, func_radio_2)
		end
		if num_options >= 3 then
			MY_GOO.radio(Info.goo_option_names[3], local_group_id, local_action_id, local_action, func_radio_3)
		end
		if num_options >= 4 then
			MY_GOO.radio(Info.goo_option_names[4], local_group_id, local_action_id, local_action, func_radio_4)
		end

	end

	local function func_submit(button)

		-- handle all the button functionality

		--^ need to have tracker as off so if plot checks it properly knows what the status is
		-- if plot thinks decisions is still on it can re-enable decision 
		--#TODO save the values to a master table before clearing them!
		local i = self.hud_decision_dynamic.goo_option_selected
		local answer_string_key = self.hud_decision_dynamic.answer_choice_keys[i]

		local run_sizer = false
		local reset_values = true
		Screen_Decision_Reset(self, false, run_sizer, reset_values)

		print("Submit Button was pressed")

		local loop_type = STR.CV.goal_completed_types.class_decisison

		if Valid_Event_Check_Full(self, loop_type) then
			if Loop_CompletionType_is_Primary(self, loop_type) then

				-- run outcome function
				local stage_key, substage_key = Get_Current_Stage_and_Substage(self)
				STR:Run_Decision_Answer_OutcomeFunc(stage_key, substage_key, self.character_role_key, answer_string_key)

				-- do debrief text if present
				-- this consists of opening popup window and setting goal type
				local debrief_text = STR:Get_Decision_Text_AnswerDebrief(stage_key, substage_key, self.character_role_key, answer_string_key)
				if Loop_StatusType_is_Main(self) and debrief_text ~= nil and debrief_text ~= "" then

					self.gameplay_loop_status = CV_gameplay_loop.status_running_debrief
					self.gameplay_loop_completion_type_secondary = STR.CV.goal_completed_types.class_new_information

					-- also subtract one from current progress if incorrect so we go back to it in the next submit
					if STR:Get_Decision_Answer_RepeatD(stage_key, substage_key, self.character_role_key, answer_string_key) then
						self.gameplay_loop_i_key = self.gameplay_loop_i_key - 1
					end

					-- add debrief screen and also update goals
					local run_sizing_goals = false
					Screen_Goals_Reset(self, true, run_sizing_goals, "Evaluate outcome of choice")

					local run_sizing_popup = true
					local reset_values_popup = true
					Screen_Popup_Reset(self, true, run_sizing_popup, reset_values_popup, debrief_text, "Update")

				else
					msg.post(".", HSH.msg_request_game_progress)
				end
			end
		end

	end

	MY_GOO.radiogroup("radiogroup_answer_options", action_id, action, func_radiogroup)

	if self.hud_decision_dynamic.goo_sumbit_isactive then
		MY_GOO.button_simple(Info.goo_submit_name, action_id, action, func_submit)
	end

end


-- HUD Screen: Graph Plot (Section 2)
local function Screen_Plot_Reset(self, enabled_setting, run_sizing, item_group_key)

	-- reset Graph Plot screen of HUD

	-- default args
	if enabled_setting == nil then
		enabled_setting = false
	end

	-- set enabled status
	local constant = self.hud_plot_constant
	local controller_node = gui.get_node(constant.node_controller)

	-- run enabling status and possibly sizing
	local function func_done(self, node)

		gui.set_enabled(node, enabled_setting)

		-- if enabling 
			-- if decision tracker is active then disable decision node
		-- if disabling
			-- if decision tracker is active then enable decision node
		local reset_values = false
		if enabled_setting then
			local run_decision_sizer = false
			if self.hud_decision_dynamic.screen_isactive then
				Screen_Decision_Reset(self, false, run_decision_sizer, reset_values)
			end
			if self.hud_popup_dynamic.screen_isactive then
				Screen_Popup_Reset(self, false, run_decision_sizer, reset_values)
			end
		else
			local run_decision_sizer = true
			if self.hud_decision_dynamic.screen_isactive then
				Screen_Decision_Reset(self, true, run_decision_sizer, reset_values)
			end
			if self.hud_popup_dynamic.screen_isactive then
				Screen_Popup_Reset(self, true, run_decision_sizer, reset_values)
			end
		end

	end

	if run_sizing then
		if enabled_setting then
			func_done(self, controller_node)
			gui.set_scale(controller_node, MY_GOO.MINIMIZE)
			gui.animate(controller_node, "scale", MY_GOO.MAXIMIZE, gui.EASING_OUTBACK, 0.50, 0)
		else
			--gui.set_scale(controller_node, MY_GOO.MAXIMIZE)
			gui.animate(controller_node, "scale", MY_GOO.MINIMIZE, gui.EASING_INBACK, 0.50, 0, func_done)
		end
	else
		func_done(self, controller_node)
	end

	-- reset tracker variables
	self.hud_plot_dynamic.screen_isactive = enabled_setting
	self.hud_plot_dynamic.active_itemkey = item_group_key

	-- if enabling then update graph
	if not enabled_setting or item_group_key == nil then return end

	-- set the axis and labels depending on the specified item group
	local item_info = CV_item_groups[item_group_key]
	if item_info == nil then
		print("Error, the following key does not exist in the item groups list: "..item_group_key.."\n")
		return
	end

	-- set title
	local title = item_info.plot_y_label .. " through Time"
	title = string.gsub(title, " ", "   ")
	gui.set_text(gui.get_node(constant.node_title_name), title)

	-- set y axis label and ticks
	local y_label = string.gsub(item_info.plot_y_label, " ", "   ")
	gui.set_text(gui.get_node(constant.node_y_label), y_label)

	-- set plot height and toggle
	local ytick_start = item_info.plot_y_range[1]
	local ytick_step = (item_info.plot_y_range[2] - ytick_start) / (constant.number_y_ticks - 1)

	for i,v_node_y_tickname in ipairs(constant.node_y_ticks) do
		local tick_label = string.format("%.2f", ytick_start + (ytick_step*(i-1)))
		gui.set_text(gui.get_node(v_node_y_tickname), tick_label)
	end

	-- enable and set graph bars accordingly
	-- get item key, and for each item bar progress and label to visible
	Plot_Data_TrackerUpdate(self, item_group_key)

end

local function Screen_Plot_Initialize(self, enabled_status)

	-- set contants and setup dynamic values and components

	local basename = "hud_timeplot"
	local plot_base = "/group_plot"
	local num_y_ticks = 6

	self.hud_plot_constant = nil
	self.hud_plot_dynamic = nil

	-- set constants
	self.hud_plot_constant = {
		hud_basename = basename,
		node_controller = basename .. "/gnode_controller",
		goo_exit_name = basename .. "/group_button_submit",
		node_title_name = basename .. plot_base .. "/gui_text_title",
		node_y_label = basename .. plot_base .. "/gui_text_label_yaxis",
		node_y_ticks = {},
		number_y_ticks = num_y_ticks,
		max_number_bars = 15,
		node_groupplots_controller = basename..plot_base.."/group_plots",
		basename_individual_bar_group = basename..plot_base.."/group_plot_",
		basename_individual_bar_label = "/gui_label",
		basename_individual_bar_max_y = "/group_bar_element/tracker_max_length",
		basename_individual_bar_progress = "/group_bar_element/gui_frame_progress",
	}

	-- add ytick labels
	local ytick_base = basename .. plot_base .. "/gui_text_label_ytick_" -- save this for 'Find All' searches: "gui_text_label_ytick_0"
	for i=1,num_y_ticks do
		self.hud_plot_constant.node_y_ticks[i] = ytick_base..tostring(i-1)
	end

	-- set dynamics
	self.hud_plot_dynamic = {}
	Screen_Plot_Reset(self, enabled_status)

end

local function Screen_Plot_Input(self, action_id, action)

	-- runs 'On Input' for Decision screen on HUD

	-- early out if not allowed to use
	if not self.hud_plot_dynamic.screen_isactive then
		return
	end

	local Info = self.hud_plot_constant

	local function func_exit(button)

		-- handle all the button functionality

		-- set that this screen is no longer interactive
		local run_sizer = false
		Screen_Plot_Reset(self, false, run_sizer)

		print("Exit Button was pressed")

	end

	MY_GOO.button_simple(Info.goo_exit_name, action_id, action, func_exit)

end


-- HUD Screen: Data (Section 2)
local function Screen_Data_Reset(self, enabled_setting)

	-- reset Data screen of HUD

	-- default args
	if enabled_setting == nil then
		enabled_setting = false
	end

	-- set enabled status
	local constant = self.hud_data_constant
	gui.set_enabled(gui.get_node(constant.node_controller), enabled_setting)

	-- reset tracking table
	self.hud_data_dynamic.screen_isactive = enabled_setting
	self.hud_data_dynamic.is_maximized = true
	self.hud_data_dynamic.goo_items_areactive = true

	-- enable and set bars accordingly
	Screen_Data_TrackerUpdate(self)

end

local function Screen_Data_Initialize(self, enabled_status)

	-- set contants and setup dynamic values and components

	local basename = "hud_data"

	self.hud_data_constant = nil
	self.hud_data_dynamic = nil

	-- set constants
	self.hud_data_constant = {
		hud_basename = basename,
		node_frame_core = basename .. "/group_frame/gui_frame_core",
		node_controller = basename .. "/gnode_controller",
		node_subcontroller = basename .. "/gnode_subcontroller",
		node_max_length = basename .. "/tracker_max_length",
		node_min_length = basename .. "/tracker_min_length",
		goo_minimizer = basename .. "/group_button_sizer",
		goo_item_gotograph = "/group_button_goto",
		basename_item_bar_progress = "/group_healthbar/gui_frame_progress",
		basename_item_bar_max_x = "/group_healthbar/tracker_max_length",
		basename_item_bar_label = "/gnode_body_text",
		goo_group_names = {},
		goo_group_goto_buttons = {},
	}

	-- add button strings contcatenated
	for k,v in pairs(CV_item_groups) do
		local name = basename .. v.group_name
		self.hud_data_constant.goo_group_names[k] = name
		self.hud_data_constant.goo_group_goto_buttons[k] = name .. self.hud_data_constant.goo_item_gotograph
	end

	-- set dynamics
	self.hud_data_dynamic = {}
	Screen_Data_Reset(self, enabled_status)

end

local function Screen_Data_Input(self, action_id, action)

	-- runs 'On Input' for Data screen on HUD

	-- early out if not allowed to use
	if not self.hud_data_dynamic.screen_isactive then
		return
	end

	local Info = self.hud_data_constant

	-- sizer button
	local function func_button_sizer(button)

		-- handle all the button functionality

		local function func_shrink(self, subcontroller_node)
			gui.set_enabled(subcontroller_node, false)
		end

		local function func_expand(self, subcontroller_node)
			gui.set_enabled(subcontroller_node, true)
		end

		-- if is currently maximized then shrink
		-- if is not currently maximized then expand

		local is_now_maximized
		local subcontroller_node = gui.get_node(Info.node_subcontroller)

		local frame_node = gui.get_node(Info.node_frame_core)

		if self.hud_data_dynamic.is_maximized then
			-- run shrink and disable
			is_now_maximized = false
			gui.animate(frame_node, "size.y", gui.get_size(gui.get_node(Info.node_min_length)).y, gui.EASING_INBACK, 0.4)
			gui.animate(subcontroller_node, "scale", MY_GOO.MINIMIZE, gui.EASING_INBACK, 0.35, 0, func_shrink)
		else
			-- run expand and enable
			is_now_maximized = true
			-- needs to be enabled to have size change, 
			-- but since default is large, will already be set small when disabled
			gui.set_enabled(subcontroller_node, true)
			gui.animate(frame_node, "size.y", gui.get_size(gui.get_node(Info.node_max_length)).y, gui.EASING_OUTBACK, 0.4)
			gui.animate(subcontroller_node, "scale", MY_GOO.MAXIMIZE, gui.EASING_OUTBACK, 0.35, 0, func_expand)
		end

		-- update booleans
		self.hud_data_dynamic.goo_items_areactive = is_now_maximized
		self.hud_data_dynamic.is_maximized = is_now_maximized

		print("Sizer was toggled. Is now maximized is "..tostring(is_now_maximized))

	end

	MY_GOO.checkbox_sizer(Info.goo_minimizer, action_id, action, func_button_sizer)


	-- goto buttons
	local function func_goto_core(table_key)

		-- handle all functionality for the goto graph buttons

		-- if active then just overwrite 
		-- if not active then expand
		local needs_expanding = not self.hud_plot_dynamic.screen_isactive

		Screen_Plot_Reset(self, true, needs_expanding, table_key)

		print("Goto button was pressed for "..table_key)

	end

	local function func_goto_ph(button)
		func_goto_core("item_ph")
	end
	local function func_goto_plankton(button)
		func_goto_core("item_plankton")
	end
	local function func_goto_coral(button)
		func_goto_core("item_coral")
	end
	local function func_goto_fish(button)
		func_goto_core("item_fish")
	end
	local function func_goto_mollusks(button)
		func_goto_core("item_mollusks")
	end
	local function func_goto_crustaceans(button)
		func_goto_core("item_crustaceans")
	end
	local function func_goto_humans(button)
		func_goto_core("item_humans")
	end

	if self.hud_data_dynamic.goo_items_areactive then
		local gotos = Info.goo_group_goto_buttons
		MY_GOO.button_goto(gotos.item_ph, action_id, action, func_goto_ph)
		MY_GOO.button_goto(gotos.item_plankton, action_id, action, func_goto_plankton)
		MY_GOO.button_goto(gotos.item_coral, action_id, action, func_goto_coral)
		MY_GOO.button_goto(gotos.item_fish, action_id, action, func_goto_fish)
		MY_GOO.button_goto(gotos.item_mollusks, action_id, action, func_goto_mollusks)
		MY_GOO.button_goto(gotos.item_crustaceans, action_id, action, func_goto_crustaceans)
		MY_GOO.button_goto(gotos.item_humans, action_id, action, func_goto_humans)
	end

end


-- HUD Process: Observe Items (Section 2)
local function On_GO_Item_Click_Labeled(self, screen_pos, unique_tbl)

	-- play sound and label of what was clicked on regardless
	sound.play("sound_controller#sound_button_1", {delay = 0, gain = 0.5, pan = 0, speed = 1.0})
	local clicked_label_node = gui.get_node("gnode_clicked_label")

	local labels_i_list = {}
	local num_unique = 0
	for k_itemname,_ in pairs(unique_tbl) do
		num_unique = num_unique + 1
		labels_i_list[num_unique] = CV_item_groups[k_itemname].clicked_label
	end

	local label_txt = ""
	if num_unique == 1 then
		label_txt = labels_i_list[1]
	elseif num_unique == 2 then
		label_txt = labels_i_list[1] .. " & ".. labels_i_list[2]
	else
		label_txt = table.concat(labels_i_list, ", ", 1, num_unique-1)
		label_txt = label_txt .. " & " .. labels_i_list[num_unique]
	end

	gui.set_text(clicked_label_node, label_txt)
	gui.set_position(clicked_label_node, vmath.vector3(screen_pos.x, screen_pos.y, 0))

	gui.set_enabled(clicked_label_node, true)
	gui.set_scale(clicked_label_node, MY_GOO.MAXIMIZE)

	local function func_shrink(self, subcontroller_node)
		gui.set_enabled(subcontroller_node, false)
	end

	gui.animate(clicked_label_node, "scale", MY_GOO.MINIMIZE, gui.EASING_LINEAR, 0.5, 1, func_shrink)

end

local function On_GO_Item_Clicked_Requested(self, action_id, action)

	-- send request to get object items clicked on

	-- if data window is open do not register click if it was within the data bounds
	-- otherwise player may accidentally click on item if item is behind one of the buttons on the data screen
	if action_id == nil or action == nil then return end
	if action_id ~= HSH.control_touch then return end
	if not action.pressed then return end

	-- also check side bars, and return if we clicked in those
	local data_node_controller = gui.get_node(self.hud_data_constant.node_controller)
	local data_node_frame = gui.get_node(self.hud_data_constant.node_frame_core)

	local goals_node_controller = gui.get_node(self.hud_goals_constant.node_controller)
	local goals_node_frame = gui.get_node(self.hud_goals_constant.node_frame_core)

	if gui.is_enabled(data_node_controller, false) and gui.pick_node(data_node_frame, action.x, action.y) then
		--print("Clicked within data frame, not checking rest...\n")
		return
	elseif gui.is_enabled(goals_node_controller, false) and gui.pick_node(goals_node_frame, action.x, action.y) then
		--print("Clicked within data frame, not checking rest...\n")
		return
	end

	-- if valid ocean click then check if for item selecting or just something simple like bubbles

	if On_GO_Items_Clicked_Basic_Valid(self) then
		msg.post("ocean_level:/level_controller", HSH.msg_request_go_clicked, {minfo_action = action})
	else
		msg.post("ocean_level:/level_controller", HSH.msg_request_make_bubbles, {minfo_action = action})
	end

end

local function On_GO_Item_Click_InputEnd(self, item_name, first_time_click)

	-- runs once successfull click on go item(s)

	-- check if actually on list, if so get data and continue
	local item_click_info = self.items_that_need_clicked_list[item_name]

	if item_click_info == nil then return end

	-- run debrief display
	local debrief_text = item_click_info.show_debrief_text
	if first_time_click and debrief_text ~= nil and debrief_text ~= "" then
		local run_sizing_debrief = true
		local update_values_to_debrief = true
		self.gameplay_loop_status = CV_gameplay_loop.status_running_debrief
		self.gameplay_loop_completion_type_secondary = STR.CV.goal_completed_types.class_new_information
		Screen_Popup_Reset(self, true, run_sizing_debrief, update_values_to_debrief, debrief_text)
	end

	-- run pop-up display
	if item_click_info.show_data_popup then
		print("Item clicked and opening graph for <"..item_name..">. \n ")
		Screen_Plot_Reset(self, true, true, item_name)
		Items_Set_Color_Tracking(self, item_name, false)
	end

end

local function On_GO_Item_Clicked_Received(self, clicked_info)

	-- runs process when player clicks on go item(s)

	-- in form 
	-- match_id_tbl[k_item_name] = {selected_go_url = k_goid, selected_go_subitem = k_subitem_name}

	-- early exits
	if not On_GO_Items_Clicked_Basic_Valid(self) then return end

	if type(clicked_info) ~= "table" then return end

	if clicked_info.minfo_match_tbl == nil then return end
	if clicked_info.minfo_match_count == nil then return end
	if clicked_info.minfo_match_count <= 0 then return end

	-- get which groups we are checking clicks for
	local needs_clicked = self.items_that_need_clicked_list
	if self.items_that_need_clicked_sum == 0 then return end

	-- might have clicked on more then one item if they were overlapping so
	-- find first group that is on 'needs to be clicked' list but not on 'is clicked list'
	--#TODO ad conct list of names to display
	local valid_item_clicked
	local back_item_clicked
	local not_allowed_click
	local clicked_unique_tbl = {}
	for _,v_clicked_info in ipairs(clicked_info.minfo_match_tbl) do
		-- on 'needs clicked list'
		local item_name = v_clicked_info.selected_go_item
		local needs_clicked_item = needs_clicked[item_name]
		if needs_clicked_item ~= nil then
			-- checked if it has been clicked or not, 
			-- items not clicked take priority so the list can actually be completed

			if not needs_clicked_item.item_was_clicked then
				-- has not yet been clicked, so add it
				valid_item_clicked = item_name
				clicked_unique_tbl[item_name] = true

				needs_clicked_item.item_was_clicked = true

				if self.items_that_were_clicked_sum < self.items_that_need_clicked_sum then
					self.items_that_were_clicked_sum = self.items_that_were_clicked_sum + 1
				end

				break
			else
				-- has been clicked and is on list, but maybe player wants to view graph again
				if needs_clicked_item.allow_duplicate_clicks then
					back_item_clicked = item_name
					clicked_unique_tbl[item_name] = true
				else
					not_allowed_click = item_name
					clicked_unique_tbl[item_name] = true
				end
			end
		else
			--not on needs clicked list 
			not_allowed_click = item_name
			clicked_unique_tbl[item_name] = true
		end
	end

	-- if this was last on list then set variable that all are done
	if self.items_that_were_clicked_sum >= self.items_that_need_clicked_sum then
		self.items_all_clicked = true
		print("All items that need to be clicked were clicked. \n")
	end

	-- finish process to click on and save data on items
	-- popup graph, which will also disable ocean script clicking
	-- also set color in data view for color and bar
	local final_item = valid_item_clicked or back_item_clicked or not_allowed_click
	if final_item ~= nil then
		local first_time_click
		if valid_item_clicked then
			first_time_click = true
		end
		On_GO_Item_Click_Labeled(self, clicked_info.minfo_screen_position, clicked_unique_tbl)
		On_GO_Item_Click_InputEnd(self, final_item, first_time_click)
	end

end


-- HUD Process: Screen Fader
local function Run_Fader(self, fade_out, time)

	-- run either fade in or fade out

	-- setup variables
	local fader_node = gui.get_node("gnode_screen_fader")
	local alpha, disable_at_end
	if fade_out then
		gui.set_enabled(fader_node, true)
		alpha = 1.0
		disable_at_end = false
	else
		alpha = 0.0
		disable_at_end = true
	end

	time = time or 2.0

	-- cancel any current fades
	gui.cancel_animation(fader_node, "color.w")

	-- declare callback for readability and thought of optimization
	local function func_set_status()
		if disable_at_end then
			gui.set_enabled(fader_node, false)
		end
	end

	-- run fader animation
	gui.animate(fader_node, "color.w", alpha, go.EASING_LINEAR, time, 0, func_set_status)

end


local function Close_All_Center_Screens(self)

	-- close any open screens in center window

	local run_sizing = false
	local enabled_status = false
	local reset_values = false

	-- popup/new info
	if self.hud_popup_dynamic.screen_isactive then
		Screen_Popup_Reset(self, enabled_status, run_sizing, reset_values)
	end

	-- decision
	if self.hud_decision_dynamic.screen_isactive then
		Screen_Decision_Reset(self, enabled_status, run_sizing, reset_values)
	end

	-- plot
	if self.hud_plot_dynamic.screen_isactive then
		Screen_Plot_Reset(self, enabled_status, run_sizing)
	end

	-- #TODO minimize data screen?

end

-- HUD Process: Game Loop
local function GameLogic_Progress(self, i_stage_addition)

	-- setups and runs next gameplay event

	if i_stage_addition == nil then
		i_stage_addition = 1
	end

	self.gameplay_loop_i_key = self.gameplay_loop_i_key + i_stage_addition

	local stage_key, substage_key = Get_Current_Stage_and_Substage(self)

	if stage_key == nil or substage_key == nil then
		print("Game loop is completed! \n")
		return
	end

	-- get and update goal text
	local goal_text = STR:Get_Goal_Text(stage_key, substage_key)
	local run_goal_sizing = not self.hud_goals_dynamic.screen_isactive
	if self.gameplay_loop_i_key > 1 then
		Screen_Goals_Reset(self, true, run_goal_sizing, goal_text)
	end

	-- run other logic
	self.gameplay_loop_status = CV_gameplay_loop.status_running_main

	-- close any other plots or popups or decisions
	Close_All_Center_Screens(self)

	-- get type of event and start associated screens
	local stage_type = STR:Get_Completion_Type(stage_key, substage_key)
	local st = STR.CV.goal_completed_types
	self.gameplay_loop_completion_type_primary = stage_type
	self.gameplay_loop_completion_type_secondary = stage_type

	print("Running stage <"..stage_key.."> with substage <"..substage_key.."> with completion type <"..stage_type.."> \n")

	if stage_type == st.class_click_items then
		-- setup clicking on items
		--#TODO get clicking items working
		On_GO_Items_Clicked_Reset(self, true)
		local items_to_click = STR:Get_Items_to_Click(stage_key, substage_key)
		Items_Click_Status_Reset(self, items_to_click)

		local popup_text_body = STR:Get_NewInfo_Text_Body(stage_key, substage_key)
		local run_sizer = true
		local reset_values = true
		Screen_Popup_Reset(self, true, run_sizer, reset_values, popup_text_body)

	elseif stage_type == st.class_decisison then
		-- setup decision
		local q_text = STR:Get_Decision_Text_Question(stage_key, substage_key, self.character_role_key)
		local a_tbl = STR:Get_Decision_Text_Options(stage_key, substage_key, self.character_role_key)
		local reset_values = true
		Screen_Decision_Reset(self, true, true, reset_values, #a_tbl, q_text, a_tbl)

	elseif stage_type == st.class_new_information then
		-- setup new information
		local popup_text_body = STR:Get_NewInfo_Text_Body(stage_key, substage_key)
		local run_sizer = true
		local reset_values = true
		Screen_Popup_Reset(self, true, run_sizer, reset_values, popup_text_body)

	end

end

local function GameLogic_Start(self)

	-- randomize random generator
	math.randomseed(socket.gettime())

	MY_GOO.acquire_input()

	msg.post("level_loader#collectionproxy", HSH.msg_builtin_load)
	self.game_paused = false

	local set_enabled = false

	Initialize_Local_Info_Tbl()

	-- reset save table
	Player_Data_Table_Reset(self)

	On_GO_Items_Clicked_Reset(self, set_enabled)
	Screen_Goals_Initialize(self, set_enabled)
	Screen_Decision_Initialize(self, set_enabled)
	Screen_Popup_Initialize(self, set_enabled)
	Screen_Data_Initialize(self, set_enabled)
	Screen_Plot_Initialize(self, set_enabled)

	-- reset click items tracker
	Items_Click_Status_Reset(self)

	self.input_is_possible = true

	self.character_role_key = "none"
	self.gameplay_loop_completion_type_primary = 0
	self.gameplay_loop_completion_type_secondary = 0
	self.gameplay_loop_i_key = 0

	-- get stage and substage list in order
	self.gameplay_loop_status = CV_gameplay_loop.status_unknown
	self.gameplay_loop_order = STR:GameOrder_CreateTable()

	-- kick off first action #TODO update to 4 once done testing
	timer.delay(0.0, false, function(self)
		GameLogic_Progress(self)
	end)

end

local function GamePauseToggle_Internal(self)

	-- pause by setting game update factor to 0
	self.game_paused = not self.game_paused

	local factor
	if self.game_paused then
		factor = 0
	else
		factor = 1
	end

	msg.post("level_loader#collectionproxy", HSH.msg_builtin_set_timestep, {factor = factor, mode = 1})
	msg.post("ocean_level:/level_controller#script", HSH.msg_pause_game_msg_sent, {minfo_game_paused = self.game_paused})

end

local function GamePauseToggle_Input(self, action_id, action)

	--#TODO testing remove when done
	if action_id == HSH.control_down and action.released then
		GamePauseToggle_Internal(self)
	end

end

local function GameHandleButtonInput(self, action_id, action)

	--#TODO testing remove when done

	if not action.released then return end

	--change weather
	if action_id == HSH.control_right or action_id == HSH.control_left then
		local is_supposed_to_rain = action_id == HSH.control_right
		-- if it is raining and we want it to rain then do nothing
		-- if it is not raining and we do not want it to rain then do nothing
		local wave_direction = math.random(0,1)
		msg.post("ocean_level:/level_controller", HSH.msg_request_change_weather, {minfo_is_raining=is_supposed_to_rain, minfo_wave_direction=wave_direction})
	end

	--trigger nutrient influx
	if action_id == HSH.control_up then
		msg.post("ocean_level:/level_controller", HSH.msg_request_run_coastal_oa, {minfo_percent_coastal_oa_hide = 0})
	end

end


function init(self)

	GameLogic_Start(self)

end

function on_message(self, message_id, message, sender)

	if message_id == HSH.msg_builtin_proxy_loaded then
		msg.post(sender, HSH.msg_builtin_enable)
	end

	if message_id == HSH.msg_request_fade_out or message_id == HSH.msg_request_fade_in then
		Run_Fader(self, message_id == HSH.msg_request_fade_out, message.minfo_fade_duration)
	elseif message_id == HSH.msg_report_go_clicked then
		On_GO_Item_Clicked_Received(self, message)
	elseif message_id == HSH.msg_request_game_progress then
		GameLogic_Progress(self, 1)
	elseif message_id == HSH.msg_request_game_repeat then

		-- reset save table if specified
		if message.minfo_reset_player_save then
			Player_Data_Table_Reset(self, true)
		end

		-- go to specified stage
		self.gameplay_loop_i_key = message.minfo_go_to_event_i or 0
		GameLogic_Progress(self, 0)

	elseif message_id == HSH.msg_set_player_character_role then
		self.character_role_key = message.minfo_role_name
	elseif message_id == HSH.msg_set_new_item_value then
		Player_Data_Table_RunScoreInput(self, message.minfo_item_score_update_tbl)
	end

end

function on_input(self, action_id, action)

	if not self.input_is_possible then return end

	Screen_Decision_Input(self, action_id, action)
	Screen_Data_Input(self, action_id, action)
	Screen_Plot_Input(self, action_id, action)
	Screen_Popup_Input(self, action_id, action)
	On_GO_Item_Clicked_Requested(self, action_id, action)

	GameHandleButtonInput(self, action_id, action)
	GamePauseToggle_Input(self, action_id, action)

end
