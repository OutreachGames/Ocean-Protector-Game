--OVERVIEW:
--setups and controls main HUD

-- dependencies
local HSH = require ("modules.hashes_md")
local MY_GOO = require ("gui.gooey_theme_md")
local STR = require ("modules.screenplay_md")
local EXT = require ("modules.extend_md")
local INFO = require("modules.item_info_md")
local GA = require("modules.custom_analytics_md")

-- constants
local CV_Current_Save_Version_Major = 4
local CV_Current_Save_Version_Minor = 1
local CV_ID_Ocean_Setup_Script = "ocean_level:/level_controller"
local CV_Application_ID = "Ocean_Protector"
local CV_Save_Player_File_Name = "player_data_save_file"
local CV_Save_GeneratedID_File_Name = "generated_id_save_file"
local CV_Player_Role_Empty = "not_yet_selected"
local CV_Node_Save_Icon = "gnode_saved_icon"

local CV_item_groups = {}

local CV_gameplay_loop = {
	status_running_main = 1,
	status_running_debrief = 2,
	status_unknown = 3
}

local CV_Bar_Old = vmath.vector4(0.80, 0.80, 0.80, 1)
local CV_Bar_Current = vmath.vector4(1.0, 1.0, 1.0, 1)

-- functions

local function Initialize_Local_Info_Tbl()

	for k_item_name,v_item_info in pairs(INFO.item_info) do
		if v_item_info.gui_info ~= nil then
			CV_item_groups[k_item_name] = v_item_info.gui_info
		end
	end

end

local function Get_Current_Stage_and_Substage(self)

	-- returns two string values for current stage and substage

	local event_info = self.gameplay_loop_order[self.player_data_tbl.gameplay_loop_i_key]

	if event_info == nil then
		print("Note: no valid event info exists for game loop key <"..tostring(self.player_data_tbl.gameplay_loop_i_key).."> \n")
		return nil, nil
	end

	local stage_key = event_info.stage_name_key
	local substage_key = event_info.substage_name_key

	return stage_key, substage_key

end

local function Loop_StatusType_is_Main(self)

	return self.gameplay_loop_status == CV_gameplay_loop.status_running_main

end

local function Loop_StatusType_is_Debrief(self)

	return self.gameplay_loop_status == CV_gameplay_loop.status_running_debrief

end

local function Loop_CompletionType_is_Primary(self, match_type)

	return match_type == self.gameplay_loop_completion_type_primary

end

local function Loop_CompletionType_is_Secondary(self, match_type)

	return match_type == self.gameplay_loop_completion_type_secondary

end

local function Valid_Event_Check_Full(self, match_loop_type)

	-- returns true if loop status type is main or debrief and if given completion type is primary or secondary, false otherwise 

	local status_valid = Loop_StatusType_is_Main(self) or Loop_StatusType_is_Debrief(self)

	local primary_or_secondary_valid = Loop_CompletionType_is_Primary(self, match_loop_type) or Loop_CompletionType_is_Secondary(self, match_loop_type)

	return (status_valid and primary_or_secondary_valid)

end

local function SimpleToggleHelper(self, controller_node, enabled_setting, run_sizing)

	-- simple open or close screen
	-- note, other screens have more complex things happening so this function is not used as often

	-- run enabling status and possibly sizing
	local function func_done(self, node)

		gui.set_enabled(node, enabled_setting)

	end

	if run_sizing then
		if enabled_setting then
			func_done(self, controller_node)
			gui.set_scale(controller_node, MY_GOO.MINIMIZE)
			gui.animate(controller_node, "scale", MY_GOO.MAXIMIZE, gui.EASING_OUTBACK, 0.50, 0)
		else
			--gui.set_scale(controller_node, MY_GOO.MAXIMIZE)
			gui.animate(controller_node, "scale", MY_GOO.MINIMIZE, gui.EASING_INBACK, 0.50, 0, func_done)
		end
	else
		func_done(self, controller_node)
	end

end

local function GeneratedID_Manage(self)

	-- loads a generated ID or makes one if file does not exist then save it

	-- get path
	local filename = sys.get_save_file(CV_Application_ID, CV_Save_GeneratedID_File_Name)

	-- load file
	local loaded_data = sys.load(filename)

	-- check and load ID or generate new one
	local loaded_id

	-- if exists, then set loaded value as generated ID
	if loaded_data ~= nil then
		loaded_id = loaded_data.generated_id_value
		--print("Loaded generated ID from file of <"..tostring(loaded_id)..">.\n")
	end

	-- if does not exist as file or file was read correctly, then generate new one
	-- keep this as separate check (do not use else check)
	-- b/c about loaded_id may be nil if it did not read correctly
	if loaded_id == nil then
		-- generate new one
		for _=1,3 do
			math.random()
		end
		loaded_id = math.random(100000, 999999)

		-- since we are generating it make sure to also save it
		-- if we loaded it that means it was already saved
		local save_successful = sys.save(filename, {generated_id_value = loaded_id})
		if not save_successful then
			print("Warning: Saving generated ID file was not successful!\n")
		end
	end

	-- finally save it for easy access
	--print("Setting generated ID of <"..tostring(loaded_id)..">.\n")
	self.generated_id_value = loaded_id

end


-- Player Data Updating, Setting, and Getting
local function PlayerData_IsValid(self, opt_id_tag)

	-- validity fail safes
	local ply_data = self.player_data_tbl
	if ply_data == nil then
		print("Error: the player data table does not exist. Optional ID tag <"..tostring(opt_id_tag)..">\n")
		return false
	end

	local items_data = ply_data.item_data_tbl
	if items_data == nil then
		print("Error: the item data table within the player data table does not exist. Optional ID tag <"..tostring(opt_id_tag)..">\n")
		return false
	end

	return true

end

local function PlayerData_CloudRecord(self, print_outcome)

	-- function to send report to cloud database

	-- error checking
	if not PlayerData_IsValid(self, "check_for_cloud_reporting") then
		return
	end

	-- variable setup
	local stage_key, substage_key = Get_Current_Stage_and_Substage(self)

	if stage_key == nil or substage_key == nil then
		--print("TRK: Game loop is not in valid state! \n")
		return
	end

	local st = STR.CV.goal_completed_types
	local stage_type = STR:Get_Completion_Type(stage_key, substage_key) or -1

	-- check stage types
	-- only save to cloud if not observe OA or click
	if EXT:equalAny(stage_type, {st.class_observe_method, st.class_click_items, -1}) then
		return
	end

	local ply = self.player_data_tbl
	local id_user = ply.id_key_user or 0000
	local plythrough_count = ply.id_playthrough_count or 1
	local character_role = ply.character_role_key or ""
	local choice_key = ply.most_recent_decision_choice_key or ""
	local duration = socket.gettime() - (self.game_logic_time_start or 0)

	local current_score
	local best_choices = ply.num_best_answers
	local total_answers = ply.num_total_answers
	if total_answers > 0 then
		current_score = best_choices/total_answers
	else
		current_score = ""
	end

	-- if decision then get extra data
	local decision_str, choice_str
	local is_final_outcome = "false"

	-- also set if this is where final player report card score is saved
	-- which will also be added to final outcome sheet
	if STR:Get_Summary_Report_Card(stage_key, substage_key) then
		is_final_outcome = "true"
	end

	if stage_type == st.class_decisison then
		-- recall choice keys are listed from best to worst, 
		-- so for individual entry can see easily which choice was selected
		decision_str = STR:Get_Decision_Cloud_String(stage_key, substage_key, character_role) or ""
		choice_str = STR:Get_Choice_Cloud_String(stage_key, substage_key, character_role, choice_key) or ""

	elseif stage_type == st.class_new_information then
		decision_str = STR:Get_NewInfo_Cloud_String(stage_key, substage_key) or ""
	else
		-- recall observe and click items are not valid by this point 
		-- since they have an early return
		decision_str = ""
		choice_str = ""
	end

	if print_outcome then
		print("Sending analytics to cloud database!\n")
	end

	local id_generated = self.generated_id_value or 999999

	-- compile and send report to cloud database
	-- keys must match value in script!
	-- https://docs.google.com/spreadsheets/d/1gisUU8HIs2_JcRbW2LxjusDa6IHTNBM-yAVTxverdCY
	-- any changes also make sure to re-deploy script then save new url in associated module!
	local cloud_send_tbl = {
		ga_key_id_user = id_user,
		ga_key_id_generated = id_generated,
		ga_key_id_playthrough_count = plythrough_count,
		ga_key_stage = stage_key,
		ga_key_substage = substage_key,
		ga_key_decision_str = decision_str,
		ga_key_character = character_role,
		ga_key_duration = duration,
		ga_key_completed_decisions = total_answers,
		ga_key_best_choices = best_choices,
		ga_key_current_score = current_score,
		ga_key_choice_str = choice_str,
		ga_is_final = is_final_outcome
		-- save player ID, stage key, substage key, duration, cloud_string or NA, secondary_key, secondary_cloud_string or NA
	}

	local url = GA.custom_spreadsheet_script_url
	local headers = {
		-- script already configured to take a JSON in Google Script, so no need to set it in header
	}
	if print_outcome then
		headers.Accept = "application/json"  -- we want a JSON response
	end

	local function handle_response(self, id, response)
		if print_outcome then
			print(response.status, response.response)
		end
	end

	http.request(url, "POST", handle_response, headers, json.encode(cloud_send_tbl))

end

local function PlayerData_Set_Character(self, role_key)

	-- changes player character variables and labels

	local human_data_label
	if role_key == nil then
		self.player_data_tbl.character_role_key = CV_Player_Role_Empty
		human_data_label = "Humans"
	else
		self.player_data_tbl.character_role_key = role_key
		local subitem_name = STR:Get_Subitem_from_Role(role_key)
		human_data_label = INFO:Get_Data_Item_Label("item_humans", subitem_name)
		-- remove current boat and update with new boat
		msg.post("ocean_level:/level_controller#script", HSH.msg_set_player_character_subitem, {minfo_subitem_boat_name = subitem_name})
	end

	-- use full string name since gauge tracking might not be initialized yet
	local data_human_label_node = gui.get_node("hud_data/group_item_humans/gnode_body_text")
	gui.set_text(data_human_label_node, human_data_label)

end

local function PlayerData_Update_SumBestChoices(self, value, override)

	value = value or 1
	if override then
		self.player_data_tbl.num_best_answers = value
	else
		self.player_data_tbl.num_best_answers = self.player_data_tbl.num_best_answers + value
	end

end

local function PlayerData_Update_SumTotalChoices(self, value, override)

	value = value or 1
	if override then
		self.player_data_tbl.num_total_answers = value
	else
		self.player_data_tbl.num_total_answers = self.player_data_tbl.num_total_answers + value
	end

end

local function PlayerData_Update_I_Key_Progress(self, new_ikey, override)

	-- update i stage

	new_ikey = new_ikey or 1
	if override then
		self.player_data_tbl.gameplay_loop_i_key = new_ikey
	else
		local current_val = self.player_data_tbl.gameplay_loop_i_key or 0
		self.player_data_tbl.gameplay_loop_i_key = current_val + new_ikey
	end

end

local function PlayerData_Update_Repeat_Count(self, new_ikey, override)

	-- update number of times repeat has occurred

	new_ikey = new_ikey or 1
	if override then
		self.player_data_tbl.id_playthrough_count = new_ikey
	else
		local current_val = self.player_data_tbl.id_playthrough_count or 1
		self.player_data_tbl.id_playthrough_count = current_val + new_ikey
	end

end

local function PlayerData_UpdateDecisionTracker(self, stage_key, substage_key, choice_key, override_instead_insert)

	-- adds an i-based entry to player save table for given decision choice
	-- needs to match up with item tracker scores (self.player_data_tbl.item_data_tbl)
	-- useful for things where we can't use i-key b/c it might have been a few stages ago

	if not PlayerData_IsValid(self, "Player Data Update Score Tracker") then
		return
	end

	local num_items = #self.player_data_tbl.decision_data_tbl
	local new_entry_i_index = num_items

	-- setup defaults
	local current_stage_key, current_substage_key = Get_Current_Stage_and_Substage(self)
	local current_choice_key = self.player_data_tbl.most_recent_decision_choice_key

	stage_key = stage_key or current_stage_key
	substage_key = substage_key or current_substage_key
	choice_key = choice_key or current_choice_key

	-- set or override values
	if override_instead_insert then
		new_entry_i_index = num_items
		self.player_data_tbl.decision_data_tbl[new_entry_i_index].selection_stage_key = stage_key
		self.player_data_tbl.decision_data_tbl[new_entry_i_index].selection_substage_key = substage_key
		self.player_data_tbl.decision_data_tbl[new_entry_i_index].selection_choice_key = choice_key
	else
		new_entry_i_index = num_items + 1
		self.player_data_tbl.decision_data_tbl[new_entry_i_index] = {
			selection_stage_key = stage_key,
			selection_substage_key = substage_key,
			selection_choice_key = choice_key
		}
	end

end

local function PlayerData_UpdateScoreTracker(self, item_key, delta_value, new_value, override_instead_insert)

	-- adds an i-based entry to player save table for given item key 
	-- needs to match up with decision tracker scores (self.player_data_tbl.decision_data_tbl)
	-- useful for things where we can't use i-key b/c it might have been a few stages ago

	if not PlayerData_IsValid(self, "Player Data Update Score Tracker") then
		return
	end

	local num_items = #self.player_data_tbl.item_data_tbl[item_key]

	local new_entry_i_index = num_items
	if override_instead_insert then
		-- override current value instead of insert new one
		new_entry_i_index = num_items
		self.player_data_tbl.item_data_tbl[item_key][new_entry_i_index].item_tracker_delta = new_value
		self.player_data_tbl.item_data_tbl[item_key][new_entry_i_index].item_tracker_score = new_value
		--print("TRK: overriding player data entry for item key <"..item_key.."> with value <"..tostring(new_value).."> and number index of <"..tostring(new_entry_i_index).."> \n")
	else
		-- insert new value
		new_entry_i_index = num_items + 1
		self.player_data_tbl.item_data_tbl[item_key][new_entry_i_index] = {item_tracker_delta = delta_value, item_tracker_score = new_value}
		--print("TRK: adding new player data entry for item key <"..item_key.."> with value <"..tostring(new_value).."> and number index of <"..tostring(new_entry_i_index).."> \n")
	end

end

local function PlayerData_UpdateHUDTracker(self, item_key, show_item, show_goto)

	local hud_tracker =  self.player_data_tbl.item_hud_status[item_key]
	if show_item ~= nil then
		hud_tracker.data_item_shown = show_item
	end
	if show_goto ~= nil then
		hud_tracker.data_goto_shown = show_goto
	end

end

local function PlayerData_Get_ItemTable(self, item_key)

	if not PlayerData_IsValid(self, "Player Data Get Item Table") then
		return nil
	end

	local item_data = self.player_data_tbl.item_data_tbl[item_key]

	if item_data == nil then
		print("Note: item key input of <"..tostring(item_key).."> to function 'Player Data Table Get Entry' is not matched with entry, returning nil")
	end

	return item_data

end

local function PlayerData_Get_Item_Entries_Sum(self, item_key)

	-- gets count of entries in player data table for given item key

	local item_tbl = PlayerData_Get_ItemTable(self, item_key)

	if item_tbl == nil then return 0 end

	return #item_tbl

end

local function PlayerData_Get_Item_Entry_I(self, item_key, i_key)

	-- gets an i-based entry from player save table for given item key and i-key

	local item_tbl = PlayerData_Get_ItemTable(self, item_key)
	if item_tbl == nil then
		-- redundant error message but that's okay
		print("Error: there is no entry in player data table for key <"..tostring(item_key).."> returning nil. ")
		return nil
	end

	-- default i-key is last in list
	local num_opts = #item_tbl
	i_key = i_key or num_opts

	-- allow for negative values 
	-- (ie -1 would be second to last value in list)
	if i_key < 0 then
		i_key = num_opts + i_key
	end

	return item_tbl[i_key]

end

local function PlayerData_Save(self)

	-- saves 'self.player_data_tbl' to file

	-- add in early return for dev testing if we don't want to save
	-- of if saving disabled for stage 
	--   (such as stage not does not make any sense alone, like observing OA)
	local stage_key, substage_key = Get_Current_Stage_and_Substage(self)
	if STR:Get_Game_Disable_Save(stage_key, substage_key) then
		return
	end

	-- get path
	local filename = sys.get_save_file(CV_Application_ID, CV_Save_Player_File_Name)

	-- save file
	local save_successful = sys.save(filename, self.player_data_tbl)
	if not save_successful then
		print("Warning: Saving player data file not successful!\n")
	else
		--print("Saving player data to file with i-key "..self.player_data_tbl.gameplay_loop_i_key.."\n")
		local saved_text_icon = gui.get_node(CV_Node_Save_Icon)

		local function func_end(self, node)
			gui.set_visible(node, false)
		end

		local function func_shrink(self, node)
			gui.animate(node, "scale", MY_GOO.MINIMIZE, gui.EASING_INSINE, 0.5, 1.25, func_end)
		end

		gui.cancel_animation(saved_text_icon, "scale")
		gui.set_scale(saved_text_icon, MY_GOO.MINIMIZE)
		gui.set_visible(saved_text_icon, true)
		gui.animate(saved_text_icon, "scale", MY_GOO.MAXIMIZE, gui.EASING_OUTSINE, 0.25, 0, func_shrink)

	end

end

local function PlayerData_Check_MaybeLoad(self, load_saved_file)

	-- loads player data save file into player data lua table
	-- returns true if load successful, false if otherwise

	-- load file, check 'self.player_data_tbl.save_file_version' 
	-- if ~= to CV_Current_Save_Version then do not load

	-- get path
	local ply_data_filename = sys.get_save_file(CV_Application_ID, CV_Save_Player_File_Name)

	-- load file
	local ply_loaded_data = sys.load(ply_data_filename)

	if ply_loaded_data ~= nil then
		local saved_version = ply_loaded_data.save_file_version_major or 0
		if saved_version >= CV_Current_Save_Version_Major then
			-- loaded data is valid so set as player data table for lua
			if load_saved_file then
				self.player_data_tbl = nil
				self.player_data_tbl = ply_loaded_data

				-- take care of special things that are saved
				msg.post(".", HSH.msg_request_resume_catchup)

			end
			--print("Loading player data from file with i-key "..self.player_data_tbl.gameplay_loop_i_key.."\n")
			return true
		else
			-- invalid version, so no load
			--print("Version is too old, not loading data!")
			return false
		end
	else
		-- no save file exists
		return false
	end

end


-- HUD Screen: Highlighter
local function Screen_Highlighter_Reset(self, enabled_setting, highlight_what)

	-- reset Highlighter screen of HUD

	-- default args
	if enabled_setting == nil then
		enabled_setting = false
	end

	local is_reset
	if highlight_what == nil then
		is_reset = true
		highlight_what = "show_key_reset"
	end

	local constant = self.hud_highlighter_constant
	local new_setup = constant.highlight_setup[highlight_what]

	if new_setup == nil then
		print("Error: function 'Screen Highlight Reset' provided with unrecognized highlight type key <"..tostring(highlight_what)..">")
		return
	end

	local new_size = new_setup.l_size
	local new_position = new_setup.l_position

	-- set enabled status
	local controller_node = gui.get_node(constant.node_controller)

	-- reset tracking table
	self.hud_highlighter_dynamic.screen_isactive = enabled_setting

	-- set highlighter size and position depending on what highlighting
	-- also set animation for blinking and set tint

	if enabled_setting then

		gui.set_enabled(controller_node, true)
		gui.cancel_animation(controller_node, "color")
		gui.set_position(controller_node, new_position)
		gui.set_size(controller_node, new_size)
		gui.set_color(controller_node, INFO.common_info.color_red_full)

		if is_reset then
			gui.set_visible(controller_node, false)
			gui.set_color(controller_node, INFO.common_info.color_white)
		else
			gui.set_visible(controller_node, true)
			gui.animate(controller_node, "color", INFO.common_info.color_red_flicker, gui.EASING_LINEAR, 1.5, 0, nil, gui.PLAYBACK_LOOP_PINGPONG)
		end

	else
		gui.cancel_animation(controller_node, "color")
		gui.set_color(controller_node, INFO.common_info.color_white)
		gui.set_position(controller_node, new_position)
		gui.set_size(controller_node, new_size)
		gui.set_enabled(controller_node, false)
	end

end

local function Screen_Highlighter_Initialize(self, enabled_status)

	-- set constants and setup dynamic values and components

	local basename = "hud_highlighter"

	self.hud_highlighter_constant = nil
	self.hud_highlighter_dynamic = nil

	-- set constants
	self.hud_highlighter_constant = {
		hud_basename = basename,
		node_controller = basename .. "/gui_frame_core",
		-- specify HUD highlighter areas
		highlight_setup = {
			-- note, we use a separate, non GUI highlighter, 
			--   since it can parent and move with coastal OA spawner
			--   and since coastal OA spawner has different starting positions based on amount to show
			show_key_reset = {l_position = vmath.vector3(0, 0, 0), l_size = vmath.vector3(32, 32, 0)},
			show_area_plankton = {l_position = vmath.vector3(127, 538, 0), l_size = vmath.vector3(278, 180, 0)},
			show_area_benthic = {l_position = vmath.vector3(800, 183, 0), l_size = vmath.vector3(1620, 390, 0)},
			show_area_pelagic = {l_position = vmath.vector3(800, 370, 0), l_size = vmath.vector3(1620, 400, 0)}
		}
	}

	-- set dynamics
	self.hud_highlighter_dynamic = {}
	Screen_Highlighter_Reset(self, enabled_status)

end


-- HUD Screen: Data (Section 1)
local function Items_Set_Color_Tracking(self, item_name, needs_to_be_clicked)

	-- set color in data view for color and bar

	--example: "hud_data/group_item_ph/gnode_controller"
	local hudinfo = self.hud_data_constant
	local item_base_groupname = hudinfo.goo_group_names[item_name]
	if item_base_groupname == nil then
		print("Error: Item name of <"..tostring(item_name).."> is not present in HUD Data Constant table ...\n")
		return
	end

	local color_text, color_bar

	if needs_to_be_clicked then
		color_text = MY_GOO.COLOR_NEEDS_SELECTED
		color_bar = MY_GOO.COLOR_NEEDS_SELECTED
	else
		color_text = MY_GOO.COLOR_TEXT_DEFAULT
		color_bar = MY_GOO.COLOR_DEFAULT
	end

	--update colors, goto button, health bar, and item label 
	local huditem_name = hudinfo.goo_group_names[item_name]
	if huditem_name == nil then
		print("Error: function 'Items SetColor Tracking' provided with not known item name of <"..tostring(item_name)..">\n")
		return
	end
	local node_gotto_button_core = gui.get_node(huditem_name..hudinfo.goo_item_gotograph..hudinfo.basename_item_button_core)
	gui.set_color(node_gotto_button_core, color_bar)

	gui.set_color(gui.get_node(item_base_groupname..hudinfo.basename_item_bar_progress), color_bar)
	gui.set_color(gui.get_node(item_base_groupname..hudinfo.basename_item_bar_label), color_text)

end

local function ScreenData_ToggleItem(self, item_name, toggle_status, update_item_status, update_goto_button_status)

	-- sets status of goto button and overall item within Data HUD section

	local hudinfo = self.hud_data_constant
	local huditem_name = hudinfo.goo_group_names[item_name]
	if huditem_name == nil then
		print("Error: function 'ScreenData ToggleItem' provided with not known item name of <"..tostring(item_name)..">\n")
		return
	end

	if toggle_status == nil then
		toggle_status = false
	end

	-- update overall item status
	if update_item_status then
		local node_item_controller = gui.get_node(huditem_name..hudinfo.basename_item_controller)
		gui.set_enabled(node_item_controller, toggle_status)
		-- record that in variable for saving, too
		PlayerData_UpdateHUDTracker(self, item_name, toggle_status, nil)
	end

	-- update goto button status
	if update_goto_button_status then
		local node_gotto_button_core = gui.get_node(huditem_name..hudinfo.goo_item_gotograph..hudinfo.basename_item_button_core)
		gui.set_enabled(node_gotto_button_core, toggle_status)
		-- record that in variable for saving, too
		PlayerData_UpdateHUDTracker(self, item_name, nil, toggle_status)
	end

end

local function Items_Click_Status_Reset(self, items_to_click_info)

	-- update tracker lists of what items need to be clicked and which items have been clicked

	self.items_all_clicked = true

	self.items_that_need_clicked_list = nil
	self.items_that_need_clicked_list = {}

	self.items_that_need_clicked_sum = 0
	self.items_that_were_clicked_sum = 0

	-- default is reset all items
	if items_to_click_info == "all_items_need_clicked" then
		--print("Default arg used, all items are going to be required to be clicked on...\n")
		items_to_click_info = {}
		for k,_ in pairs(CV_item_groups) do
			items_to_click_info[k] = {
				item_name = k,
				show_debrief_text = "",
				show_data_popup = nil,
				allow_duplicate_clicks = false,
				item_was_clicked = false
			}
		end
	end

	-- if there are items to add to 'needs click' list then add them
	-- also save that we have not clicked them all yet
	local sum_to_click = 0
	if type(items_to_click_info) == "table" then

		self.items_that_need_clicked_list = items_to_click_info

		-- count up items and set color
		for k_itemname,_ in pairs(items_to_click_info) do
			sum_to_click = sum_to_click + 1
			Items_Set_Color_Tracking(self, k_itemname, true)
		end

		-- saved click tracker variables
		if sum_to_click > 0 then
			self.items_all_clicked = false
			self.items_that_need_clicked_sum = sum_to_click
		end

	end

	--print("Sum to click is "..sum_to_click.."\n")

end

local function Screen_Data_TrackerUpdate(self, item_name)

	-- update progress bar(s), default is to update all bars

	local constant = self.hud_data_constant
	local items_to_update
	if item_name ~= nil then
		items_to_update = {}
		items_to_update[item_name] = true
	else
		items_to_update = constant.goo_group_names
	end

	--# recall that updating works on disabled node

	for k_itemname,_ in pairs(items_to_update) do
		local gui_groupname = constant.goo_group_names[k_itemname]
		-- get nodes
		local max_length_node = gui.get_node(gui_groupname..constant.basename_item_bar_max_x)
		local max_size = gui.get_size(max_length_node)
		-- get health percent
		local entry_health_data = PlayerData_Get_Item_Entry_I(self, k_itemname)
		if entry_health_data == nil then
			print("Error: current entry health data for 'Player Data Table Get Entry' function is nil, not updating...\n")
			return
		end
		local new_health_value = EXT:math_clamp(entry_health_data.item_tracker_score, 0, 1)
		-- set as new size
		local progress_node = gui.get_node(gui_groupname..constant.basename_item_bar_progress)
		local new_size = gui.get_size(progress_node)
		new_size.x = EXT:math_round(max_size.x * new_health_value, 0)
		gui.set_size(progress_node, new_size)
	end

end


-- HUD Screens: Graph Plot (Section 1)
local function Plot_Data_TrackerUpdate(self, item_key)

	-- updates bar heights for plot given item
	-- reminder all items use the same plot, so only one can be open at a time

	local number_entries = PlayerData_Get_Item_Entries_Sum(self, item_key)
	local constant = self.hud_plot_constant
	local max_graph_bars = constant.max_number_bars

	if number_entries > max_graph_bars then
		print("Error: number of graph bars <"..tostring(max_graph_bars).."> will not be able to accomdate this many player data entries <"..tostring(number_entries).."> ")
	end

	local time_shade_bars = false

	for i=1,max_graph_bars  do

		-- get nodes to update/show or hide
		local plot_id = constant.basename_individual_bar_group..i
		local progress_node = gui.get_node(plot_id..constant.basename_individual_bar_progress)
		local label_node = gui.get_node(plot_id..constant.basename_individual_bar_label)
		local set_visible

		-- if there is an i-match then make visible text and bar progress, otherwise hide visibility
		local entry_health_data = PlayerData_Get_Item_Entry_I(self, item_key, i)
		if entry_health_data ~= nil then
			-- get node sizes 
			local max_y_length_node = gui.get_node(plot_id..constant.basename_individual_bar_max_y)
			local max_size = gui.get_size(max_y_length_node)
			local new_size = gui.get_size(progress_node)
			-- get health percent
			local new_health_value = EXT:math_clamp(entry_health_data.item_tracker_score, 0, 1)
			new_size.y = EXT:math_round(max_size.y * new_health_value, 0)
			-- set as new size and enable visibility
			gui.set_size(progress_node, new_size)
			local label_text = constant.specified_bar_labels[i]
			gui.set_text(label_node, label_text or "")
			set_visible = true
		else
			set_visible = false
		end

		-- update colors, 0.9by default, 1.1 if most recently shown bar
		if time_shade_bars then
			if i == number_entries then
				gui.set_color(progress_node, CV_Bar_Current)
			else
				gui.set_color(progress_node, CV_Bar_Old)
			end
		end

		-- visibility accordingly
		gui.set_visible(label_node, set_visible)
		gui.set_visible(progress_node, set_visible)


	end

end


-- HUD Process: Observe Items (Section 1)
local function On_GO_Items_Clicked_Reset(self, enabled_setting)

	if enabled_setting == nil then
		enabled_setting = false
	end

	self.hud_can_select_go_items = enabled_setting

end

local function On_GO_Items_Clicked_Basic_Valid(self)

	-- failsafe for do not run if we are looking at decisions or plots
	-- the reset function of these should have 
	-- already set the clickable boolean, but this is a failsafe
	if self.hud_decision_dynamic.screen_isactive or self.hud_plot_dynamic.screen_isactive or self.hud_popup_dynamic.screen_isactive then
		return false
	end

	if self.hud_can_select_go_items then
		return true
	else
		return false
	end

end


-- HUD Process: Update Items 
local function QuestionScores_GetFinalPercent(self)

	local affected_total = self.num_player_affected_questions
	if affected_total <= 0 then
		-- edge case used in development testing where we removed all questions
		return 0
	else
		local checked_total = self.player_data_tbl.num_total_answers
		if affected_total ~= checked_total then
			print("Warning: player_data_tbl.num_total_answers of "..tostring(checked_total).." is not equal to self.num_player_affected_questions "..tostring(affected_total)..".\n")
		end
		return self.player_data_tbl.num_best_answers/affected_total
	end

end

local function PlayerData_RunScoreInput(self, score_tbl, override_instead_insert, was_best_choice, was_player_choice)

	-- takes a table with item keys and new delta scores and updates item scores in player save table accordingly

	-- validity fail safes
	if not PlayerData_IsValid(self, "Player Data Run Score Input") then
		return
	end

	-- save to decision tracker if needed
	if was_player_choice then
		PlayerData_Update_SumTotalChoices(self)
		-- add to best choice tally if needed
		if was_best_choice then
			PlayerData_Update_SumBestChoices(self)
		end
		PlayerData_UpdateDecisionTracker(self, nil, nil, nil, override_instead_insert)
	end

	-- do this by looping through things we can track and checking if they match what is in table with same string key
	for k_itemname,v_item_tracker_tbl in pairs(self.player_data_tbl.item_data_tbl) do
		-- get previous entry
		local previous_entry = v_item_tracker_tbl[#v_item_tracker_tbl] or {}
		local previous_score = previous_entry.item_tracker_score or 0

		-- get new delta by matching our known trackers with the score update table provided to function
		local delta_score = score_tbl[k_itemname] or score_tbl[1]

		--print("Update score for new entry for "..tostring(k_itemname).." is <"..tostring(delta_score).."> \n")

		-- only update if not nil
		-- remember, do not return or break since it breaks the loop matching
		if delta_score ~= nil then
			-- new value is previous + delta 
			-- clamp new entry between 0 and 1 so that next entry might have a visible positive effect
			-- IE if we did not clamp this may happened:
			--   new value gets -1.2 so that even a positive action next time does not show any benefit
			--   also visible bars are already clamped between 0 and 1 anyway
			local new_value = EXT:math_clamp(previous_score + delta_score, 0, 1)

			PlayerData_UpdateScoreTracker(self, k_itemname, delta_score, new_value, override_instead_insert)

			-- update hud data trackers done on click
		end

	end

end

local function Get_Coastal_OA_Percent_Helper(self)

	-- safe way of getting coastal OA percent from question choice
	-- can't use i-key b/c it might have been a few stages ago

	local decision_tbl = self.player_data_tbl.decision_data_tbl
	local length_decision_items = #decision_tbl
	local length_ph_trck = #self.player_data_tbl.item_data_tbl.item_ph
	if length_decision_items ~= length_ph_trck then
		print("Error: within 'Get Coastal OA Percent Helper' function, length_decision_items <"..tostring(length_decision_items).."> is not equal to length_ph_trck <"..tostring(length_ph_trck)..">\n")
	end

	-- get text for decision reminder
	local decision_info = decision_tbl[length_decision_items]
	local stage_key = decision_info.selection_stage_key
	local substage_key = decision_info.selection_substage_key
	local choice_key = decision_info.selection_choice_key
	local character_role = self.player_data_tbl.character_role_key

	return STR:Get_Choice_PercentCoastalOA(stage_key, substage_key, character_role, choice_key)

end

local function DynamicText_DecisionSummary(self)

	-- get dynamic text for decision summary

	local n = "\n"
	local indent = "    "

	-- make table that has delta change, most recent and second most recent
    local items_delta = {}
    for k_itemname,_ in pairs(CV_item_groups) do
        items_delta[k_itemname] = PlayerData_Get_Item_Entry_I(self, k_itemname).item_tracker_delta
    end

	-- make function to get text descriptions of change
	local function func_get_delta_text(percent_delta, is_ph)

		local magnitude_text
		local ph_extra

		if percent_delta > 0 then
			magnitude_text = "Increased"
			ph_extra = " (water is less acidic)"
		elseif percent_delta < 0 then
			magnitude_text = "Decreased"
			ph_extra = " (water is more acidic)"
		else
			magnitude_text = "Remained Relatively Stable"
			ph_extra = " (water acidity has not changed)"
		end

		if is_ph then
			magnitude_text = magnitude_text .. ph_extra
		end

		return magnitude_text

	end


	-- add summary debrief after clicking on items in each stage 
	-- no extra HUD screen with outcome question since it takes up too much space and player needs to be able to see things
	-- add message scroll back?
	-- for example, just a link to a PDF page with notes all written out, 
	-- and add this to message along with link at bottom to click to open page

	-- failsafe check for list length, by the time player decisions have rolled around 
	-- these should be equal in length and stay that way
	local decision_tbl = self.player_data_tbl.decision_data_tbl
	local length_decision_items = #decision_tbl
	local length_ph_trck = #self.player_data_tbl.item_data_tbl.item_ph
	if length_decision_items ~= length_ph_trck then
		print("Error: within 'Dynamic Text Decision Summary' function, length_decision_items <"..tostring(length_decision_items).."> is not equal to length_ph_trck <"..tostring(length_ph_trck)..">\n")
	end

	-- get text for decision reminder
	local decision_info = decision_tbl[length_decision_items]
	local stage_key = decision_info.selection_stage_key
	local substage_key = decision_info.selection_substage_key
	local choice_key = decision_info.selection_choice_key
	local character_role = self.player_data_tbl.character_role_key

	local decision_debrief = STR:Get_Choice_Text_Debrief(stage_key, substage_key, character_role, choice_key)

	-- get text for pH change
    local txt_ph = func_get_delta_text(items_delta.item_ph, true)

    -- get text for ocean life on average (yes just using pH since we want to reinforce that pH and ocean health are tied together)
    local txt_ocean_life = func_get_delta_text(items_delta.item_ph)

    -- get text for human
    local prefix_humans = INFO:Get_Y_Axis_Label("item_humans", STR:Get_Subitem_from_Role(character_role))..": "
    local txt_your_success = func_get_delta_text(items_delta.item_humans)

	-- compile
    local text_tbl = {
		dynamic_text_top_title = "Reminder of your decision:",
		dynamic_text_top_value = decision_debrief,

		--"You have observed and documented the effects of your decision, which are summarized below. ",

		dynamic_text_ph_title = "Change in Average Ocean pH:",
		dynamic_text_ph_value = txt_ph,

		dynamic_text_life_title = "Change in Health of Ocean Life:",
		dynamic_text_life_value = txt_ocean_life,

		dynamic_text_you_title = prefix_humans,
		dynamic_text_you_value = txt_your_success,

		dynamic_text_end_value = "When ready, click 'Continue' to move on."
    }

    return text_tbl

end

local function DynamicText_FinalDebrief(self, end_game_opt)

	-- get dynamic text for final debrief

    local n = "\n"
	local indent = "    "

    -- make table that has all final - initial values for all items
    local items_delta = {}
    for k_itemname,_ in pairs(CV_item_groups) do
        local val_change_start = PlayerData_Get_Item_Entry_I(self, "item_ph", 1).item_tracker_score
        local val_change_end = PlayerData_Get_Item_Entry_I(self, "item_ph").item_tracker_score
        local val_delta = val_change_end - val_change_start
        local percent_delta = (val_delta/val_change_start)
        items_delta[k_itemname] = percent_delta
    end

	-- make function to get text descriptions of change
    local function func_get_delta_text(percent_delta, is_ph, extra_special_acidity_case)

        -- get net change 
        local net_change_text
		local ph_suffix

        if percent_delta > 0.1 then
			net_change_text = "Increased"
			ph_suffix = " (water is less acidic)"
        elseif percent_delta < -0.1 then
            net_change_text = "Decreased"
			ph_suffix = " (water is more acidic)"
		else
			net_change_text = "Remained Relatively Stable"
			ph_suffix = " (water acidity has not changed)"
        end

        -- get size of change
        local magnitude_val = math.abs(percent_delta)
        local magnitude_text
        if magnitude_val > 0.8 then
            magnitude_text = "Substantially"
        elseif percent_delta > 0.5 then
            magnitude_text = "Moderately"
        elseif percent_delta > 0.5 then
            magnitude_text = "Slightly"
        end

        -- combine and return
        local combined_text = ""
        if net_change_text ~= nil and magnitude_text ~= nil then
            combined_text = magnitude_text .. " " .. net_change_text
        else
            combined_text = net_change_text
        end

		if is_ph then
			combined_text = combined_text .. ph_suffix
		end

        if extra_special_acidity_case then
			if magnitude_text == nil then
				magnitude_text = ""
			else
				magnitude_text = magnitude_text.." "
			end
            if percent_delta > 0.1 then
                combined_text = "On average, the ocean became "..string.lower(magnitude_text).."less acidic."
            elseif percent_delta < -0.1 then
                combined_text = "On average, the ocean became "..string.lower(magnitude_text).."more acidic."
            else
                combined_text = "On average, the acidity of the ocean water remained about the same."
            end
        end

        return combined_text

    end

	-- get text for co2
	-- add or keep excluded? (uncomment in compile table if adding back in)
	-- already mention in recommendations how to reduce, so keep out for now?...
	--local txt_co2 = "Average Annual Carbon Dioxide Emissions and Nutrient Pollution:"..n..indent..func_get_delta_text(-items_delta.item_ph)

	-- get text for pH
    local txt_ph = func_get_delta_text(items_delta.item_ph, true)
	-- maybe add extra summary sentence?
	--txt_ph = txt_ph ..n..n..func_get_delta_text(items_delta.item_ph, false, true)

    -- get text for ocean life on average (yes just using pH since we want to reinforce that pH and ocean health are tied together)
    local txt_ocean_life = func_get_delta_text(items_delta.item_ph)

    -- get text for human
    local prefix_humans = INFO:Get_Y_Axis_Label("item_humans", STR:Get_Subitem_from_Role(self.player_data_tbl.character_role_key))..": "
    local txt_your_success = func_get_delta_text(items_delta.item_humans)

    -- get text for recommendation
    local final_score = QuestionScores_GetFinalPercent(self)
    local txt_recomendations

    local good_suffix = "helped reduce ocean acidification, increased the health of ocean life, and improved your character goals."
    local reminder_suffix = "choices that help reduce energy usage and/or nutrient pollution are effective ways to help prevent ocean acidification. "
    local try_again_txt
	if end_game_opt then
		try_again_txt = "Don't forget, you can rerun the game, too. Just click 'Continue' to go back to the end options screen."
	else
		try_again_txt = "You will soon have an option to rerun the game, too. "
	end

    -- recall that many questions have 0 change, so while they may not help as much they also do not hinder as much
    if final_score == 100 then
        txt_recomendations = "Fantastic work with the questions. Every choice you made "..good_suffix.." As you have shown,"..reminder_suffix
    elseif final_score > 70 then
        txt_recomendations = "Very good work with the questions. Most of the choices you made "..good_suffix.." A few of the other choices did not result in outcomes that were as beneficial. Remember,"..reminder_suffix
    elseif final_score > 40 then
        txt_recomendations = "Good work with the questions. Many of the choices you made "..good_suffix.." Other choices did not result in outcomes that were as beneficial. Remember,"..reminder_suffix
    else
		--"It can be tricky to know what the best choice might be for each question. " --might be too much reading
        txt_recomendations = "Good effort with the questions. Even if ocean health and your character goals may not have improved, it is still very useful to learn about how different choices lead to different outcomes. Remember,"..reminder_suffix
    end

	-- compile

	local text_tbl = {
		dynamic_text_top_title = "Summary of your decisions:",
		dynamic_text_top_value = txt_recomendations,

        --"Percentage of decisions with most optimal choices: "..n..indent..string.format("%.0f", (final_score*100)).."% "..n,
        -- ^possibly remove/comment out?

        --"Summary of changes over time:",
		--txt_co2, "",
		-- ^possibly add in?

		dynamic_text_ph_title = "Average Annual Ocean pH:",
		dynamic_text_ph_value = txt_ph,

		dynamic_text_life_title = "Average Health of Ocean Life:",
		dynamic_text_life_value = txt_ocean_life,

		dynamic_text_you_title = prefix_humans,
		dynamic_text_you_value = txt_your_success,

		dynamic_text_end_value = try_again_txt
    }

    return text_tbl

end


-- HUD Screen: Goals
local function Screen_Goals_Reset(self, enabled_setting, run_sizing, text)

	-- reset Goals screen of HUD

	-- default args
	if enabled_setting == nil then
		enabled_setting = false
	end

	-- set enabled status
	local constant = self.hud_goals_constant
	local controller_node = gui.get_node(constant.node_controller)

	-- run enabling status and possibly sizing
	local function func_done(self, node)

		gui.set_enabled(node, enabled_setting)

		-- enable and set text if new
		local text_node = gui.get_node(constant.node_text_body)
		if text ~= nil then
			gui.set_text(text_node, text)
		end

		-- try to resize hud screen so text fits
		local shown_text = gui.get_text(text_node)
		local str_length = #shown_text

		-- 220ish is base with 2 lines and 330ish is with 5 lines, 100/3
		local line_per_extra_y = 32
		local min_frame_y = 220
		local str_length_per_line = 15
		local base_num_lines = 2

		local num_extra_lines = math.max((str_length/str_length_per_line) - base_num_lines, 0)
		local new_y_frame = math.max(min_frame_y + (num_extra_lines*line_per_extra_y), min_frame_y)

		local frame_node = gui.get_node(constant.node_frame_core)
		gui.set_size(frame_node, vmath.vector3(gui.get_size(frame_node).x, new_y_frame, 0))

	end

	if run_sizing then
		if enabled_setting then
			func_done(self, controller_node)
			gui.set_scale(controller_node, MY_GOO.MINIMIZE)
			gui.animate(controller_node, "scale", MY_GOO.MAXIMIZE, gui.EASING_OUTBACK, 0.50, 0)
		else
			--gui.set_scale(controller_node, MY_GOO.MAXIMIZE)
			gui.animate(controller_node, "scale", MY_GOO.MINIMIZE, gui.EASING_INBACK, 0.50, 0, func_done)
		end
	else
		func_done(self, controller_node)
	end

	-- reset tracking table
	self.hud_goals_dynamic.screen_isactive = enabled_setting

	if enabled_setting and not self.player_data_tbl.special_setup_goals_hud_enabled then
		self.player_data_tbl.special_setup_goals_hud_enabled = true
	end

end

local function Screen_Goals_Initialize(self, enabled_status)

	-- set constants and setup dynamic values and components

	local basename = "hud_goals"

	self.hud_goals_constant = nil
	self.hud_goals_dynamic = nil

	-- set constants
	self.hud_goals_constant = {
		hud_basename = basename,
		node_controller = basename .. "/gnode_controller",
		node_text_title = basename .. "/gnode_header_text",
		node_text_body = basename .. "/gnode_body_text",
		node_frame_core = basename .. "/group_frame/gui_frame_core"
	}

	-- set dynamics
	self.hud_goals_dynamic = {}
	Screen_Goals_Reset(self, enabled_status)

end

local function Screen_Goals_Input(self, action_id, action)

	-- runs 'On Input' for Goals screen on HUD

	-- early out if not allowed to use
	if not self.hud_goals_dynamic.screen_isactive then
		return
	end

	local Hud_info = self.hud_goals_constant

end


-- HUD Screen: Popup 
local function Screen_Popup_Reset(self, enabled_setting, run_sizing, reset_values, body_text, title_text, size_type, is_dynamic, op_hyperlink, special_image_id)

	-- reset Popup screen of HUD

	-- default args
	if enabled_setting == nil then
		enabled_setting = false
	end
	if reset_values == nil then
		reset_values = false
	end

	-- set enabled status
	local constant = self.hud_popup_constant
	local node_controller_main = gui.get_node(constant.node_controller_main)
	local node_controller_review = gui.get_node(constant.node_controller_review)
	local node_hyperlink_button = gui.get_node(constant.node_optional_hyperlink)
	local node_special_image = gui.get_node(constant.node_special_image)

	-- leave on more dynamic options if not resetting values
	-- in other words, disable more dynamic nodes if resetting
	if reset_values then
		gui.set_enabled(node_controller_review, false)
		gui.set_enabled(node_hyperlink_button, false)
		gui.set_visible(node_special_image, false)
	end

	-- enable and set text, but only if enabling
	-- do this before sizing so text sizer can be used
	if enabled_setting and reset_values then

		-- check if using dynamic special text
		-- and override some values if so
		if is_dynamic then
			size_type = "size_huge"
			self.hud_popup_dynamic.overall_size = size_type

			-- get which type of dynamic text is being used
			local text_tbl

			if body_text == HSH.helper_outcome_final_debrief_1 or body_text == HSH.helper_outcome_final_debrief_2 then
				title_text = "Final Summary"
				local is_final_2 = (body_text == HSH.helper_outcome_final_debrief_2)
				text_tbl = DynamicText_FinalDebrief(self, is_final_2)
			elseif body_text == HSH.helper_outcome_decision_summary then
				title_text = "Decision Summary"
				text_tbl = DynamicText_DecisionSummary(self)
			end

			-- now reset body text to blank since using dynamic text
			body_text = " "

			-- set dynamic text if specified
			if text_tbl ~= nil then
				-- enable
				gui.set_enabled(node_controller_review, true)

				-- set text using specific keys
				for k_tblkey, v_nodename in pairs(constant.node_special_text_tbl) do
					local l_text = text_tbl[k_tblkey]
					if l_text == nil then
						print("Warning: Text not found for key "..k_tblkey.."\n")
						l_text = ""
					end
					gui.set_text(gui.get_node(v_nodename), l_text)
				end

			end

		end

		-- setup body text
		if body_text ~= nil then
			gui.set_text(gui.get_node(constant.node_text_body), body_text)

			-- also try to auto size if none specified
			if size_type == nil then
				local _, counted_newlines = body_text:gsub('\n', '\n')
				local num_lines_guess = math.max(counted_newlines, #body_text/80)
				if num_lines_guess > 12 then
					size_type = "size_huge"
				elseif num_lines_guess > 8 then
					size_type = "size_large"
				elseif num_lines_guess > 3 then
					size_type = "size_medium"
				else
					size_type = "size_small"
				end
				self.hud_popup_dynamic.overall_size = size_type or "size_medium"
			end

		end

		-- setup title text
		title_text = title_text or "New Information"
		if title_text ~= nil then
			gui.set_text(gui.get_node(constant.node_text_title), title_text)
		end

		-- set hyperlink button
		if op_hyperlink ~= nil and op_hyperlink ~= "" then
			gui.set_enabled(node_hyperlink_button, true)
			self.hud_popup_dynamic.optional_hyperlink_address = op_hyperlink
		end

		-- set special image on or off
		if special_image_id ~= nil then
			gui.set_visible(node_special_image, true)
			gui.play_flipbook(node_special_image, special_image_id)
		end

	end

	-- run enabling status and possibly sizing
	local function func_done(self, node)

		gui.set_enabled(node, enabled_setting)

	end

	if run_sizing then
		if enabled_setting then
			-- prep for sizing
			func_done(self, node_controller_main)

			gui.set_scale(node_controller_main, MY_GOO.MINIMIZE)

			-- get and set sizing
			local y_ranges = {
				-- y values for 1) body frame, 2) body text, 3) lower buttons, 4) special image
				size_small = {250, 119, 108, 230},
				size_medium = {400, 258, -51, 86},
				size_large = {600, 468, -251, -38},
				size_huge = {820, 680, -465, -248},
			}

			local yvals = y_ranges[self.hud_popup_dynamic.overall_size]

			-- get nodes
			local node_body_frame = gui.get_node(constant.node_frame_body)
			local node_body_text = gui.get_node(constant.node_text_body)
			local node_button_frame = gui.get_node(constant.node_continue_frame)

			-- set node sizes
			gui.set_size(node_body_frame, vmath.vector3(gui.get_size(node_body_frame).x, yvals[1], 0))
			gui.set_size(node_body_text, vmath.vector3(gui.get_size(node_body_text).x, yvals[2], 0))

			-- set node positions
			gui.set_position(node_button_frame, vmath.vector3(gui.get_position(node_button_frame).x, yvals[3], 0))
			gui.set_position(node_hyperlink_button, vmath.vector3(gui.get_position(node_hyperlink_button).x, yvals[3], 0))
			gui.set_position(node_special_image, vmath.vector3(gui.get_position(node_special_image).x, yvals[4], 0))

			gui.animate(node_controller_main, "scale", MY_GOO.MAXIMIZE, gui.EASING_OUTBACK, 0.50, 0)
		else
			--gui.set_scale(node_controller_main, MY_GOO.MAXIMIZE)
			gui.animate(node_controller_main, "scale", MY_GOO.MINIMIZE, gui.EASING_INBACK, 0.50, 0, func_done)
		end
	else
		func_done(self, node_controller_main)
	end

	-- exit if not resetting answer option tracker variables
	if not reset_values then return end

	-- reset tracking table
	self.hud_popup_dynamic.screen_isactive = enabled_setting
	self.hud_popup_dynamic.overall_size = size_type or "size_medium"

end

local function Screen_Popup_Initialize(self, enabled_status)

	-- set constants and setup dynamic values and components

	local basename = "hud_newinfo"

	self.hud_popup_constant = nil
	self.hud_popup_dynamic = nil

	-- set constants
	self.hud_popup_constant = {
		hud_basename = basename,
		node_controller_main = basename .. "/gnode_controller_main",
		node_text_title = basename .. "/group_header/gui_frame_text",
		node_text_body = basename .. "/gnode_info_text_main",
		node_frame_body = basename .. "/group_body/gui_frame_core",
		node_continue_frame = basename .. "/group_button_submit/gui_button_core",
		node_continue_text = basename .. "group_button_submit/gui_button_label",
		goo_continue_name = basename .. "/group_button_submit",
		node_controller_review = basename .. "/gnode_review_controller",
		node_special_text_tbl = {
			-- need to match output of DynamicText_DecisionSummary and DynamicText_FinalDebrief
			dynamic_text_top_title = basename .. "/gnode_review_top_title",
			dynamic_text_top_value = basename .. "/gnode_review_top_value",

			dynamic_text_ph_title = basename .. "/gnode_review_ph_title",
			dynamic_text_ph_value = basename .. "/gnode_review_ph_value",

			dynamic_text_life_title = basename .. "/gnode_review_life_title",
			dynamic_text_life_value = basename .. "/gnode_review_life_value",

			dynamic_text_you_title = basename .. "/gnode_review_you_title",
			dynamic_text_you_value = basename .. "/gnode_review_you_value",

			dynamic_text_end_value = basename .. "/gnode_review_end"
		},
		goo_optional_hyperlink = basename .. "/group_button_hyperlink",
		node_optional_hyperlink = basename .. "/group_button_hyperlink/gui_button_core",
		node_special_image = basename .. "/gnode_special_image"
	}

	-- set dynamics
	self.hud_popup_dynamic = {}
	local run_sizing = false
	local reset_values = true
	Screen_Popup_Reset(self, enabled_status, run_sizing, reset_values)

end

local function Screen_Popup_Input(self, action_id, action)

	-- runs 'On Input' for Popup screen on HUD

	-- early out if not allowed to use
	if not self.hud_popup_dynamic.screen_isactive or self.hud_decision_dynamic.screen_isactive or self.hud_plot_dynamic.screen_isactive then
		return
	end

	local Hud_info = self.hud_popup_constant
	local hyperlink = self.hud_popup_dynamic.optional_hyperlink_address

	local function func_continue(button)

		-- handle all the button functionality

		-- set that this screen is no longer interactive
		local run_sizing = false
		local reset_values = true
		Screen_Popup_Reset(self, false, run_sizing, reset_values)

		--print("Continue Button was pressed")

		local new_info_loop_type = STR.CV.goal_completed_types.class_new_information

		if Valid_Event_Check_Full(self, new_info_loop_type) then

			-- if primary loop type is new_info and not in debrief then run debrief check
			-- if that is not the case, then it means we got to this new_info via
			-- some kind of debrief, whether it is a debrief of a new_info, decision, or item_click
			if Loop_CompletionType_is_Primary(self, new_info_loop_type) and Loop_StatusType_is_Main(self) then

				local stage_key, substage_key = Get_Current_Stage_and_Substage(self)
				local debrief_text, is_debrief_dynamic, opt_link = STR:Get_NewInfo_Text_Debrief(stage_key, substage_key)
				local debrief_title_text = STR:Get_NewInfo_Title_Debrief(stage_key, substage_key)

				-- if there is debrief for this new_info screen then run it, 
				-- otherwise finish up 
				if debrief_text ~= nil and debrief_text ~= "" then
					self.gameplay_loop_status = CV_gameplay_loop.status_running_debrief
					self.gameplay_loop_completion_type_secondary = STR.CV.goal_completed_types.class_new_information
					local run_sizing_debrief = true
					local update_values_to_debrief = true
					local special_image_str = STR:Get_NewInfo_Special_Image_Debrief(stage_key, substage_key)
					Screen_Popup_Reset(self, true, run_sizing_debrief, update_values_to_debrief, debrief_text, debrief_title_text, nil, is_debrief_dynamic, opt_link, special_image_str)
				else
					STR:Run_Generic_OutcomeFunc(stage_key, substage_key)
					msg.post(".", HSH.msg_request_game_progress)
				end

			else
				-- in some form of debrief 
				-- if debrief of new_info then run new_info completion function if any exists before just progressing. 
				-- this is b/c the event type we came from to this stage 
				-- is not a new_info and already had it's outcome func ran 
				-- update here with additional types as needed, might not always want to run progress
				local progress_to_next_stage = false

				if Loop_CompletionType_is_Primary(self, new_info_loop_type) then
					progress_to_next_stage = true
				elseif Loop_CompletionType_is_Primary(self, STR.CV.goal_completed_types.class_click_items) then
					if self.items_all_clicked then
						progress_to_next_stage = true
					end
				else
					progress_to_next_stage = true
				end

				if progress_to_next_stage then
					local stage_key, substage_key = Get_Current_Stage_and_Substage(self)
					STR:Run_Generic_OutcomeFunc(stage_key, substage_key)
					msg.post(".", HSH.msg_request_game_progress)
				end
			end

		end

	end

	local function func_hyperlink(button)

		sys.open_url(hyperlink)

	end

	-- submit button
	MY_GOO.button_simple(Hud_info.goo_continue_name, action_id, action, func_continue)

	-- optional hyperlink button
	if hyperlink ~= nil and hyperlink ~= "" then
		MY_GOO.button_simple(Hud_info.goo_optional_hyperlink, action_id, action, func_hyperlink)
	end

end


-- HUD Screen: Decision
local function Screen_Decision_Reset(self, enabled_setting, run_sizing, reset_tracker_variables, num_options, question_text, answer_text_tbl, hint_text, title)

	-- reset Decision screen of HUD

	-- default args
	if enabled_setting == nil then
		enabled_setting = false
	end
	if reset_tracker_variables == nil then
		reset_tracker_variables = false
	end
	if num_options == nil then
		num_options = self.hud_decision_dynamic.number_answer_options or 3
	end

	-- set enabled status
	local constant = self.hud_decision_constant
	local controller_node = gui.get_node(constant.node_controller)

	local has_specific_hint_text
	if hint_text ~= nil and hint_text ~= "" then
		has_specific_hint_text = true
	end

	-- run enabling status and possibly sizing
	local function func_done(self, node)

		gui.set_enabled(node, enabled_setting)

		-- always disable hint box and hint button
		-- will enable below if enabling screen
		gui.set_text(gui.get_node(constant.node_hint_button_text), "Show Hint")
		local hint_button_frame = gui.get_node(constant.node_hint_button_frame)
		gui.set_enabled(hint_button_frame, false)
		gui.set_enabled(gui.get_node(constant.node_hint_subcontroller), false)

		-- get which buttons to enable/disable when starting up/enabling
		-- disable all buttons to start except for those that will be used
		if enabled_setting then
			for i_node_num,v_node_id in ipairs(constant.goo_option_names) do
				local status = false
				if i_node_num <= num_options then
					status = true
				end
				gui.set_enabled(gui.get_node(v_node_id..constant.goo_option_core_basename), status)
				gui.set_enabled(gui.get_node(v_node_id..constant.goo_option_label_basename), status)
			end

			-- set base position and height of frame and submit button depending on number of options
			local pos_update = constant.goo_option_placement[num_options]
			gui.set_position(node, vmath.vector3(gui.get_position(node).x, pos_update.frame_position_y, 0))

			local frame_node = gui.get_node(constant.node_frame)
			gui.set_size(frame_node, vmath.vector3(gui.get_size(frame_node).x, pos_update.frame_ylength, 0))

			local button_node = gui.get_node(constant.node_submit_button_frame)
			local current_pos_button = gui.get_position(button_node)
			gui.set_position(button_node, vmath.vector3(current_pos_button.x, pos_update.submit_position_y, 0))

			-- enable hint button if hint present
			-- also set hint text now, too
			if has_specific_hint_text then

				local hint_button_pos = vmath.vector3(-current_pos_button.x, pos_update.submit_position_y, 0)
				local hint_txt_controller_node = gui.get_node(constant.node_hint_subcontroller)

				gui.set_enabled(hint_button_frame, true)

				gui.set_position(hint_button_frame, hint_button_pos)
				gui.set_position(hint_txt_controller_node, hint_button_pos)
				gui.set_text(gui.get_node(constant.node_hint_body_text), hint_text)
			end

			-- if not resetting values (ie coming from closing plot screen) 
			-- then enable hint if it is supposed to be enabled
			if not reset_tracker_variables and self.hud_decision_dynamic.has_hint_available then
				gui.set_enabled(hint_button_frame, true)
			end

		end

	end

	if run_sizing then
		if enabled_setting then
			func_done(self, controller_node)
			gui.set_scale(controller_node, MY_GOO.MINIMIZE)
			gui.animate(controller_node, "scale", MY_GOO.MAXIMIZE, gui.EASING_OUTBACK, 0.50, 0)
		else
			--gui.set_scale(controller_node, MY_GOO.MAXIMIZE)
			gui.animate(controller_node, "scale", MY_GOO.MINIMIZE, gui.EASING_INBACK, 0.50, 0, func_done)
		end
	else
		func_done(self, controller_node)
	end

	-- exit if not resetting answer option tracker variables
	if not reset_tracker_variables then return end

	-- reset tracking table
	self.hud_decision_dynamic.screen_isactive = enabled_setting
	self.hud_decision_dynamic.goo_option_selected = 0
	self.hud_decision_dynamic.goo_sumbit_isactive = false
	self.hud_decision_dynamic.number_answer_options = num_options
	self.hud_decision_dynamic.has_hint_available = has_specific_hint_text
	self.hud_decision_dynamic.hint_box_is_open = false

	-- actually reset radio nodes, including resetting text color
	for _,v_nodeid in ipairs(constant.goo_option_names) do
		gui.set_color(gui.get_node(v_nodeid..constant.goo_option_label_basename), MY_GOO.COLOR_TEXT_DEFAULT)
		MY_GOO.radio(v_nodeid).set_selected(false)
	end

	-- set tint on button to dark/locked
	gui.set_color(gui.get_node(constant.node_submit_button_frame), MY_GOO.COLOR_LOCKED)
	gui.set_color(gui.get_node(constant.node_submit_button_text), MY_GOO.COLOR_LOCKED)

	-- set text body and title
	if question_text ~= nil then
		gui.set_text(gui.get_node(constant.node_question_text), question_text)
	end

	title = title or "Decision"
	gui.set_text(gui.get_node(constant.node_question_title), title)

	-- update answer option text and save keys in same order
	self.hud_decision_dynamic.answer_choice_keys = nil
	self.hud_decision_dynamic.answer_choice_keys = {}
	if type(answer_text_tbl) == "table" then
		for i,v_info in ipairs(answer_text_tbl) do
			local q_node_name = constant.goo_option_names[i]..constant.goo_option_label_basename
			gui.set_text(gui.get_node(q_node_name), v_info.choice_text_answer)
			--print("Setting node <"..q_node_name.."> to text <"..v_info.choice_text_answer.."> \n")
			self.hud_decision_dynamic.answer_choice_keys[i] = v_info.user_choice_key
		end
	end

end

local function Screen_Decision_Initialize(self, enabled_status)

	-- set constants and setup dynamic values and components

	local basename = "hud_decision"

	self.hud_decision_constant = nil
	self.hud_decision_dynamic = nil

	-- set constants
	self.hud_decision_constant = {
		hud_basename = basename,
		node_controller = basename .. "/gnode_controller",
		node_frame = basename .. "/group_body/gui_frame_core",
		node_question_text = basename .. "/gnode_question_text",
		node_question_title = basename .. "/group_header/gui_frame_text",
		goo_option_placement = {
			{frame_ylength = 740, frame_position_y = 450, submit_position_y = -368},
			{frame_ylength = 740, frame_position_y = 450, submit_position_y = -368},
			{frame_ylength = 740, frame_position_y = 450, submit_position_y = -368},
			{frame_ylength = 868, frame_position_y = 536, submit_position_y = -495}
		},
		goo_option_names = {
			basename.."/group_option_1",
			basename.."/group_option_2",
			basename.."/group_option_3",
			basename.."/group_option_4"
		},
		goo_option_label_basename = "/gui_radio_label",
		goo_option_core_basename = "/gui_radio_core",
		goo_submit_name = basename.."/group_button_submit",
		goo_hint_name = basename.."/group_button_hint",
		goo_review_sheet_name = basename.."/group_button_review_sheet",
		node_submit_button_frame = basename.."/group_button_submit/gui_button_core",
		node_submit_button_text = basename.."/group_button_submit/gui_button_label",
		node_hint_subcontroller = basename .. "/gnode_hint_box_subcontroller",
		node_hint_button_frame = basename .. "/group_button_hint/gui_button_core",
		node_hint_button_text = basename .. "/group_button_hint/gui_button_label",
		node_hint_body_text = basename .. "/gnode_hint_box_body"
	}

	-- set dynamics
	self.hud_decision_dynamic = {}
	local run_sizer = false
	local reset_answers = true
	Screen_Decision_Reset(self, enabled_status, run_sizer, reset_answers)

end

local function Screen_Decision_Input(self, action_id, action)

	-- runs 'On Input' for Decision screen on HUD

	-- early out if not allowed to use
	if not self.hud_decision_dynamic.screen_isactive or self.hud_plot_dynamic.screen_isactive then
		return
	end

	local Hud_info = self.hud_decision_constant
	local num_options = self.hud_decision_dynamic.number_answer_options

	local function func_radiogroup(local_group_id, local_action_id, local_action)

		-- handles all the radio functionality

		local function radio_base(index)

			-- run the logic when radio selected

			-- set the selected index and allow the submit button
			self.hud_decision_dynamic.goo_option_selected = index
			self.hud_decision_dynamic.goo_sumbit_isactive = true
			gui.set_color(gui.get_node(Hud_info.node_submit_button_frame), MY_GOO.COLOR_DEFAULT)
			gui.set_color(gui.get_node(Hud_info.node_submit_button_text), MY_GOO.COLOR_TEXT_DEFAULT)

			-- visually highlight which choice was selected
			local other_nodes = {1, 2, 3, 4}
			other_nodes[index] = nil

			-- note that trying to use the bright white makes text darker actually
			gui.set_color(gui.get_node(Hud_info.goo_option_names[index]..Hud_info.goo_option_label_basename), MY_GOO.COLOR_TEXT_DEFAULT)
			for _,v_otherindex in pairs(other_nodes) do
				gui.set_color(gui.get_node(Hud_info.goo_option_names[v_otherindex]..Hud_info.goo_option_label_basename), MY_GOO.COLOR_TEXT_UNSELECTED)
			end

			--print("radio "..index.." selected")
		end

		local function func_radio_1(radio)
			radio_base(1)
		end
		local function func_radio_2(radio)
			radio_base(2)
		end
		local function func_radio_3(radio)
			radio_base(3)
		end
		local function func_radio_4(radio)
			radio_base(4)
		end

		if num_options >= 1 then
			MY_GOO.radio(Hud_info.goo_option_names[1], local_group_id, local_action_id, local_action, func_radio_1)
		end
		if num_options >= 2 then
			MY_GOO.radio(Hud_info.goo_option_names[2], local_group_id, local_action_id, local_action, func_radio_2)
		end
		if num_options >= 3 then
			MY_GOO.radio(Hud_info.goo_option_names[3], local_group_id, local_action_id, local_action, func_radio_3)
		end
		if num_options >= 4 then
			MY_GOO.radio(Hud_info.goo_option_names[4], local_group_id, local_action_id, local_action, func_radio_4)
		end

	end

	local function func_submit(button)

		-- handle all the button functionality

		--^ need to have tracker as off so if plot checks it properly knows what the status is
		-- if plot thinks decisions is still on it can re-enable decision 
		-- save the values to a master table before clearing them!
		local i = self.hud_decision_dynamic.goo_option_selected
		local answer_string_key = self.hud_decision_dynamic.answer_choice_keys[i]
		self.player_data_tbl.most_recent_decision_choice_key = answer_string_key

		local run_sizer = false
		local reset_values = true
		Screen_Decision_Reset(self, false, run_sizer, reset_values)

		--print("Submit Button was pressed")

		local loop_type = STR.CV.goal_completed_types.class_decisison

		if Valid_Event_Check_Full(self, loop_type) then
			if Loop_CompletionType_is_Primary(self, loop_type) then

				-- run outcome function
				local stage_key, substage_key = Get_Current_Stage_and_Substage(self)
				local role_key = self.player_data_tbl.character_role_key
				STR:Run_Choice_Answer_OutcomeFunc(stage_key, substage_key, role_key, answer_string_key)

				-- do debrief text if present
				-- this consists of opening popup window and setting goal type
				local debrief_text, is_debrief_dynamic, debrief_link = STR:Get_Choice_Text_Debrief(stage_key, substage_key, role_key, answer_string_key, true)
				local debrief_title_text = STR:Get_Choice_Title_Debrief(stage_key, substage_key, role_key, answer_string_key)

				if Loop_StatusType_is_Main(self) and debrief_text ~= nil and debrief_text ~= "" then

					self.gameplay_loop_status = CV_gameplay_loop.status_running_debrief
					self.gameplay_loop_completion_type_secondary = STR.CV.goal_completed_types.class_new_information

					-- also do not advance one from current progress if incorrect so we go back to it in the next submit
					if STR:Get_Choice_Answer_RepeatD(stage_key, substage_key, role_key, answer_string_key) then
						self.player_data_tbl.game_loop_needs_repeated = true
					end

					-- add debrief screen and also update goals
					local run_sizing_goals = false
					local goal_text = STR:Get_Choice_Answer_GoalText(stage_key, substage_key, role_key, answer_string_key) or "Review outcomes from your decision."
					Screen_Goals_Reset(self, true, run_sizing_goals, goal_text)

					local run_sizing_popup = true
					local reset_values_popup = true
					local size_type = nil
					local special_image_id = nil
					Screen_Popup_Reset(self, true, run_sizing_popup, reset_values_popup, debrief_text, debrief_title_text or "Update", size_type, is_debrief_dynamic, debrief_link, special_image_id)

				else
					msg.post(".", HSH.msg_request_game_progress)
				end
			end
		end

	end

	local function func_hint_toggle(button)

		-- toggle hint box

		local hint_button_label
		local controller_node = gui.get_node(Hud_info.node_hint_subcontroller)

		local current_setting = self.hud_decision_dynamic.hint_box_is_open
		local new_setting = not current_setting
		self.hud_decision_dynamic.hint_box_is_open = new_setting

		if new_setting then
			-- if hint open then close 
			hint_button_label = "Hide Hint"
		else
			-- if hint closed then open
			hint_button_label = "Show Hint"
		end

		SimpleToggleHelper(self, controller_node, new_setting, true)
		gui.set_text(gui.get_node(Hud_info.node_hint_button_text), hint_button_label)

	end

	local function func_review_sheet_open(button)

		-- opens review sheet PDF

		-- example of using open webpage:
		-- 	local success = sys.open_url("http://www.defold.com", {target = "_blank"})
		-- 	if not success then
				-- could not open the url...
		-- 	end

		sys.open_url("https://www.outreachgames.org/OceanProtector/custom_web_files/OPG_Student_Helper_Sheet.pdf")

	end

	MY_GOO.radiogroup("radiogroup_answer_options", action_id, action, func_radiogroup)

	-- hint button
	if self.hud_decision_dynamic.has_hint_available then

		MY_GOO.button_simple(Hud_info.goo_hint_name, action_id, action, func_hint_toggle)

		-- review sheet button
		if self.hud_decision_dynamic.hint_box_is_open then
			MY_GOO.button_simple(Hud_info.goo_review_sheet_name, action_id, action, func_review_sheet_open)
		end

	end

	-- submit button
	if self.hud_decision_dynamic.goo_sumbit_isactive then

		MY_GOO.button_simple(Hud_info.goo_submit_name, action_id, action, func_submit)

	end

end


-- HUD Screen: Graph Plot (Section 2)
local function Screen_Plot_Reset(self, enabled_setting, run_sizing, item_group_key)

	-- reset Graph Plot screen of HUD

	-- default args
	if enabled_setting == nil then
		enabled_setting = false
	end

	-- set enabled status
	local constant = self.hud_plot_constant
	local controller_node = gui.get_node(constant.node_controller)

	-- run enabling status and possibly sizing
	local function func_done(self, node)

		gui.set_enabled(node, enabled_setting)

		-- if enabling 
			-- if decision tracker is active then disable decision node
		-- if disabling
			-- if decision tracker is active then enable decision node
		local reset_values = false
		if enabled_setting then
			local run_decision_sizer = false
			if self.hud_decision_dynamic.screen_isactive then
				Screen_Decision_Reset(self, false, run_decision_sizer, reset_values)
			end
			if self.hud_popup_dynamic.screen_isactive then
				Screen_Popup_Reset(self, false, run_decision_sizer, reset_values)
			end
		else
			local run_decision_sizer = true
			if self.hud_decision_dynamic.screen_isactive then
				Screen_Decision_Reset(self, true, run_decision_sizer, reset_values)
			end
			if self.hud_popup_dynamic.screen_isactive then
				Screen_Popup_Reset(self, true, run_decision_sizer, reset_values)
			end
		end

	end

	if run_sizing then
		if enabled_setting then
			func_done(self, controller_node)
			gui.set_scale(controller_node, MY_GOO.MINIMIZE)
			gui.animate(controller_node, "scale", MY_GOO.MAXIMIZE, gui.EASING_OUTBACK, 0.50, 0)
		else
			--gui.set_scale(controller_node, MY_GOO.MAXIMIZE)
			gui.animate(controller_node, "scale", MY_GOO.MINIMIZE, gui.EASING_INBACK, 0.50, 0, func_done)
		end
	else
		func_done(self, controller_node)
	end

	-- reset tracker variables
	self.hud_plot_dynamic.screen_isactive = enabled_setting
	self.hud_plot_dynamic.active_itemkey = item_group_key

	-- if enabling then update graph
	if not enabled_setting or item_group_key == nil then return end

	-- set the axis and labels depending on the specified item group
	local item_info = CV_item_groups[item_group_key]
	if item_info == nil then
		print("Error: the following key does not exist in the item groups list: "..item_group_key.."\n")
		return
	end

	-- get sub-name if human and we have chosen a character
	local opt_subitem_name
	if item_group_key == "item_humans" then
		opt_subitem_name = STR:Get_Subitem_from_Role(self.player_data_tbl.character_role_key)
		-- will be nil if has not selected character yet
	end

	local y_axis_label = INFO:Get_Y_Axis_Label(item_group_key, opt_subitem_name)

	-- set title
	local title = y_axis_label .. " through Time"
	title = string.gsub(title, " ", "   ")
	gui.set_text(gui.get_node(constant.node_title_name), title)

	-- set y axis label and ticks
	local y_label = string.gsub(y_axis_label, " ", "   ")
	gui.set_text(gui.get_node(constant.node_y_axis_label), y_label)

	-- set plot height and toggle
	local tick_labels = INFO:Get_Y_Tick_Labels(item_group_key, opt_subitem_name)
	for i_tickindex,v_node_y_tickname in ipairs(constant.node_y_ticks) do
		gui.set_text(gui.get_node(v_node_y_tickname), tick_labels[i_tickindex])
	end

	-- set subtitle helper text
	local subtitle_text = INFO:Get_Plot_Subtitle_Text(item_group_key, opt_subitem_name) or ""
	gui.set_text(gui.get_node(constant.node_helper_subtitle_text), subtitle_text)

	-- set x axis label (tick labels and bar visibility handled in 'plot tracker update function' below)
	gui.set_text(gui.get_node(constant.node_x_axis_label), INFO:Get_X_Axis_Label())

	-- enable and set graph bars accordingly
	-- get item key, and for each item bar progress and label to visible
	Plot_Data_TrackerUpdate(self, item_group_key)

end

local function Screen_Plot_Initialize(self, enabled_status)

	-- set constants and setup dynamic values and components

	local basename = "hud_timeplot"
	local plot_base = "/group_plot"

	self.hud_plot_constant = nil
	self.hud_plot_dynamic = nil

	-- set constants
	self.hud_plot_constant = {
		hud_basename = basename,
		node_controller = basename .. "/gnode_controller",
		goo_exit_name = basename .. "/group_button_submit",
		node_title_name = basename .. plot_base .. "/gui_text_title",
		node_y_axis_label = basename .. plot_base .. "/gui_text_label_yaxis",
		node_x_axis_label = basename .. plot_base .. "/gui_text_label_xaxis",
		-- add ytick labels
		-- must match number of labels specified in INFO module!
		node_y_ticks = {
			basename..plot_base.."/gui_text_label_ytick_p0",
			basename..plot_base.."/gui_text_label_ytick_p25",
			basename..plot_base.."/gui_text_label_ytick_p50",
			basename..plot_base.."/gui_text_label_ytick_p75",
			basename..plot_base.."/gui_text_label_ytick_p100",
		},
		max_number_bars = 11,
		node_groupplots_controller = basename..plot_base.."/group_plots",
		basename_individual_bar_group = basename..plot_base.."/group_plot_",
		basename_individual_bar_label = "/gui_label",
		specified_bar_labels = INFO:Get_X_Tick_Labels(),
		basename_individual_bar_max_y = "/group_bar_element/tracker_max_length",
		basename_individual_bar_progress = "/group_bar_element/gui_frame_progress",
		node_helper_subtitle_text = basename .. plot_base .. "/gui_text_subtitle"
	}

	-- set dynamics
	self.hud_plot_dynamic = {}
	Screen_Plot_Reset(self, enabled_status)

end

local function Screen_Plot_Input(self, action_id, action)

	-- runs 'On Input' for Decision screen on HUD

	-- early out if not allowed to use
	if not self.hud_plot_dynamic.screen_isactive then
		return
	end

	local Hud_info = self.hud_plot_constant

	local function func_exit(button)

		-- handle all the button functionality

		-- set that this screen is no longer interactive
		local run_sizer = false
		Screen_Plot_Reset(self, false, run_sizer)

		if Loop_CompletionType_is_Primary(self, STR.CV.goal_completed_types.class_click_items) then
			if self.items_all_clicked then
				local stage_key, substage_key = Get_Current_Stage_and_Substage(self)
				STR:Run_Generic_OutcomeFunc(stage_key, substage_key)
				msg.post(".", HSH.msg_request_game_progress)
			end
		end

		--print("Exit Button was pressed")

	end

	MY_GOO.button_simple(Hud_info.goo_exit_name, action_id, action, func_exit)

end


-- HUD Screen: Data (Section 2)
local function Screen_Data_Reset(self, enabled_setting, disable_items_for_starting_out)

	-- reset Data screen of HUD

	-- default args
	if enabled_setting == nil then
		enabled_setting = false
	end

	-- disable goto button and overall item for starting out
	if disable_items_for_starting_out then
		for k,_ in pairs(CV_item_groups) do
			ScreenData_ToggleItem(self, k, false, true, true)
		end
	end

	-- set enabled status
	local constant = self.hud_data_constant
	gui.set_enabled(gui.get_node(constant.node_controller), enabled_setting)

	-- reset tracking table
	self.hud_data_dynamic.screen_isactive = enabled_setting
	self.hud_data_dynamic.is_maximized = true
	self.hud_data_dynamic.goo_items_areactive = enabled_setting

	-- enable and set data summary bars accordingly
	Screen_Data_TrackerUpdate(self)

	if enabled_setting and not self.player_data_tbl.special_setup_data_hud_enabled then
		self.player_data_tbl.special_setup_data_hud_enabled = true
	end

end

local function Screen_Data_Initialize(self, enabled_status)

	-- set constants and setup dynamic values and components

	local basename = "hud_data"

	self.hud_data_constant = nil
	self.hud_data_dynamic = nil

	-- set constants
	self.hud_data_constant = {
		hud_basename = basename,
		node_frame_core = basename .. "/group_frame/gui_frame_core",
		node_controller = basename .. "/gnode_controller",
		node_subcontroller = basename .. "/gnode_subcontroller",
		node_max_length = basename .. "/tracker_max_length",
		node_min_length = basename .. "/tracker_min_length",
		goo_minimizer = basename .. "/group_button_sizer",
		goo_item_gotograph = "/group_button_goto",
		basename_item_bar_progress = "/group_healthbar/gui_frame_progress",
		basename_item_bar_max_x = "/group_healthbar/tracker_max_length",
		basename_item_bar_label = "/gnode_body_text",
		basename_item_button_core = "/gui_button_core",
		basename_item_controller = "/gnode_controller",
		goo_group_names = {},
		goo_group_goto_buttons = {},
	}

	-- add goto graph button strings
	-- also disable goto buttons and overall items until game-play adds/reveals them
	for k,v in pairs(CV_item_groups) do
		local name = basename .. v.group_name
		self.hud_data_constant.goo_group_names[k] = name
		local button_name = name .. self.hud_data_constant.goo_item_gotograph
		self.hud_data_constant.goo_group_goto_buttons[k] = button_name
	end

	-- set dynamics
	self.hud_data_dynamic = {}
	Screen_Data_Reset(self, enabled_status, true)

end

local function Screen_Data_Input(self, action_id, action)

	-- runs 'On Input' for Data screen on HUD

	-- early out if not allowed to use
	if not self.hud_data_dynamic.screen_isactive then
		return
	end

	local Hud_info = self.hud_data_constant

	-- sizer button
	local function func_button_sizer(button)

		-- handle all the button functionality

		local function func_shrink(self, subcontroller_node)
			gui.set_enabled(subcontroller_node, false)
		end

		local function func_expand(self, subcontroller_node)
			gui.set_enabled(subcontroller_node, true)
		end

		-- if is currently maximized then shrink
		-- if is not currently maximized then expand

		local is_now_maximized
		local subcontroller_node = gui.get_node(Hud_info.node_subcontroller)

		local frame_node = gui.get_node(Hud_info.node_frame_core)

		if self.hud_data_dynamic.is_maximized then
			-- run shrink and disable
			is_now_maximized = false
			gui.animate(frame_node, "size.y", gui.get_size(gui.get_node(Hud_info.node_min_length)).y, gui.EASING_INBACK, 0.4)
			gui.animate(subcontroller_node, "scale", MY_GOO.MINIMIZE, gui.EASING_INBACK, 0.35, 0, func_shrink)
		else
			-- run expand and enable
			is_now_maximized = true
			-- needs to be enabled to have size change, 
			-- but since default is large, will already be set small when disabled
			gui.set_enabled(subcontroller_node, true)
			gui.animate(frame_node, "size.y", gui.get_size(gui.get_node(Hud_info.node_max_length)).y, gui.EASING_OUTBACK, 0.4)
			gui.animate(subcontroller_node, "scale", MY_GOO.MAXIMIZE, gui.EASING_OUTBACK, 0.35, 0, func_expand)
		end

		-- update booleans
		self.hud_data_dynamic.goo_items_areactive = is_now_maximized
		self.hud_data_dynamic.is_maximized = is_now_maximized

		--print("Sizer was toggled. Is now maximized is "..tostring(is_now_maximized))

	end

	MY_GOO.checkbox_sizer(Hud_info.goo_minimizer, action_id, action, func_button_sizer)


	-- goto buttons
	local function func_goto_core(table_key)

		-- handle all functionality for the goto graph buttons

		-- if active then just overwrite 
		-- if not active then expand
		local needs_expanding = not self.hud_plot_dynamic.screen_isactive

		Screen_Plot_Reset(self, true, needs_expanding, table_key)

		--print("Goto button was pressed for "..table_key)

	end

	local function func_goto_ph(button)
		func_goto_core("item_ph")
	end
	local function func_goto_plankton(button)
		func_goto_core("item_plankton")
	end
	local function func_goto_coral(button)
		func_goto_core("item_coral")
	end
	local function func_goto_fish(button)
		func_goto_core("item_fish")
	end
	local function func_goto_mollusks(button)
		func_goto_core("item_mollusks")
	end
	local function func_goto_crustaceans(button)
		func_goto_core("item_crustaceans")
	end
	local function func_goto_humans(button)
		func_goto_core("item_humans")
	end

	if self.hud_data_dynamic.goo_items_areactive then
		local gotos = Hud_info.goo_group_goto_buttons
		local needs_clicked = self.items_that_need_clicked_list

		local button_helper = {
			item_ph = func_goto_ph,
			item_plankton = func_goto_plankton,
			item_coral = func_goto_coral,
			item_fish = func_goto_fish,
			item_mollusks = func_goto_mollusks,
			item_crustaceans = func_goto_crustaceans,
			item_humans = func_goto_humans
		}

		--goal is to look like this
		--if not self.items_that_need_clicked_list.item_ph.item_was_clicked then
			--MY_GOO.button_goto(gotos.item_ph, action_id, action, func_goto_ph)
		--end

		-- only allow clicking on goto if item was clicked/selected and updated 

		for k_itemname, v_func_goto in pairs(button_helper) do
			local button_available = true
			if needs_clicked ~= nil and needs_clicked[k_itemname] ~= nil then
				if not needs_clicked[k_itemname].item_was_clicked then
					button_available = false
				end
			end
			if button_available then
				MY_GOO.button_goto(gotos[k_itemname], action_id, action, v_func_goto)
			end
		end

	end

end


--HUD Process: Deal with Player Data Table
local function PlayerData_MakeOA_Tbl(self, stage_key, substage_key)

	-- makes and returns table to use in OA outcome observations and catchup 

	local oa_outcome_tbl = {
		minfo_oa_outcome_item_health_values = {}
	}

	for k_item_name,v_item_tracker_tbl in pairs(self.player_data_tbl.item_data_tbl) do
		if v_item_tracker_tbl ~= nil then
			local tracker_list_length = #v_item_tracker_tbl
			local new_val = v_item_tracker_tbl[tracker_list_length].item_tracker_score
			local previous_val
			-- add previous and new values
			if tracker_list_length >= 2 then
				previous_val = v_item_tracker_tbl[tracker_list_length-1].item_tracker_score
			else
				previous_val = new_val
			end
			-- save to table for message passing
			oa_outcome_tbl.minfo_oa_outcome_item_health_values[k_item_name] = {
				health_value_previous = previous_val,
				health_value_new = new_val
			}
		end
	end

	if stage_key ~= nil and substage_key ~= nil then
		oa_outcome_tbl.minfo_oa_outcome_reset_swimmers = STR:Get_Swimmers_are_Resetting(stage_key, substage_key)
		oa_outcome_tbl.minfo_oa_outcomes_show_highlighter = STR:Get_Show_HUD_Highlighter(stage_key, substage_key)
		oa_outcome_tbl.minfo_run_coastal_oa_percent = Get_Coastal_OA_Percent_Helper(self)
	end

	return oa_outcome_tbl

end

local function PlayerData_CatchUp(self)

	-- runs all catch up events that should have been triggered by this point

	local ply = self.player_data_tbl

	-- human character
	if ply.character_role_key ~= CV_Player_Role_Empty then
		-- already got to character choice, so use that
		PlayerData_Set_Character(self, ply.character_role_key)
	else
		-- not yet at character choice, so show default boat
		if ply.special_setup_item_boat_present then
			msg.post(".", HSH.msg_request_special_case_action, {minfo_special_case_key = HSH.special_setup_first_boat})
		end
	end

	-- show goals?
	-- ply.special_setup_goals_hud_enabled just bool check at game progress
	if ply.special_setup_goals_hud_enabled and not self.hud_goals_dynamic.screen_isactive then
		Screen_Goals_Reset(self, true)
	end

	-- show data hud? 
	-- ply.special_setup_data_hud_enabled just bool check at game progress
	if ply.special_setup_data_hud_enabled and not self.hud_data_dynamic.screen_isactive then
		Screen_Data_Reset(self, true)
	end

	-- show buoy
	if ply.special_setup_item_buoy_present then
		msg.post(".", HSH.msg_request_special_case_action, {minfo_special_case_key = HSH.special_setup_pH_buoy})
	end

	-- show individual items in data screen
	for k_itemname,_ in pairs(CV_item_groups) do
		local hud_data = ply.item_hud_status[k_itemname]
		if hud_data ~= nil then
			ScreenData_ToggleItem(self, k_itemname, hud_data.data_item_shown, hud_data.data_item_shown, false)
			ScreenData_ToggleItem(self, k_itemname, hud_data.data_goto_shown, false, hud_data.data_goto_shown)
		end
	end

	-- run static and plankton catch up
	-- if buoy not present then still within starting range and no need to do all of this
	if not ply.special_setup_item_buoy_present then
		return
	end

	-- recall static and plankton are cumulative visuals, so need to be updated to where we left off
	-- swimmers are reset each observation event, so no need to update visuals when loading

	-- send message to instantly catch up
	-- do not show OA values, b/c graph plots and other popups are needed to advance to next stages
	self.oa_outcomes_are_active = false
	msg.post(CV_ID_Ocean_Setup_Script, HSH.msg_request_oa_catchup_micro_or_static, PlayerData_MakeOA_Tbl(self))

end

local function PlayerData_Reset(self, update_hud_screens, back_to_beginning)

	-- resets player data
	-- player data will be loaded in and checked for save file and loaded if needed within main menu logic

	-- if 'back_to_beginning' is true, then this is running as part of full restart and not first initialization

	-- save player ID if restarting game
	local ply_id, ply_repeat_count
	if type(self.player_data_tbl) == "table" then
		ply_id = self.player_data_tbl.id_key_user or 1111
		ply_repeat_count = self.player_data_tbl.id_playthrough_count or 1
	end

	-- reset fully
	self.player_data_tbl = nil

	self.player_data_tbl = {
		id_key_user = ply_id,
		id_playthrough_count = ply_repeat_count,
		save_file_version_major = CV_Current_Save_Version_Major,
		save_file_version_minor = CV_Current_Save_Version_Minor,
		num_best_answers = 0,
		num_total_answers = 0,
		gameplay_loop_i_key = 0,
		most_recent_decision_choice_key = "", --this saves choice, while loop i key above saves stage/substage keys
		character_role_key = CV_Player_Role_Empty,
		special_setup_goals_hud_enabled = false,
		special_setup_data_hud_enabled = false,
		special_setup_item_boat_present = false,
		special_setup_item_buoy_present = false,
		-- set first value as dummy entry so it lines up with score tracker
		-- b/c decision trackers are only added if player decision was made, 
		-- and first entry in health trackers are initial negative health
		decision_data_tbl = {{}},
		item_data_tbl = {},
		item_hud_status = {},
		game_loop_needs_repeated = false
	}

	PlayerData_Update_SumBestChoices(self, 0, true)
	PlayerData_Update_SumTotalChoices(self, 0, true)

	-- go through item keys and initialize table and add first entry of fully healthy
	for k_itemname,_ in pairs(CV_item_groups) do
		self.player_data_tbl.item_data_tbl[k_itemname] = {}
		self.player_data_tbl.item_hud_status[k_itemname] = {}

		PlayerData_UpdateScoreTracker(self, k_itemname, 1.0, 1.0)

		PlayerData_UpdateHUDTracker(self, k_itemname, false, false)
	end

	-- recall this function is only run when starting or repeating game
	-- also recall, that bar plots are updated and checked for each bar within player table each time bar plot is opened,
	-- which means that if player table entry is not there, since it was reset, then bar will be hidden 
	-- so no need to enable or disable bars since it already does it when opening bar plot
	-- plus hud screens may not have been initialized yet
	if update_hud_screens then

		Screen_Data_Reset(self, false, back_to_beginning)
		-- ^^ recall data rest internally calls Screen_Data_TrackerUpdate( function 

		-- not really sure how we could get to this point, since plot would have to be closed to click on restart
		-- but update here for failsafe anyway
		if self.hud_plot_dynamic.screen_isactive then
			Plot_Data_TrackerUpdate(self, self.hud_plot_dynamic.active_itemkey)
		end
	end

	-- no need to save since i progress will save

end


-- HUD Process: Observe Items (Section 2)
local function On_GO_Item_Click_Labeled(self, screen_pos, unique_tbl)

	-- play sound and show label of what was clicked on regardless
	sound.play("sound_controller#sound_button_1", {delay = 0, gain = 0.5, pan = 0, speed = 1.0})

	local labels_i_list = {}
	local num_unique = 0
	for k_itemname,_ in pairs(unique_tbl) do
		num_unique = num_unique + 1
		labels_i_list[num_unique] = CV_item_groups[k_itemname].object_clicked_label
	end

	-- failsafe out
	if num_unique <= 0 then
		return
	end

	-- show label
	local label_txt = ""
	if num_unique == 1 then
		label_txt = labels_i_list[1]
	elseif num_unique == 2 then
		label_txt = labels_i_list[1] .. " & ".. labels_i_list[2]
	else
		label_txt = table.concat(labels_i_list, ", ", 1, num_unique-1)
		label_txt = label_txt .. " & " .. labels_i_list[num_unique]
	end

	local clicked_label_node = gui.get_node("gnode_clicked_label")
	gui.set_text(clicked_label_node, label_txt)
	gui.set_position(clicked_label_node, vmath.vector3(screen_pos.x, screen_pos.y, 0))

	gui.set_enabled(clicked_label_node, true)
	gui.set_scale(clicked_label_node, MY_GOO.MAXIMIZE)

	local function func_shrink(self, subcontroller_node)
		gui.set_enabled(subcontroller_node, false)
	end

	gui.animate(clicked_label_node, "scale", MY_GOO.MINIMIZE, gui.EASING_LINEAR, 0.5, 1, func_shrink)

end

local function On_GO_Item_Clicked_Requested(self, action_id, action)

	-- send request to get object items clicked on

	-- if data window is open do not register click if it was within the data bounds
	-- otherwise player may accidentally click on item if item is behind one of the buttons on the data screen
	if action_id == nil or action == nil then return end
	if action_id ~= HSH.control_touch then return end
	if not action.pressed then return end

	-- also check side bars, and return if we clicked in those
	local data_node_controller = gui.get_node(self.hud_data_constant.node_controller)
	local data_node_frame = gui.get_node(self.hud_data_constant.node_frame_core)

	local goals_node_controller = gui.get_node(self.hud_goals_constant.node_controller)
	local goals_node_frame = gui.get_node(self.hud_goals_constant.node_frame_core)

	if gui.is_enabled(data_node_controller, false) and gui.pick_node(data_node_frame, action.x, action.y) then
		--print("Clicked within data frame, not checking rest...\n")
		return
	--elseif gui.is_enabled(goals_node_controller, false) and gui.pick_node(goals_node_frame, action.x, action.y) then
		--print("Clicked within data frame, not checking rest...\n")
		-- no need to worry about goals since they only overlap the boat and just barely and goals as no buttons
		-- also better to allow clicking through goals so players don't get confused 
		--   as to why they cannot click the boat when it comes on-screen
		--return
	end

	-- if valid ocean click then check if for item selecting or just something simple like bubbles

	if On_GO_Items_Clicked_Basic_Valid(self) then
		msg.post(CV_ID_Ocean_Setup_Script, HSH.msg_request_go_clicked, {minfo_action = action})
	else
		msg.post(CV_ID_Ocean_Setup_Script, HSH.msg_request_make_bubbles, {minfo_action = action})
	end

end

local function On_GO_Item_Click_InputEnd(self, item_name, first_time_click)

	-- runs once successful click on go item(s)

	-- check if actually on list, if so get data and continue
	local item_click_info = self.items_that_need_clicked_list[item_name]

	if item_click_info == nil then return end

	-- run debrief display and item enabling if first click

	local debrief_text = item_click_info.show_debrief_text
	local run_debrief = (debrief_text ~= nil and debrief_text ~= "")
	if first_time_click then

		-- check and run item data view enabling
		local enable_goto = item_click_info.enable_goto_in_data_hud_onclick
		local enable_item = item_click_info.enable_item_in_data_hud_onclick
		if enable_goto or enable_item then
			-- failsafe to enable data gauge if not enabled
			if not self.hud_data_dynamic.screen_isactive then
				Screen_Data_Reset(self, true)
			end

			ScreenData_ToggleItem(self, item_name, true, enable_item, enable_goto)
		end

		-- have these updaters here in case things need enabled

		-- update score tracker variables 
		Screen_Data_TrackerUpdate(self, item_name)

		-- set data hud color
		Items_Set_Color_Tracking(self, item_name, false)

		-- check and run debrief 
		if run_debrief then
			local run_sizing_debrief = true
			local update_values_to_debrief = true
			self.gameplay_loop_status = CV_gameplay_loop.status_running_debrief
			self.gameplay_loop_completion_type_secondary = STR.CV.goal_completed_types.class_new_information
			Screen_Popup_Reset(self, true, run_sizing_debrief, update_values_to_debrief, debrief_text)
		end

	end

	-- run graph plot display if needed
	if not run_debrief and item_click_info.show_data_popup and not self.oa_outcomes_are_active then
		-- update graph plot
		--print("Item clicked and opening graph for <"..item_name..">. \n ")
		Screen_Plot_Reset(self, true, true, item_name) --also runs plot update
	end

end

local function On_GO_Item_Clicked_Received(self, clicked_info)

	-- runs process when player clicks on go item(s)

	-- in form 
	-- match_id_tbl[k_item_name] = {selected_go_url = k_goid, selected_go_subitem = k_subitem_name}

	-- early exits
	if not On_GO_Items_Clicked_Basic_Valid(self) then return end

	if type(clicked_info) ~= "table" then return end

	if clicked_info.minfo_match_tbl == nil then return end
	if clicked_info.minfo_match_count == nil then return end
	if clicked_info.minfo_match_count <= 0 then return end

	-- get which groups we are checking clicks for
	local needs_clicked = self.items_that_need_clicked_list
	if self.items_that_need_clicked_sum == 0 then return end

	-- might have clicked on more then one item if they were overlapping so
	-- find first group that is on 'needs to be clicked' list but not on 'is clicked list'
	local valid_item_clicked
	local back_item_clicked
	local not_allowed_click
	local clicked_unique_tbl = {}
	for _,v_clicked_info in ipairs(clicked_info.minfo_match_tbl) do
		-- on 'needs clicked list'
		local item_name = v_clicked_info.selected_go_item
		local needs_clicked_item = needs_clicked[item_name]
		if needs_clicked_item ~= nil then
			-- checked if it has been clicked or not, 
			-- items not clicked take priority so the list can actually be completed

			if not needs_clicked_item.item_was_clicked then
				-- has not yet been clicked, so add it
				valid_item_clicked = item_name
				clicked_unique_tbl[item_name] = true

				self.items_that_need_clicked_list[item_name].item_was_clicked = true

				if self.items_that_were_clicked_sum < self.items_that_need_clicked_sum then
					self.items_that_were_clicked_sum = self.items_that_were_clicked_sum + 1
				end

				break
			else
				-- has been clicked and is on list, but maybe player wants to view graph again
				if needs_clicked_item.allow_duplicate_clicks then
					back_item_clicked = item_name
					clicked_unique_tbl[item_name] = true
				else
					not_allowed_click = item_name
					clicked_unique_tbl[item_name] = true
				end
			end
		else
			-- not on the 'needs clicked' list 
			not_allowed_click = item_name
			clicked_unique_tbl[item_name] = true
		end
	end

	-- if this was last on list then set variable that all are done
	if self.items_that_were_clicked_sum >= self.items_that_need_clicked_sum then
		self.items_all_clicked = true
		--print("All items that need to be clicked were clicked. \n")
	end

	-- finish process to click on and save data on items
	-- popup graph, which will also disable ocean script clicking
	-- also set color in data view for color and bar
	local final_item = valid_item_clicked or back_item_clicked or not_allowed_click
	if final_item ~= nil then
		local first_time_click
		if valid_item_clicked then
			first_time_click = true
		end
		On_GO_Item_Click_Labeled(self, clicked_info.minfo_screen_position, clicked_unique_tbl)
		On_GO_Item_Click_InputEnd(self, final_item, first_time_click)
	end

end


-- HUD Process: Screen Fader
local function Run_Fader(self, fade_out, time)

	-- run either fade in or fade out

	-- setup variables
	local fader_node = gui.get_node("gnode_screen_fader")
	local alpha, disable_at_end
	if fade_out then
		gui.set_enabled(fader_node, true)
		alpha = 1.0
		disable_at_end = false
	else
		alpha = 0.0
		disable_at_end = true
	end

	time = time or 2.0

	-- cancel any current fades
	gui.cancel_animation(fader_node, "color.w")

	-- declare callback for readability and thought of optimization
	local function func_set_status()
		if disable_at_end then
			gui.set_enabled(fader_node, false)
		end
	end

	-- run fader animation
	gui.animate(fader_node, "color.w", alpha, go.EASING_LINEAR, time, 0, func_set_status)

end


local function Close_All_Center_Screens(self)

	-- close any open screens in center window

	local run_sizing = false
	local enabled_status = false
	local reset_values = false

	-- popup/new info
	if self.hud_popup_dynamic.screen_isactive then
		Screen_Popup_Reset(self, enabled_status, run_sizing, reset_values)
	end

	-- decision
	if self.hud_decision_dynamic.screen_isactive then
		Screen_Decision_Reset(self, enabled_status, run_sizing, reset_values)
	end

	-- plot
	if self.hud_plot_dynamic.screen_isactive then
		Screen_Plot_Reset(self, enabled_status, run_sizing)
	end

	-- data screen side bar?
	-- leave open for now, but close when running OA effects?

end


-- HUD Process: Game Loop
local function GamePauseToggle_Internal(self)

	-- pause by setting game update factor to 0
	self.game_paused = not self.game_paused

	local factor
	if self.game_paused then
		factor = 0
	else
		factor = 1
	end

	msg.post("level_loader#collectionproxy", HSH.msg_builtin_set_timestep, {factor = factor, mode = 1})
	msg.post("ocean_level:/level_controller#script", HSH.msg_pause_game_msg_sent, {minfo_game_paused = self.game_paused})

end

local function GamePause_On(self)

	-- if game should be paused but is not paused, then pause it
	if not self.game_paused then
		GamePauseToggle_Internal(self)
	end

end

local function GamePause_Off(self)

	-- if game should be resumed but is paused, then resume it
	if self.game_paused then
		GamePauseToggle_Internal(self)
	end

end

local function GameLogic_Progress(self, i_stage_addition, run_file_save, disable_cloud_report)

	-- setups and runs next game-play event

	-- record previous progress to cloud analytics reporting before advancing
	-- though if i_stage_addition is -1 we need to account for that
	if not disable_cloud_report then
		PlayerData_CloudRecord(self, false)
	end

	-- set that new start time
	self.game_logic_time_start = socket.gettime()

	-- update i-key
	if i_stage_addition == nil then
		i_stage_addition = 1
	end
	-- special case for repeating events
	if i_stage_addition == 1 and self.player_data_tbl.game_loop_needs_repeated then
		i_stage_addition = 0
		self.player_data_tbl.game_loop_needs_repeated = false
	end
	PlayerData_Update_I_Key_Progress(self, i_stage_addition)

	local stage_key, substage_key = Get_Current_Stage_and_Substage(self)

	if stage_key == nil or substage_key == nil then
		--print("TRK: Game loop is completed! \n")
		return
	end

	-- run 'self.player_data_tbl' save to file here
	-- so game saves after each stage
	-- we have reached this stage so now save, 
	-- do not save before reaching this stage otherwise we will have to replay stage when loading
	if run_file_save then
		PlayerData_Save(self)
	end

	-- get and update goal text
	local goal_text = STR:Get_Goal_Text(stage_key, substage_key)
	local run_goal_sizing = not self.hud_goals_dynamic.screen_isactive
	if self.player_data_tbl.special_setup_goals_hud_enabled then
		Screen_Goals_Reset(self, true, run_goal_sizing, goal_text)
	end

	-- run other logic
	self.gameplay_loop_status = CV_gameplay_loop.status_running_main

	-- close any other plots or popups or decisions
	Close_All_Center_Screens(self)

	-- get type of event and start associated screens
	local stage_type = STR:Get_Completion_Type(stage_key, substage_key)
	local cv = STR.CV
	local st = cv.goal_completed_types
	self.gameplay_loop_completion_type_primary = stage_type
	self.gameplay_loop_completion_type_secondary = stage_type

	--print("  TRK: Running stage <"..stage_key.."> with substage <"..substage_key.."> with completion type <"..stage_type.."> \n")

	local special_image_str = nil

	if stage_type == st.class_click_items then
		-- setup clicking on items
		On_GO_Items_Clicked_Reset(self, true)
		local items_to_click = STR:Get_Items_to_Click(stage_key, substage_key)
		Items_Click_Status_Reset(self, items_to_click)

		local popup_text_body, pop_textbody_isdynamic, opt_hyperlink = STR:Get_NewInfo_Text_Body(stage_key, substage_key)
		local run_sizer = true
		local reset_values = true
		local popup_text_title = STR:Get_NewInfo_Title_Body(stage_key, substage_key)

		Screen_Popup_Reset(self, true, run_sizer, reset_values, popup_text_body, popup_text_title, nil, pop_textbody_isdynamic, opt_hyperlink, special_image_str)

	elseif stage_type == st.class_decisison then
		-- setup decision
		local role_key = self.player_data_tbl.character_role_key
		local q_text = STR:Get_Decision_Text_Question(stage_key, substage_key, role_key)
		local a_tbl = STR:Get_Decision_Text_Options(stage_key, substage_key, role_key)
		local hint_text = STR:Get_Decision_Text_Hint(stage_key, substage_key, role_key)
		local reset_values = true
		local title = STR:Get_Decision_Text_Title(stage_key, substage_key, role_key)
		Screen_Decision_Reset(self, true, true, reset_values, #a_tbl, q_text, a_tbl, hint_text, title)

	elseif stage_type == st.class_new_information then
		-- setup new information
		local popup_text_body, pop_textbody_isdynamic, opt_hyperlink  = STR:Get_NewInfo_Text_Body(stage_key, substage_key)
		local popup_text_title = STR:Get_NewInfo_Title_Body(stage_key, substage_key)
		local run_sizer = true
		local reset_values = true

		special_image_str = STR:Get_NewInfo_Special_Image_Body(stage_key, substage_key)
		Screen_Popup_Reset(self, true, run_sizer, reset_values, popup_text_body, popup_text_title, nil, pop_textbody_isdynamic, opt_hyperlink, special_image_str)


	elseif stage_type == st.class_observe_method then
		-- observe methods
		local observe_methods = cv.goal_completed_extra_types

		-- first get which method type and then run accordingly
		local observe_type = STR:Get_Goal_SubType_Method(stage_key, substage_key) or -1

		if observe_type == observe_methods.subclass_oa_outcome then
			-- OA outcome

			-- send message to run outcomes
			-- this script will get a message back once that outcome effect is done
			-- and at that point request a game progress
			-- get previous and current values for items into table and send it
			if PlayerData_IsValid(self, "Observe Items Setup") then
				-- hide data screen so OA changes are easier to see?
				-- then open back up after OA done? 
				-- or just do not bother and assume player will set how they want
				-- also might hiding and un-hiding may distract from watching OA changes 
				-- and OA changes and animal groups to click on will virtually always be visible to click on

				-- send message to start and set that OA outcomes are active so certain popup clicking does not work
				self.oa_outcomes_are_active = true
				msg.post(CV_ID_Ocean_Setup_Script, HSH.msg_request_oa_outcomes_started, PlayerData_MakeOA_Tbl(self, stage_key, substage_key))
			end

		elseif EXT:equalAny(observe_type, {observe_methods.subclass_wait_time_only, observe_methods.subclass_wait_then_pause}) then
			-- wait time only or wait time then pause

			-- get wait time
			local time_to_wait = STR:Get_Goal_SubType_Value(stage_key, substage_key)

			-- run timer, pause if needed, then progress game
			timer.delay(time_to_wait, false, function (self)

				if observe_type == observe_methods.subclass_wait_then_pause then
					GamePause_On(self)
				end

				STR:Run_Generic_OutcomeFunc(stage_key, substage_key)
				msg.post(".", HSH.msg_request_game_progress)

			end)


		elseif observe_type == observe_methods.subclass_unpause then
			-- unpause 

			-- unpause then progress game
			GamePause_Off(self)
			STR:Run_Generic_OutcomeFunc(stage_key, substage_key)
			msg.post(".", HSH.msg_request_game_progress)

		end

	end

end


-- HUD Screen: Main Menu (Section 1)
local function Screen_MainMenu_Reset(self, enabled_setting, run_sizing, stage_num)

	-- reset Main Menu screen of HUD

	-- default args
	if enabled_setting == nil then
		enabled_setting = false
	end

	stage_num = stage_num or 1

	-- set enabled status
	local constant = self.hud_mainmenu_constant
	local controller_node = gui.get_node(constant.node_controller_main)

	-- reset tracking table
	self.hud_mainmenu_dynamic.screen_isactive = enabled_setting
	self.hud_mainmenu_dynamic.stage_number = stage_num

	local stage1_controller = gui.get_node(constant.node_controller_start_menu)
	local stage2_controller = gui.get_node(constant.node_controller_new_game)

	-- toggle sizing
	SimpleToggleHelper(self, controller_node, enabled_setting, run_sizing)

	if stage_num == 1 then
		-- main menu starting path
		gui.set_enabled(stage1_controller, true)
		gui.set_enabled(stage2_controller, false)

		-- set color of resume button depending on lock status
		if self.hud_mainmenu_dynamic.resume_game_possible then
			gui.set_color(gui.get_node(constant.node_resume_button_frame), MY_GOO.COLOR_DEFAULT)
			gui.set_color(gui.get_node(constant.node_resume_button_text), MY_GOO.COLOR_TEXT_DEFAULT)
		else
			gui.set_color(gui.get_node(constant.node_resume_button_frame), MY_GOO.COLOR_LOCKED)
			gui.set_color(gui.get_node(constant.node_resume_button_text), MY_GOO.COLOR_LOCKED)
		end

	elseif stage_num == 2 then
		-- new game path with game ID confirmation
		gui.set_enabled(stage1_controller, false)
		gui.set_enabled(stage2_controller, true)
		MY_GOO.input(constant.goo_input_name, gui.KEYBOARD_TYPE_DEFAULT, nil, nil, constant.input_config_tbl)

		if constant.game_id_must_be_valid then
			gui.set_color(gui.get_node(constant.node_confirm_button_frame), MY_GOO.COLOR_LOCKED)
			gui.set_color(gui.get_node(constant.node_confirm_button_text), MY_GOO.COLOR_LOCKED)
		else
			gui.set_color(gui.get_node(constant.node_confirm_button_frame), MY_GOO.COLOR_DEFAULT)
			gui.set_color(gui.get_node(constant.node_confirm_button_text), MY_GOO.COLOR_TEXT_DEFAULT)
		end

	end

end

local function Screen_MainMenu_Initialize(self, enabled_status, save_file_exists)

	-- set constants and setup dynamic values and components

	local basename = "hud_startmenu"

	self.hud_mainmenu_constant = nil
	self.hud_mainmenu_dynamic = nil

	-- set constants
	self.hud_mainmenu_constant = {
		hud_basename = basename,
		node_controller_main = basename .. "/gnode_controller_main",
		goo_game_new_name = basename .. "/group_button_game_new",
		goo_game_resume_name = basename .. "/group_button_game_resume",
		node_resume_button_frame = basename .. "/group_button_game_resume/gui_button_core",
		node_resume_button_text = basename .. "/group_button_game_resume/gui_button_label",
		node_controller_start_menu = basename .. "/gnode_controller_start_menu",
		node_controller_new_game = basename .. "/gnode_controller_new_game",
		goo_game_confirm_id =  basename .. "/group_button_confirm_id",
		node_confirm_button_frame = basename .. "/group_button_confirm_id/gui_button_core",
		node_confirm_button_text = basename .. "/group_button_confirm_id/gui_button_label",
		goo_input_name = basename .. "/group_input_id",
		input_config_tbl = {
			empty_text = "<click to type>",
			max_length = 4,
			allowed_characters = "[%d]",
			use_marked_text = false
		},
		-- update game ID validity check if needed
		game_id_must_be_valid = true
	}

	-- set dynamics
	self.hud_mainmenu_dynamic = {}
	self.hud_mainmenu_dynamic.stage_number = 1
	self.hud_mainmenu_dynamic.current_input_id = self.player_data_tbl.id_key_user

	self.hud_mainmenu_dynamic.resume_game_possible = save_file_exists

	Screen_MainMenu_Reset(self, enabled_status, true)

end

local function Screen_MainMenu_Input(self, action_id, action)

	-- runs 'On Input' for Main Menu screen on HUD

	-- early out if not allowed to use
	if not self.hud_mainmenu_dynamic.screen_isactive then
		return
	end

	local hudinfo = self.hud_mainmenu_constant

	local function func_new_game(button)

		-- handle all the button functionality for new game

		-- since this is a new game clear 
		-- we need to clear any loaded player tbl
		-- should already be clear, but just to be on safe side
		if self.hud_mainmenu_dynamic.resume_game_possible then
			PlayerData_Reset(self)
		end

		-- set that this screen is no longer interactive
		local run_sizer = false
		Screen_MainMenu_Reset(self, false, run_sizer)

		-- now that cleared that open new game ID confirmation screen
		Screen_MainMenu_Reset(self, true, true, 2)

		--print("New game started!")

	end

	local function func_resume_game(button)

		-- handle all the button functionality for resume game

		-- set that this screen is no longer interactive
		local run_sizer = false
		Screen_MainMenu_Reset(self, false, run_sizer)

		-- load game if preset and go to next stage
		local stage_addition
		if PlayerData_Check_MaybeLoad(self, true) then
			stage_addition = 0
		else
			-- failsafe if somehow we got here and save file invalid
			stage_addition = 1
		end

		local run_file_save = false
		local disable_cloud_report = true
		-- disable cloud report so that if players are loading/resuming game there are no duplicates
		-- particularly useful to avoid duplicates in the final score analytic sheet 
		--   which is caused by loading/resuming game during the final question phase
		GameLogic_Progress(self, stage_addition, run_file_save, disable_cloud_report)

		--print("Game resumed!")

	end

	local function func_submit_game_id(button)

		-- handle all the button functionality for new game ID confirmation

		self.player_data_tbl.id_key_user = self.hud_mainmenu_dynamic.current_input_id

		local run_sizer = false
		Screen_MainMenu_Reset(self, false, run_sizer)

		local run_file_save = true
		GameLogic_Progress(self, 1, run_file_save)

	end

	-- run logic depending on stage, recall save will trigger at next screenplay stage
	local stage_num = self.hud_mainmenu_dynamic.stage_number
	if stage_num == 1 then
		--default stage 1
		-- new game
		MY_GOO.button_simple(hudinfo.goo_game_new_name, action_id, action, func_new_game)

		-- resume game
		if self.hud_mainmenu_dynamic.resume_game_possible then
			MY_GOO.button_simple(hudinfo.goo_game_resume_name, action_id, action, func_resume_game)
		end

	elseif stage_num == 2 then
		-- stage 2, set game ID

		-- game ID input 
		local text_input = MY_GOO.input(hudinfo.goo_input_name, gui.KEYBOARD_TYPE_DEFAULT, action_id, action, hudinfo.input_config_tbl)
		-- save game ID to use in submit game ID button
		local typed_input = text_input.text

		-- set new game ID
		local id_must_be_valid = hudinfo.game_id_must_be_valid
		local allow_button_clicking
		if id_must_be_valid then
			-- ID must be valid, so check requirements
			if typed_input ~= nil and #typed_input == 4 then
				-- requirements met
				allow_button_clicking = true
			else
				-- requirements not met
				allow_button_clicking = false
			end
		else
			-- ID does not care about validity so let player go
			allow_button_clicking = true
		end

		-- check and set if id input changed 
		local ids_changed
		if self.hud_mainmenu_dynamic.current_input_id ~= typed_input then
			self.hud_mainmenu_dynamic.current_input_id = typed_input
			ids_changed = true
		end

		-- set colors and confirm button accordingly
		if allow_button_clicking then
			-- set colors as good and allow button clicking
			if ids_changed then
				gui.set_color(gui.get_node(hudinfo.node_confirm_button_frame), MY_GOO.COLOR_DEFAULT)
				gui.set_color(gui.get_node(hudinfo.node_confirm_button_text), MY_GOO.COLOR_TEXT_DEFAULT)
			end

			MY_GOO.button_simple(hudinfo.goo_game_confirm_id, action_id, action, func_submit_game_id)
		else
			-- set colors as locked and do not allow button clicking
			if ids_changed then
				gui.set_color(gui.get_node(hudinfo.node_confirm_button_frame), MY_GOO.COLOR_LOCKED)
				gui.set_color(gui.get_node(hudinfo.node_confirm_button_text), MY_GOO.COLOR_LOCKED)
			end
		end

	end

end


-- HUD Process: More Game-play

local function OceanScene_ChangeWeather(self, is_raining, wave_direction, run_coastal_oa_when_done)

	msg.post(CV_ID_Ocean_Setup_Script, HSH.msg_request_change_weather, {minfo_is_raining=is_raining, minfo_wave_direction=wave_direction, minfo_run_coastal_oa_too = run_coastal_oa_when_done})

end

local function OceanScene_RunCoastalOA(self, percent_coastal_oa_to_hide)

	msg.post(CV_ID_Ocean_Setup_Script, HSH.msg_request_run_coastal_oa, {minfo_percent_coastal_oa_hide = percent_coastal_oa_to_hide})

end

local function On_SpecialAction(self, special_action_name)

	if special_action_name == HSH.special_setup_first_boat or special_action_name == HSH.special_setup_pH_buoy then

		-- setup boat or buoy
		msg.post("ocean_level:/level_controller#script", HSH.msg_request_special_case_action, {minfo_special_case_key = special_action_name})
		if special_action_name == HSH.special_setup_first_boat then
			self.player_data_tbl.special_setup_item_boat_present = true
		elseif special_action_name == HSH.special_setup_pH_buoy then
			self.player_data_tbl.special_setup_item_buoy_present = true
		end

	elseif special_action_name == HSH.special_setup_coastal_oa_1 then

		-- run coastal OA
		local is_raining = true
		local run_coastal_oa_when_done = true
		OceanScene_ChangeWeather(self, is_raining, INFO:Get_BaseWave_Direction(), run_coastal_oa_when_done)
		--start but then pause the game 
		timer.delay(5, false, GamePause_On)

	elseif special_action_name == HSH.special_setup_start_goals_gauge then

		-- set goals
		-- function 'On Game Progress' checks this value then loads goals if it is on
		self.player_data_tbl.special_setup_goals_hud_enabled = true

	end

end

local function On_OutcomeEffects_Done(self)

	self.oa_outcomes_are_active = false

	Screen_Highlighter_Reset(self)

	local stage_key, substage_key = Get_Current_Stage_and_Substage(self)
	STR:Run_Generic_OutcomeFunc(stage_key, substage_key)

	msg.post(".", HSH.msg_request_game_progress)

end

local function GameHandleButtonInput(self, action_id, action)

	-- this if for testing controls and actions
	-- currently not using (see early return below)
	if not action.released or true then return end

	if action_id == HSH.control_down and action.released then
		GamePauseToggle_Internal(self)
	end

	--change weather
	if action_id == HSH.control_right or action_id == HSH.control_left then
		local is_supposed_to_rain = action_id == HSH.control_right
		local wave_direction = 1
		OceanScene_ChangeWeather(self, is_supposed_to_rain, wave_direction)
	end

	--trigger nutrient influx
	if action_id == HSH.control_up then
		OceanScene_RunCoastalOA(self, 0)
	end

end

local function Game_RunRestart(self, reset_ply_data, game_repeat_method)

	-- reset save table
	if reset_ply_data then
		local update_hud_screens, back_to_begining
		if self.gameplay_initialized then
			update_hud_screens = true
			back_to_begining = true
		end
		PlayerData_Reset(self, update_hud_screens, back_to_begining)
	end

	PlayerData_Set_Character(self)
	local set_enabled = false
	On_GO_Items_Clicked_Reset(self, set_enabled)

	-- reset click items tracker
	Items_Click_Status_Reset(self)

	self.input_is_possible = true

	self.gameplay_loop_completion_type_primary = 0
	self.gameplay_loop_completion_type_secondary = 0

	-- get stage and substage list in order
	self.gameplay_loop_status = CV_gameplay_loop.status_unknown

	-- if game has already been initialized, that means this function was called as part of a game restart
	-- so close any menus that were open 

	-- go to stage according to repeat type
	local repeat_methods = STR.CV.game_repeat_methods
	local new_i_key, playthrough_add

	if game_repeat_method ~= nil then
		if game_repeat_method == repeat_methods.repeat_type_full then
			-- full repeat
			new_i_key = 1
			playthrough_add = 1

		elseif game_repeat_method == repeat_methods.repeat_type_quiz then
			-- partial repeat starting at quiz
			-- find matching repeat_type and save i key
			for i_ss,v_ssinfo in ipairs(self.gameplay_loop_order) do
				local repeat_method = STR:Get_Game_Repeat_Value(v_ssinfo.stage_name_key, v_ssinfo.substage_name_key)
				if repeat_method == repeat_methods.repeat_type_quiz then
					new_i_key = i_ss
					playthrough_add = 1
					break
				end
			end

		end
	else
		-- default of 1
		new_i_key = 1
		playthrough_add = 0
	end

	-- Recall:
	--   'Game logic progress' function runs after selecting 'Start Game' option in starting menu
	--   'Game logic progress' function runs after clicking submit on decision
	-- so no need to run game logic progress here, 
	-- as we have updated the i key and the function will use that once called by the above methods
	-- but it does mean we have to subtract 1 from it
	new_i_key = new_i_key - 1

	PlayerData_Update_I_Key_Progress(self, new_i_key, true)
	PlayerData_Update_Repeat_Count(self, playthrough_add)

	if self.gameplay_initialized then
		-- popup and others should have already been closed by 
		-- internal choice button logic that got us to this point
		Screen_Goals_Reset(self, set_enabled)

		-- also if running game restart here then reset animals and buoy
		Run_Fader(self, true, 0.25)
		-- wait until fully dark/hidden, then reset, then fade back in
		timer.delay(0.35, false, function(self)

			msg.post("ocean_level:/level_controller#script", HSH.msg_request_special_case_action, {minfo_special_case_key = HSH.special_restart_game})
			--^ above takes 0.25 seconds at least so wait a bit before fading back in

			-- deal with game repeat types
			if game_repeat_method == repeat_methods.repeat_type_quiz then

				-- add back in starter OA hurt values
				PlayerData_RunScoreInput(self, STR.CV.update_item_values_tbls.initial_oa_affected_values_all, true)

				-- enable special aspects
				self.player_data_tbl.special_setup_goals_hud_enabled = true
				self.player_data_tbl.special_setup_data_hud_enabled = true
				self.player_data_tbl.special_setup_item_boat_present = true
				self.player_data_tbl.special_setup_item_buoy_present = true

				-- set goals and HUD data to on
				for k_itemname,_ in pairs(CV_item_groups) do
					PlayerData_UpdateHUDTracker(self, k_itemname, true, true)
				end

				-- run catch up
				PlayerData_CatchUp(self)

			end

			timer.delay(0.45, false, function(self)
				Run_Fader(self, false, 0.25)
			end)

		end)
	end

end

local function Game_First_Initialization(self)

	-- randomize random generator
	local current_time = socket.gettime()
	math.randomseed(current_time)

	GeneratedID_Manage(self)

	self.game_logic_time_start = current_time

	MY_GOO.acquire_input()

	msg.post("level_loader#collectionproxy", HSH.msg_builtin_load)
	GamePause_Off(self)

	local enabled_setting = false

	Initialize_Local_Info_Tbl()
	-- do not update HUD screens since they are not initialized yet, 
	-- need to initialize player table first though so HUD screen initialization works
	PlayerData_Reset(self)

	-- now initialize other screens and setup
	Screen_Highlighter_Initialize(self, enabled_setting)
	Screen_Goals_Initialize(self, enabled_setting)
	Screen_Decision_Initialize(self, enabled_setting)
	Screen_Popup_Initialize(self, enabled_setting)
	Screen_Data_Initialize(self, enabled_setting)
	Screen_Plot_Initialize(self, enabled_setting)

	self.num_player_affected_questions = STR:Get_Total_Choices()
	self.gameplay_loop_order = STR:GameOrder_CreateTable()

	gui.set_visible(gui.get_node(CV_Node_Save_Icon), false)

	Game_RunRestart(self)

	self.gameplay_initialized = true

	-- kick off first action, which is main menu
	-- also check if save file exists
	local save_file_exists = PlayerData_Check_MaybeLoad(self, false)
	Screen_MainMenu_Initialize(self, true, save_file_exists)

end


function init(self)

	Game_First_Initialization(self)

end

function on_message(self, message_id, message, sender)

	if message_id == HSH.msg_builtin_proxy_loaded then
		msg.post(sender, HSH.msg_builtin_enable)
	end

	if message_id == HSH.msg_request_fade_out or message_id == HSH.msg_request_fade_in then
		Run_Fader(self, message_id == HSH.msg_request_fade_out, message.minfo_fade_duration)
	elseif message_id == HSH.msg_report_go_clicked then
		On_GO_Item_Clicked_Received(self, message)
	elseif message_id == HSH.msg_request_game_progress then
		local add_i = message.minfo_game_i_stage_addition or 1
		GameLogic_Progress(self, add_i, true)
	elseif message_id == HSH.msg_request_game_repeat then
		Game_RunRestart(self, message.minfo_reset_player_file, message.minfo_game_repeat_method)
	elseif message_id == HSH.msg_set_player_character_role then
		PlayerData_Set_Character(self, message.minfo_role_name)
	elseif message_id == HSH.msg_update_item_value then
		PlayerData_RunScoreInput(self, message.minfo_item_score_update_tbl, message.minfo_overrides_instead_of_inserts, message.minfo_was_best_choice, message.minfo_was_player_choice)
	elseif message_id == HSH.msg_request_special_case_action then
		On_SpecialAction(self, message.minfo_special_case_key)
	elseif message_id == HSH.msg_report_oa_outcomes_done then
		On_OutcomeEffects_Done(self)
	elseif message_id == HSH.msg_request_update_highlighter then
		Screen_Highlighter_Reset(self, true, message.minfo_hud_highlighter_type)
	elseif message_id == HSH.msg_request_resume_catchup then
		PlayerData_CatchUp(self)
	end

end

function on_input(self, action_id, action)

	if not self.input_is_possible then return end

	Screen_MainMenu_Input(self, action_id, action)

	Screen_Decision_Input(self, action_id, action)
	Screen_Data_Input(self, action_id, action)
	Screen_Plot_Input(self, action_id, action)
	Screen_Popup_Input(self, action_id, action)
	On_GO_Item_Clicked_Requested(self, action_id, action)

	GameHandleButtonInput(self, action_id, action)

end
