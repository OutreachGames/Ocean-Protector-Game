--OVERVIEW:
--setups and controls main HUD

-- dependencies
local HSH = require ("modules.hashes_md")
local MY_GOO = require ("gui.gooey_theme_md")
local STR = require ("modules.screenplay_md")
local EXT = require ("modules.extend_md")
local INFO = require("modules.item_info_md")

-- constants
local CV_Current_Save_Version = 0.1

local CV_item_groups = {}

local CV_gameplay_loop = {
	status_running_main = 1,
	status_running_debrief = 2,
	status_unknown = 3
}

local CV_Bar_Old = vmath.vector4(0.80, 0.80, 0.80, 1)
local CV_Bar_Current = vmath.vector4(1.0, 1.0, 1.0, 1)


-- functions

local function Initialize_Local_Info_Tbl()

	for k_item_name,v_item_info in pairs(INFO.item_info) do
		if v_item_info.gui_info ~= nil then
			CV_item_groups[k_item_name] = v_item_info.gui_info
		end
	end

end

local function Get_Current_Stage_and_Substage(self)

	-- returns two string values for current stage and substage

	local event_info = self.gameplay_loop_order[self.player_data_tbl.gameplay_loop_i_key]

	if event_info == nil then
		print("Note: no valid event info exists for game loop key <"..tostring(self.player_data_tbl.gameplay_loop_i_key).."> \n")
		return nil, nil
	end

	local stage_key = event_info.stage_name_key
	local substage_key = event_info.substage_name_key

	return stage_key, substage_key

end

local function Loop_StatusType_is_Main(self)

	return self.gameplay_loop_status == CV_gameplay_loop.status_running_main

end

local function Loop_StatusType_is_Debrief(self)

	return self.gameplay_loop_status == CV_gameplay_loop.status_running_debrief

end

local function Loop_CompletionType_is_Primary(self, match_type)

	return match_type == self.gameplay_loop_completion_type_primary

end

local function Loop_CompletionType_is_Secondary(self, match_type)

	return match_type == self.gameplay_loop_completion_type_secondary

end

local function Valid_Event_Check_Full(self, match_loop_type)

	-- returns true if loop status type is main or debrief and if given completion type is primary or secondary, false otherwise 

	local status_valid = Loop_StatusType_is_Main(self) or Loop_StatusType_is_Debrief(self)

	local primary_or_secondary_valid = Loop_CompletionType_is_Primary(self, match_loop_type) or Loop_CompletionType_is_Secondary(self, match_loop_type)

	return (status_valid and primary_or_secondary_valid)

end

local function SimpleToggleHelper(self, controller_node, enabled_setting, run_sizing)

	-- simple open or close screen
	-- note, other screens have more complex things happening so this function is not used as often

	-- run enabling status and possibly sizing
	local function func_done(self, node)

		gui.set_enabled(node, enabled_setting)

	end

	if run_sizing then
		if enabled_setting then
			func_done(self, controller_node)
			gui.set_scale(controller_node, MY_GOO.MINIMIZE)
			gui.animate(controller_node, "scale", MY_GOO.MAXIMIZE, gui.EASING_OUTBACK, 0.50, 0)
		else
			--gui.set_scale(controller_node, MY_GOO.MAXIMIZE)
			gui.animate(controller_node, "scale", MY_GOO.MINIMIZE, gui.EASING_INBACK, 0.50, 0, func_done)
		end
	else
		func_done(self, controller_node)
	end

end


-- Player Data Updating, Setting, and Getting
local function PlayerData_Set_Character(self, role_key)

	-- changes player character variables and labels
	-- #TODO add save to file here

	local human_data_label
	if role_key == nil then
		self.player_data_tbl.character_role_key = "none"
		human_data_label = "Humans"
	else
		self.player_data_tbl.character_role_key = role_key
		local subitem_name = STR:Get_Subitem_from_Role(role_key)
		human_data_label = INFO:Get_Data_Item_Label("item_humans", subitem_name)
		-- remove current boat and update with new boat
		msg.post("ocean_level:/level_controller#script", HSH.msg_set_player_character_subitem, {minfo_subitem_boat_name = subitem_name})
	end

	-- use full string name since gauge tracking might not be initialized yet
	local data_human_label_node = gui.get_node("hud_data/group_item_humans/gnode_body_text")
	gui.set_text(data_human_label_node, human_data_label)

end

local function PlayerData_Set_Special(self, data_key, set_value)

	-- #TODO add save to file here
	self.player_data_tbl[data_key] = set_value

end

local function PlayerData_Update_SumBestChoices(self, value, override)

	-- #TODO add save to file here

	value = value or 1
	if override then
		self.player_data_tbl.num_best_answers = value
	else
		self.player_data_tbl.num_best_answers = self.player_data_tbl.num_best_answers + value
	end

end

local function PlayerData_Update_I_Key_Progress(self, new_ikey, override)

	-- #TODO add save to file here

	new_ikey = new_ikey or 1
	if override then
		self.player_data_tbl.gameplay_loop_i_key = new_ikey
	else
		self.player_data_tbl.gameplay_loop_i_key = self.player_data_tbl.gameplay_loop_i_key + new_ikey
	end

end

local function PlayerData_UpdateScoreTracker(self, item_key, new_value, override_instead_insert)

	-- adds an i-based entry to player save table for given item key 
	-- #TODO add save to file here

	local num_items = #self.player_data_tbl.item_data_tbl[item_key]

	local new_entry_i_index = num_items
	if override_instead_insert then
		-- override current value instead of insert new one
		new_entry_i_index = num_items
		self.player_data_tbl.item_data_tbl[item_key][new_entry_i_index].item_tracker_score = new_value
		--print("TRK: overriding player data entry for item key <"..item_key.."> with value <"..tostring(new_value).."> and number index of <"..tostring(new_entry_i_index).."> \n")
	else
		-- insert new value
		new_entry_i_index = num_items + 1
		self.player_data_tbl.item_data_tbl[item_key][new_entry_i_index] = {item_tracker_score = new_value}
		--print("TRK: adding new player data entry for item key <"..item_key.."> with value <"..tostring(new_value).."> and number index of <"..tostring(new_entry_i_index).."> \n")
	end

end

local function PlayerData_UpdateHUDTracker(self, item_key, show_item, show_goto)

	-- #TODO add save to file here

	local hud_tracker =  self.player_data_tbl.item_data_tbl[item_key]
	if show_item ~= nil then
		hud_tracker.data_item_shown = show_item
	end
	if show_goto ~= nil then
		hud_tracker.data_goto_shown = show_goto
	end

end

local function PlayerData_Get_ItemTable(self, item_key)

	if self.player_data_tbl == nil then
		print("Error: unable to get entry in player data table because player data table does not exist \n")
		return nil
	end
	if self.player_data_tbl.item_data_tbl == nil then
		print("Error: unable to get entry in item data table of player data table because item data table does not exist \n")
		return nil
	end

	local item_data = self.player_data_tbl.item_data_tbl[item_key]

	if item_data == nil then
		print("Note: item key input of <"..tostring(item_key).."> to function 'Player Data Table Get Entry' is not matched with entry, returning nil")
	end

	return item_data

end

local function PlayerData_Get_ICount(self, item_key)

	-- gets count of entries in player data table for given item key

	local item_tbl = PlayerData_Get_ItemTable(self, item_key)

	if item_tbl == nil then return 0 end

	return #item_tbl

end

local function PlayerData_Get_IEntry(self, item_key, i_key)

	-- gets an i-based entry from player save table for given item key and i-key

	local item_tbl = PlayerData_Get_ItemTable(self, item_key)
	if item_tbl == nil then
		print("Error: there is no entry in player data table for key <"..tostring(item_key).."> returning nil. ")
		return nil
	end

	-- default i-key is last in list
	i_key = i_key or #item_tbl

	return item_tbl[i_key]

end


-- HUD Screen: Data (Section 1)
local function Items_Set_Color_Tracking(self, item_name, needs_to_be_clicked)

	-- set color in data view for color and bar

	--"hud_data/group_item_ph/gnode_controller"
	local hudinfo = self.hud_data_constant
	local item_base_groupname = hudinfo.goo_group_names[item_name]
	if item_base_groupname == nil then
		print("Error: Item name of <"..tostring(item_name).."> is not present in HUD Data Constant table ...\n")
		return
	end

	local color_text, color_bar

	if needs_to_be_clicked then
		color_text = MY_GOO.COLOR_NEEDS_SELECTED
		color_bar = MY_GOO.COLOR_NEEDS_SELECTED
	else
		color_text = MY_GOO.COLOR_TEXT_DEFAULT
		color_bar = MY_GOO.COLOR_DEFAULT
	end

	--update colors, goto button, health bar, and item label 
	local huditem_name = hudinfo.goo_group_names[item_name]
	if huditem_name == nil then
		print("Error: function 'Items SetColor Tracking' provided with not known item name of <"..tostring(item_name)..">\n")
		return
	end
	local node_gotto_button_core = gui.get_node(huditem_name..hudinfo.goo_item_gotograph..hudinfo.basename_item_button_core)
	gui.set_color(node_gotto_button_core, color_bar)

	gui.set_color(gui.get_node(item_base_groupname..hudinfo.basename_item_bar_progress), color_bar)
	gui.set_color(gui.get_node(item_base_groupname..hudinfo.basename_item_bar_label), color_text)

end

local function ScreenData_ToggleItem(self, item_name, toggle_status, update_item_status, update_goto_button_status)

	-- sets status of goto button and overall item within Data HUD section

	local hudinfo = self.hud_data_constant
	local huditem_name = hudinfo.goo_group_names[item_name]
	if huditem_name == nil then
		print("Error: function 'ScreenData ToggleItem' provided with not known item name of <"..tostring(item_name)..">\n")
		return
	end

	if toggle_status == nil then
		toggle_status = false
	end

	-- update overall item status
	if update_item_status then
		local node_item_controller = gui.get_node(huditem_name..hudinfo.basename_item_controller)
		gui.set_enabled(node_item_controller, toggle_status)
		-- record that in variable for saving, too
		PlayerData_UpdateHUDTracker(self, item_name, toggle_status, nil)
	end

	-- update goto button status
	if update_goto_button_status then
		local node_gotto_button_core = gui.get_node(huditem_name..hudinfo.goo_item_gotograph..hudinfo.basename_item_button_core)
		gui.set_enabled(node_gotto_button_core, toggle_status)
		-- record that in variable for saving, too
		PlayerData_UpdateHUDTracker(self, item_name, nil, toggle_status)
	end

end

local function Items_Click_Status_Reset(self, items_to_click_info)

	-- update tracker lists of what items need to be clicked and which items have been clicked

	self.items_all_clicked = true

	self.items_that_need_clicked_list = nil
	self.items_that_need_clicked_list = {}

	self.items_that_need_clicked_sum = 0
	self.items_that_were_clicked_sum = 0

	-- default is reset all items
	if items_to_click_info == "all_items_need_clicked" then
		--print("Default arg used, all items are going to be required to be clicked on...\n")
		items_to_click_info = {}
		for k,_ in pairs(CV_item_groups) do
			items_to_click_info[k] = {
				item_name = k,
				show_debrief_text = "",
				show_data_popup = nil,
				allow_duplicate_clicks = false,
				item_was_clicked = false
			}
		end
	end

	-- if there are items to add to 'needs click' list then add them
	-- also save that we have not clicked them all yet
	local sum_to_click = 0
	if type(items_to_click_info) == "table" then

		self.items_that_need_clicked_list = items_to_click_info

		-- count up items and set color
		for k_itemname,_ in pairs(items_to_click_info) do
			sum_to_click = sum_to_click + 1
			Items_Set_Color_Tracking(self, k_itemname, true)
		end

		-- saved click tracker variables
		if sum_to_click > 0 then
			self.items_all_clicked = false
			self.items_that_need_clicked_sum = sum_to_click
		end

	end

	--print("Sum to click is "..sum_to_click.."\n")

end

local function Screen_Data_TrackerUpdate(self, item_name)

	-- update progress bar(s), default is to update all bars

	local constant = self.hud_data_constant
	local items_to_update
	if item_name ~= nil then
		items_to_update = {}
		items_to_update[item_name] = true
	else
		items_to_update = constant.goo_group_names
	end

	--# recall that updating works on disabled node

	for k_itemname,_ in pairs(items_to_update) do
		local gui_groupname = constant.goo_group_names[k_itemname]
		-- get nodes
		local max_length_node = gui.get_node(gui_groupname..constant.basename_item_bar_max_x)
		local max_size = gui.get_size(max_length_node)
		-- get health percent
		local entry_health_data = PlayerData_Get_IEntry(self, k_itemname)
		if entry_health_data == nil then
			print("Error: current entry health data for 'Player Data Table Get Entry' function is nil, not updating...\n")
			return
		end
		local new_health_value = EXT:math_clamp(entry_health_data.item_tracker_score, 0, 1)
		-- set as new size
		local progress_node = gui.get_node(gui_groupname..constant.basename_item_bar_progress)
		local new_size = gui.get_size(progress_node)
		new_size.x = EXT:math_round(max_size.x * new_health_value, 0)
		gui.set_size(progress_node, new_size)
	end

end


-- HUD Screens: Graph Plot (Section 1)
local function Plot_Data_TrackerUpdate(self, item_key)

	-- updates bar heights for plot given item
	-- reminder all items use the same plot, so only one can be open at a time

	local number_entries = PlayerData_Get_ICount(self, item_key)
	local constant = self.hud_plot_constant
	local max_graph_bars = constant.max_number_bars

	if number_entries > max_graph_bars then
		print("Error: number of graph bars <"..tostring(max_graph_bars).."> will not be able to accomdate this many player data entries <"..tostring(number_entries).."> ")
	end

	local time_shade_bars = false

	for i=1,max_graph_bars  do

		-- get nodes to update/show or hide
		local plot_id = constant.basename_individual_bar_group..i
		local progress_node = gui.get_node(plot_id..constant.basename_individual_bar_progress)
		local label_node = gui.get_node(plot_id..constant.basename_individual_bar_label)
		local set_visible

		-- if there is an i-match then make visible text and bar progress, otherwise hide visibility
		local entry_health_data = PlayerData_Get_IEntry(self, item_key, i)
		if entry_health_data ~= nil then
			-- get node sizes 
			local max_y_length_node = gui.get_node(plot_id..constant.basename_individual_bar_max_y)
			local max_size = gui.get_size(max_y_length_node)
			local new_size = gui.get_size(progress_node)
			-- get health percent
			local new_health_value = EXT:math_clamp(entry_health_data.item_tracker_score, 0, 1)
			new_size.y = EXT:math_round(max_size.y * new_health_value, 0)
			-- set as new size and enable visibility
			gui.set_size(progress_node, new_size)
			local label_text = constant.specified_bar_labels[i]
			gui.set_text(label_node, label_text or "")
			set_visible = true
		else
			set_visible = false
		end

		-- update colors, 0.9by default, 1.1 if most recently shown bar
		if time_shade_bars then
			if i == number_entries then
				gui.set_color(progress_node, CV_Bar_Current)
			else
				gui.set_color(progress_node, CV_Bar_Old)
			end
		end

		-- visibility accordingly
		gui.set_visible(label_node, set_visible)
		gui.set_visible(progress_node, set_visible)


	end

end


-- HUD Process: Observe Items (Section 1)
local function On_GO_Items_Clicked_Reset(self, enabled_setting)

	if enabled_setting == nil then
		enabled_setting = false
	end

	self.hud_can_select_go_items = enabled_setting

end

local function On_GO_Items_Clicked_Basic_Valid(self)

	-- failsafe for do not run if we are looking at decisions or plots
	-- the reset function of these should have 
	-- already set the clickable boolean, but this is a failsafe
	if self.hud_decision_dynamic.screen_isactive or self.hud_plot_dynamic.screen_isactive or self.hud_popup_dynamic.screen_isactive then
		return false
	end

	if self.hud_can_select_go_items then
		return true
	else
		return false
	end

end


-- HUD Process: Update Items 
local function QuestionScores_GetFinalPercent(self)

	if self.num_player_affected_questions <= 0 then
		-- edge case used in development testing where we removed all questions
		return 0
	else
		return self.player_data_tbl.num_best_answers/self.num_player_affected_questions
	end

end

local function PlayerData_RunScoreInput(self, score_tbl, override_instead_insert, was_best_choice)

	-- takes a table with item keys and new delta scores and updates item scores in player save table accordingly

	-- add to best choice tally if needed
	if was_best_choice then
		PlayerData_Update_SumBestChoices(self)
	end

	-- do this by looping through things we can track and checking if they match what is in table with same string key
	for k_itemname,_ in pairs(self.player_data_tbl.item_data_tbl) do
		-- get previous entry
		local previous_entry = PlayerData_Get_IEntry(self, k_itemname) or {}
		local previous_score = previous_entry.item_tracker_score or 0

		-- get new delta by matching our known trackers with the score update table provided to function
		local update_score = score_tbl[k_itemname] or score_tbl[1]

		--print("Update score for new entry for "..tostring(k_itemname).." is <"..tostring(update_score).."> \n")

		-- only update if not nil
		-- remember, do not return or break since it breakds the loop matching
		if update_score ~= nil then
			-- new value is previous + delta 
			-- clamp new entry between 0 and 1 so that next entry might have a visible positive effect
			-- IE if we did not clamp this may happened:
			--   new value gets -1.2 so that even a positive action next time does not show any benefit
			--   also visible bars are already clamped between 0 and 1 anyway
			local new_value = EXT:math_clamp(previous_score + update_score, 0, 1)

			PlayerData_UpdateScoreTracker(self, k_itemname, new_value, override_instead_insert)

			-- update hud data trackers done on click
		end

	end

end

local function DynamicText_FinalDebrief(self)

    local n = "\n"

    -- make table that has all final - initial values for all items
    local items_delta = {}
    for k_itemname,_ in pairs(CV_item_groups) do
        local val_change_start = PlayerData_Get_IEntry(self, "item_ph", 1).item_tracker_score
        local val_change_end = PlayerData_Get_IEntry(self, "item_ph").item_tracker_score
        local val_delta = val_change_end - val_change_start
        local percent_delta = (val_delta/val_change_start)
        items_delta[k_itemname] = percent_delta
    end

    local function func_get_delta_text(percent_delta, special_acidity_case)

        -- get net change 
        local net_change_text
        if percent_delta > 0.1 then
            net_change_text = "Increased"
        elseif percent_delta < -0.1 then
            net_change_text = "Decreased"
        end

        -- get size of change
        local magnitude_val = math.abs(percent_delta)
        local magnitude_text
        if magnitude_val > 0.8 then
            magnitude_text = "Substantially"
        elseif percent_delta > 0.5 then
            magnitude_text = "Moderately"
        elseif percent_delta > 0.5 then
            magnitude_text = "Slightly"
        end

        -- combine and return
        local combined_text = ""
        if net_change_text ~= nil and magnitude_text ~= nil then
            combined_text = magnitude_text .. " " .. net_change_text
        else
            combined_text = "Remained Relatively Stable"
        end

        if special_acidity_case then
			if magnitude_text == nil then
				magnitude_text = ""
			else
				magnitude_text = magnitude_text.." "
			end
            if percent_delta > 0.1 then
                combined_text = "On average, the ocean became "..string.lower(magnitude_text).."less acidic."
            elseif percent_delta < -0.1 then
                combined_text = "On average, the ocean became "..string.lower(magnitude_text).."more acidic."
            else
                combined_text = "On average, the acidity of the ocean water remained about the same."
            end
        end

        return combined_text

    end

    -- pH
	local indent = "  "
	--local txt_co2 = "Average Annual Carbon Dioxide Emissions: "..n..indent..func_get_delta_text(items_delta.item_ph)

    local txt_ph = "Average Annual Ocean pH: "..n..indent..func_get_delta_text(items_delta.item_ph)..n..indent..func_get_delta_text(items_delta.item_ph, true)

    -- ocean life on average (yes just using pH since we want to reinforce that pH and ocean health are tied together)
    local txt_ocean_life = "Average Health of Ocean Life: "..n..indent..func_get_delta_text(items_delta.item_ph)

    -- human
    local prefix_humans = INFO:Get_Y_Axis_Label("item_humans", STR:Get_Subitem_from_Role(self.player_data_tbl.character_role_key))..": "
    local txt_your_success = prefix_humans..n..indent..func_get_delta_text(items_delta.item_humans)

    -- recommendation text
    local final_score = QuestionScores_GetFinalPercent(self)
    local txt_recomendations

    local good_suffix = "helped reduce ocean acidification, increased the health of ocean life, and improved your character goals."
    local reminder_suffix = "choices that help reduce energy usage and/or nutrient pollution are effective ways to help prevent ocean acidification. "
    local try_again_txt
	if not self.final_debrief_shown then
		self.final_debrief_shown = true
		try_again_txt = "\n\nYou will soon have an option to rerun the game, too. "
	else
		try_again_txt = "\n\nDon't forget, you can rerun the game, too. "
	end

    -- recall that many questions have 0 change, so while they may not help as much they also do not hinder as much
    if final_score == 100 then
        txt_recomendations = "Fantastic work with the questions. Every choice you made "..good_suffix.." As you have shown,"..reminder_suffix..try_again_txt
    elseif final_score > 70 then
        txt_recomendations = "Very good work with the questions. Most of the choices you made "..good_suffix.." A few of the other choices did not result in outcomes that were as beneficial. Remember,"..reminder_suffix..try_again_txt
    elseif final_score > 40 then
        txt_recomendations = "Good work with the questions. Many of the choices you made "..good_suffix.." Other choices did not result in outcomes that were as beneficial. Remember,"..reminder_suffix..try_again_txt
    else
		--"It can be tricky to know what the best choice might be for each question. " --might be too much reading
        txt_recomendations = "Good effort with the questions. Even if ocean health and your character goals may not have improved, it is still very useful to learn about how different choices lead to different outcomes. Remember,"..reminder_suffix..try_again_txt
    end

    local text_tbl = {
        --"Summary of Decision Outcomes:",
        --"",
        "Percentage of decisions with most optimal choices: "..n..indent..string.format("%.0f", (final_score*100)).."% "..n,
        -- ^possibly remove/comment out?
        --"Summary of changes over time:",
        txt_ph,
		"",
        txt_ocean_life,
		"",
        txt_your_success,
        n,
        "Recomendations: ",
		txt_recomendations
    }

    return table.concat(text_tbl, n)

end

local function TranslateHelperText(self, hashed_text_key)

	-- takes hashed text key and translates and updates it with internal logic
	-- returns as string

	if hashed_text_key == HSH.helper_outcome_final_debrief then
		return DynamicText_FinalDebrief(self), "Outcome Summary"
	else
		return ""
	end

end


-- HUD Screen: Goals
local function Screen_Goals_Reset(self, enabled_setting, run_sizing, text)

	-- reset Goals screen of HUD

	-- default args
	if enabled_setting == nil then
		enabled_setting = false
	end

	-- set enabled status
	local constant = self.hud_goals_constant
	local controller_node = gui.get_node(constant.node_controller)

	-- run enabling status and possibly sizing
	local function func_done(self, node)

		gui.set_enabled(node, enabled_setting)

		-- enable and set text if new
		local text_node = gui.get_node(constant.node_text_body)
		if text ~= nil then
			gui.set_text(text_node, text)
		end

		-- try to resize hud screen so text fits
		local shown_text = gui.get_text(text_node)
		local str_length = #shown_text

		-- 220ish is base with 2 lines and 330ish is with 5 lines, 100/3
		local line_per_extra_y = 28
		local min_frame_y = 220
		local str_length_per_line = 15
		local base_num_lines = 2

		local num_extra_lines = math.max((str_length/str_length_per_line) - base_num_lines, 0)
		local new_y_frame = math.max(min_frame_y + (num_extra_lines*line_per_extra_y), min_frame_y)

		local frame_node = gui.get_node(constant.node_frame_core)
		gui.set_size(frame_node, vmath.vector3(gui.get_size(frame_node).x, new_y_frame, 0))

	end

	if run_sizing then
		if enabled_setting then
			func_done(self, controller_node)
			gui.set_scale(controller_node, MY_GOO.MINIMIZE)
			gui.animate(controller_node, "scale", MY_GOO.MAXIMIZE, gui.EASING_OUTBACK, 0.50, 0)
		else
			--gui.set_scale(controller_node, MY_GOO.MAXIMIZE)
			gui.animate(controller_node, "scale", MY_GOO.MINIMIZE, gui.EASING_INBACK, 0.50, 0, func_done)
		end
	else
		func_done(self, controller_node)
	end

	-- reset tracking table
	self.hud_goals_dynamic.screen_isactive = enabled_setting

	if enabled_setting and not self.player_data_tbl.special_setup_goals_hud_enabled then
		PlayerData_Set_Special(self, "special_setup_goals_hud_enabled", true)
	end

end

local function Screen_Goals_Initialize(self, enabled_status)

	-- set constants and setup dynamic values and components

	local basename = "hud_goals"

	self.hud_goals_constant = nil
	self.hud_goals_dynamic = nil

	-- set constants
	self.hud_goals_constant = {
		hud_basename = basename,
		node_controller = basename .. "/gnode_controller",
		node_text_title = basename .. "/gnode_header_text",
		node_text_body = basename .. "/gnode_body_text",
		node_frame_core = basename .. "/group_frame/gui_frame_core"
	}

	-- set dynamics
	self.hud_goals_dynamic = {}
	Screen_Goals_Reset(self, enabled_status)

end

local function Screen_Goals_Input(self, action_id, action)

	-- runs 'On Input' for Goals screen on HUD

	-- early out if not allowed to use
	if not self.hud_goals_dynamic.screen_isactive then
		return
	end

	local Hud_info = self.hud_goals_constant

end


-- HUD Screen: Popup 
local function Screen_Popup_Reset(self, enabled_setting, run_sizing, reset_values, body_text, title_text, size_type)

	-- reset Popup screen of HUD

	-- default args
	if enabled_setting == nil then
		enabled_setting = false
	end
	if reset_values == nil then
		reset_values = false
	end

	-- set enabled status
	local constant = self.hud_popup_constant
	local controller_node = gui.get_node(constant.node_controller)

	-- enable and set text, but only if enabling
	-- do this before sizing so text sizer can be used
	if enabled_setting and reset_values then
		if body_text ~= nil then
			gui.set_text(gui.get_node(constant.node_text_body), body_text)

			-- also try to auto size if none specified
			if size_type == nil then
				local _, counted_newlines = body_text:gsub('\n', '\n')
				local num_lines_guess = math.max(counted_newlines, #body_text/80)
				if num_lines_guess > 12 then
					size_type = "size_huge"
				elseif num_lines_guess > 8 then
					size_type = "size_large"
				elseif num_lines_guess > 3 then
					size_type = "size_medium"
				else
					size_type = "size_small"
				end
				self.hud_popup_dynamic.overall_size = size_type or "size_medium"
			end

		end
		title_text = title_text or "New Information"
		if title_text ~= nil then
			gui.set_text(gui.get_node(constant.node_text_title), title_text)
		end
	end

	-- run enabling status and possibly sizing
	local function func_done(self, node)

		gui.set_enabled(node, enabled_setting)

	end

	if run_sizing then
		if enabled_setting then
			func_done(self, controller_node)
			gui.set_scale(controller_node, MY_GOO.MINIMIZE)

			local y_ranges = {
				size_small = {250, 119, 108},
				size_medium = {400, 258, -51},
				size_large = {600, 468, -251},
				size_huge = {820, 680, -465},
			}

			local yvals = y_ranges[self.hud_popup_dynamic.overall_size]

			local node_body_frame = gui.get_node(constant.node_frame_body)
			local node_body_text = gui.get_node(constant.node_text_body)
			local node_button_frame = gui.get_node(constant.node_continue_frame)
			gui.set_size(node_body_frame, vmath.vector3(gui.get_size(node_body_frame).x, yvals[1], 0))
			gui.set_size(node_body_text, vmath.vector3(gui.get_size(node_body_text).x, yvals[2], 0))
			gui.set_position(node_button_frame, vmath.vector3(gui.get_position(node_button_frame).x, yvals[3], 0))

			gui.animate(controller_node, "scale", MY_GOO.MAXIMIZE, gui.EASING_OUTBACK, 0.50, 0)
		else
			--gui.set_scale(controller_node, MY_GOO.MAXIMIZE)
			gui.animate(controller_node, "scale", MY_GOO.MINIMIZE, gui.EASING_INBACK, 0.50, 0, func_done)
		end
	else
		func_done(self, controller_node)
	end

	-- exit if not resetting answer option tracker variables
	if not reset_values then return end

	-- reset tracking table
	self.hud_popup_dynamic.screen_isactive = enabled_setting
	self.hud_popup_dynamic.overall_size = size_type or "size_medium"

end

local function Screen_Popup_Initialize(self, enabled_status)

	-- set constants and setup dynamic values and components

	local basename = "hud_newinfo"

	self.hud_popup_constant = nil
	self.hud_popup_dynamic = nil

	-- set constants
	self.hud_popup_constant = {
		hud_basename = basename,
		node_controller = basename .. "/gnode_controller",
		node_text_title = basename .. "/group_header/gui_frame_text",
		node_text_body = basename .. "/gnode_info_text",
		node_frame_body = basename .. "/group_body/gui_frame_core",
		node_continue_frame = basename .. "/group_button_submit/gui_button_core",
		node_continue_text = basename .. "group_button_submit/gui_button_label",
		goo_continue_name = basename .. "/group_button_submit"
	}

	-- set dynamics
	self.hud_popup_dynamic = {}
	local run_sizing = false
	local reset_values = true
	Screen_Popup_Reset(self, enabled_status, run_sizing, reset_values)

end

local function Screen_Popup_Input(self, action_id, action)

	-- runs 'On Input' for Decision screen on HUD

	-- early out if not allowed to use
	if not self.hud_popup_dynamic.screen_isactive or self.hud_decision_dynamic.screen_isactive or self.hud_plot_dynamic.screen_isactive then
		return
	end

	local Hud_info = self.hud_popup_constant

	local function func_continue(button)

		-- handle all the button functionality

		-- set that this screen is no longer interactive
		local run_sizing = false
		local reset_values = true
		Screen_Popup_Reset(self, false, run_sizing, reset_values)

		--print("Continue Button was pressed")

		local new_info_loop_type = STR.CV.goal_completed_types.class_new_information

		if Valid_Event_Check_Full(self, new_info_loop_type) then

			-- if primary loop type is new_info and not in debrief then run debrief check
			-- if that is not the case, then it means we got to this new_info via
			-- some kind of debrief, whether it is a debrief of a new_info, decision, or item_click
			if Loop_CompletionType_is_Primary(self, new_info_loop_type) and Loop_StatusType_is_Main(self) then

				local stage_key, substage_key = Get_Current_Stage_and_Substage(self)
				local debrief_text, is_debrief_dynamic = STR:Get_NewInfo_Text_Debrief(stage_key, substage_key)
				local debrief_title_text

				if is_debrief_dynamic then
					debrief_text, debrief_title_text = TranslateHelperText(self, debrief_text)
				end

				-- if there is debrief for this new_info screen then run it, 
				-- otherwise finish up 
				if debrief_text ~= nil and debrief_text ~= "" then
					self.gameplay_loop_status = CV_gameplay_loop.status_running_debrief
					self.gameplay_loop_completion_type_secondary = STR.CV.goal_completed_types.class_new_information
					local run_sizing_debrief = true
					local update_values_to_debrief = true
					Screen_Popup_Reset(self, true, run_sizing_debrief, update_values_to_debrief, debrief_text, debrief_title_text)
				else
					STR:Run_NewInfo_Text_OutcomeFunc(stage_key, substage_key)
					msg.post(".", HSH.msg_request_game_progress)
				end

			else
				-- in some form of debrief 
				-- if debrief of new_info then run new_info completion function if any exists before just progressing. 
				-- this is b/c the event type we came from to this stage 
				-- is not a new_info and already had it's outcome func ran 
				--#TODO update here with additional types, might not always want to run progress
				local progress_to_next_stage = false

				if Loop_CompletionType_is_Primary(self, new_info_loop_type) then
					progress_to_next_stage = true
				elseif Loop_CompletionType_is_Primary(self, STR.CV.goal_completed_types.class_click_items) then
					if self.items_all_clicked then
						progress_to_next_stage = true
					end
				else
					progress_to_next_stage = true
				end

				if progress_to_next_stage then
					local stage_key, substage_key = Get_Current_Stage_and_Substage(self)
					STR:Run_NewInfo_Text_OutcomeFunc(stage_key, substage_key)
					msg.post(".", HSH.msg_request_game_progress)
				end
			end

		end

	end

	MY_GOO.button_simple(Hud_info.goo_continue_name, action_id, action, func_continue)

end


-- HUD Screen: Decision
local function Screen_Decision_Reset(self, enabled_setting, run_sizing, reset_tracker_variables, num_options, question_text, answer_text_tbl, hint_text)

	-- reset Decision screen of HUD

	-- default args
	if enabled_setting == nil then
		enabled_setting = false
	end
	if reset_tracker_variables == nil then
		reset_tracker_variables = false
	end
	if num_options == nil then
		num_options = 3
	end

	-- set enabled status
	local constant = self.hud_decision_constant
	local controller_node = gui.get_node(constant.node_controller)

	local has_hint
	if hint_text ~= nil and hint_text ~= "" then
		has_hint = true
	end

	-- run enabling status and possibly sizing
	local function func_done(self, node)

		gui.set_enabled(node, enabled_setting)

		-- always disable hint box and hint button
		-- will enable below if enabling screen
		gui.set_text(gui.get_node(constant.node_hint_button_text), "Show Hint")
		local hint_frame = gui.get_node(constant.node_hint_button_frame)
		gui.set_enabled(hint_frame, false)
		gui.set_enabled(gui.get_node(constant.node_hint_subcontroller), false)

		-- get which buttons to enable/disable when starting up/enabling
		-- disable all buttons to start except for those that will be used
		if enabled_setting then
			for i_node_num,v_node_id in ipairs(constant.goo_option_names) do
				local status = false
				if i_node_num <= num_options then
					status = true
				end
				gui.set_enabled(gui.get_node(v_node_id..constant.goo_option_core_basename), status)
				gui.set_enabled(gui.get_node(v_node_id..constant.goo_option_label_basename), status)
			end

			-- set base position and height of frame and submit button depending on number of options
			local pos_update = constant.goo_option_placement[num_options]
			gui.set_position(node, vmath.vector3(gui.get_position(node).x, pos_update.frame_position_y, 0))

			local frame_node = gui.get_node(constant.node_frame)
			gui.set_size(frame_node, vmath.vector3(gui.get_size(frame_node).x, pos_update.frame_ylength, 0))

			local button_node = gui.get_node(constant.node_submit_button_frame)
			local current_pos_button = gui.get_position(button_node)
			gui.set_position(button_node, vmath.vector3(current_pos_button.x, pos_update.submit_position_y, 0))

			-- enable hint button if hint present
			-- also set hint text now, too
			if has_hint then
				gui.set_enabled(hint_frame, true)
				gui.set_position(hint_frame, vmath.vector3(-current_pos_button.x, pos_update.submit_position_y, 0))
				gui.set_text(gui.get_node(constant.node_hint_body_text), hint_text)
			end

		end

	end

	if run_sizing then
		if enabled_setting then
			func_done(self, controller_node)
			gui.set_scale(controller_node, MY_GOO.MINIMIZE)
			gui.animate(controller_node, "scale", MY_GOO.MAXIMIZE, gui.EASING_OUTBACK, 0.50, 0)
		else
			--gui.set_scale(controller_node, MY_GOO.MAXIMIZE)
			gui.animate(controller_node, "scale", MY_GOO.MINIMIZE, gui.EASING_INBACK, 0.50, 0, func_done)
		end
	else
		func_done(self, controller_node)
	end

	-- exit if not resetting answer option tracker variables
	if not reset_tracker_variables then return end

	-- reset tracking table
	self.hud_decision_dynamic.screen_isactive = enabled_setting
	self.hud_decision_dynamic.goo_option_selected = 0
	self.hud_decision_dynamic.goo_sumbit_isactive = false
	self.hud_decision_dynamic.number_answer_options = num_options
	self.hud_decision_dynamic.has_hint_available = has_hint
	self.hud_decision_dynamic.hint_box_is_open = false

	-- actually reset radio nodes, including resetting text color
	for _,v_nodeid in ipairs(constant.goo_option_names) do
		gui.set_color(gui.get_node(v_nodeid..constant.goo_option_label_basename), MY_GOO.COLOR_TEXT_DEFAULT)
		MY_GOO.radio(v_nodeid).set_selected(false)
	end

	-- set tint on button to dark/locked
	gui.set_color(gui.get_node(constant.node_submit_button_frame), MY_GOO.COLOR_LOCKED)
	gui.set_color(gui.get_node(constant.node_submit_button_text), MY_GOO.COLOR_LOCKED)

	-- set text 
	if question_text ~= nil then
		gui.set_text(gui.get_node(constant.node_question_text), question_text)
	end

	-- update answer option text and save keys in same order
	self.hud_decision_dynamic.answer_choice_keys = nil
	self.hud_decision_dynamic.answer_choice_keys = {}
	if type(answer_text_tbl) == "table" then
		for i,v_info in ipairs(answer_text_tbl) do
			local q_node_name = constant.goo_option_names[i]..constant.goo_option_label_basename
			gui.set_text(gui.get_node(q_node_name), v_info.choice_text_answer)
			--print("Setting node <"..q_node_name.."> to text <"..v_info.choice_text_answer.."> \n")
			self.hud_decision_dynamic.answer_choice_keys[i] = v_info.user_choice_key
		end
	end

end

local function Screen_Decision_Initialize(self, enabled_status)

	-- set constants and setup dynamic values and components

	local basename = "hud_decision"

	self.hud_decision_constant = nil
	self.hud_decision_dynamic = nil

	-- set constants
	self.hud_decision_constant = {
		hud_basename = basename,
		node_controller = basename .. "/gnode_controller",
		node_frame = basename .. "/group_body/gui_frame_core",
		node_question_text = basename .. "/gnode_question_text",
		goo_option_placement = {
			{frame_ylength = 740, frame_position_y = 450, submit_position_y = -368},
			{frame_ylength = 740, frame_position_y = 450, submit_position_y = -368},
			{frame_ylength = 740, frame_position_y = 450, submit_position_y = -368},
			{frame_ylength = 868, frame_position_y = 536, submit_position_y = -495}
		},
		goo_option_names = {
			basename.."/group_option_1",
			basename.."/group_option_2",
			basename.."/group_option_3",
			basename.."/group_option_4"
		},
		goo_option_label_basename = "/gui_radio_label",
		goo_option_core_basename = "/gui_radio_core",
		goo_submit_name = basename.."/group_button_submit",
		goo_hint_name = basename.."/group_button_hint",
		node_submit_button_frame = basename.."/group_button_submit/gui_button_core",
		node_submit_button_text = basename.."/group_button_submit/gui_button_label",
		node_hint_subcontroller = basename .. "/gnode_hint_box_subcontroller",
		node_hint_button_frame = basename .. "/group_button_hint/gui_button_core",
		node_hint_button_text = basename .. "/group_button_hint/gui_button_label",
		node_hint_body_text = basename .. "/gnode_hint_box_body"
	}

	-- set dynamics
	self.hud_decision_dynamic = {}
	local run_sizer = false
	local reset_answers = true
	Screen_Decision_Reset(self, enabled_status, run_sizer, reset_answers)

end

local function Screen_Decision_Input(self, action_id, action)

	-- runs 'On Input' for Decision screen on HUD

	-- early out if not allowed to use
	if not self.hud_decision_dynamic.screen_isactive or self.hud_plot_dynamic.screen_isactive then
		return
	end

	local Hud_info = self.hud_decision_constant
	local num_options = self.hud_decision_dynamic.number_answer_options

	local function func_radiogroup(local_group_id, local_action_id, local_action)

		-- handles all the radio functionality

		local function radio_base(index)

			-- run the logic when radio selected

			-- set the selected index and allow the submit button
			self.hud_decision_dynamic.goo_option_selected = index
			self.hud_decision_dynamic.goo_sumbit_isactive = true
			gui.set_color(gui.get_node(Hud_info.node_submit_button_frame), MY_GOO.COLOR_DEFAULT)
			gui.set_color(gui.get_node(Hud_info.node_submit_button_text), MY_GOO.COLOR_TEXT_DEFAULT)

			-- visually highlight which choice was selected
			local other_nodes = {1, 2, 3}
			other_nodes[index] = nil

			-- note that trying to use the bright white makes text darker actually
			gui.set_color(gui.get_node(Hud_info.goo_option_names[index]..Hud_info.goo_option_label_basename), MY_GOO.COLOR_TEXT_DEFAULT)
			for _,v_otherindex in pairs(other_nodes) do
				gui.set_color(gui.get_node(Hud_info.goo_option_names[v_otherindex]..Hud_info.goo_option_label_basename), MY_GOO.COLOR_TEXT_UNSELECTED)
			end

			--print("radio "..index.." selected")
		end

		local function func_radio_1(radio)
			radio_base(1)
		end
		local function func_radio_2(radio)
			radio_base(2)
		end
		local function func_radio_3(radio)
			radio_base(3)
		end
		local function func_radio_4(radio)
			radio_base(4)
		end

		if num_options >= 1 then
			MY_GOO.radio(Hud_info.goo_option_names[1], local_group_id, local_action_id, local_action, func_radio_1)
		end
		if num_options >= 2 then
			MY_GOO.radio(Hud_info.goo_option_names[2], local_group_id, local_action_id, local_action, func_radio_2)
		end
		if num_options >= 3 then
			MY_GOO.radio(Hud_info.goo_option_names[3], local_group_id, local_action_id, local_action, func_radio_3)
		end
		if num_options >= 4 then
			MY_GOO.radio(Hud_info.goo_option_names[4], local_group_id, local_action_id, local_action, func_radio_4)
		end

	end

	local function func_submit(button)

		-- handle all the button functionality

		--^ need to have tracker as off so if plot checks it properly knows what the status is
		-- if plot thinks decisions is still on it can re-enable decision 
		--#TODO save the values to a master table before clearing them!
		local i = self.hud_decision_dynamic.goo_option_selected
		local answer_string_key = self.hud_decision_dynamic.answer_choice_keys[i]

		local run_sizer = false
		local reset_values = true
		Screen_Decision_Reset(self, false, run_sizer, reset_values)

		--print("Submit Button was pressed")

		local loop_type = STR.CV.goal_completed_types.class_decisison

		if Valid_Event_Check_Full(self, loop_type) then
			if Loop_CompletionType_is_Primary(self, loop_type) then

				-- run outcome function
				local stage_key, substage_key = Get_Current_Stage_and_Substage(self)
				local role_key = self.player_data_tbl.character_role_key
				STR:Run_Decision_Answer_OutcomeFunc(stage_key, substage_key, role_key, answer_string_key)

				-- do debrief text if present
				-- this consists of opening popup window and setting goal type
				local debrief_text, is_debrief_dynamic = STR:Get_Decision_Text_AnswerDebrief(stage_key, substage_key, role_key, answer_string_key)
				local debrief_title_text

				if is_debrief_dynamic then
					debrief_text, debrief_title_text = TranslateHelperText(self, debrief_text)
				end

				if Loop_StatusType_is_Main(self) and debrief_text ~= nil and debrief_text ~= "" then

					self.gameplay_loop_status = CV_gameplay_loop.status_running_debrief
					self.gameplay_loop_completion_type_secondary = STR.CV.goal_completed_types.class_new_information

					-- also subtract one from current progress if incorrect so we go back to it in the next submit
					if STR:Get_Decision_Answer_RepeatD(stage_key, substage_key, role_key, answer_string_key) then
						PlayerData_Update_I_Key_Progress(self, -1)
					end

					-- add debrief screen and also update goals
					local run_sizing_goals = false
					Screen_Goals_Reset(self, true, run_sizing_goals, "Evaluate outcome of choice")

					local run_sizing_popup = true
					local reset_values_popup = true
					Screen_Popup_Reset(self, true, run_sizing_popup, reset_values_popup, debrief_text, debrief_title_text or "Update")

				else
					msg.post(".", HSH.msg_request_game_progress)
				end
			end
		end

	end

	local function func_hint_toggle(button)

		-- toggle hint box

		local hint_button_label
		local enabled_setting
		local controller_node = gui.get_node(Hud_info.node_hint_subcontroller)

		local current_setting = self.hud_decision_dynamic.hint_box_is_open
		local new_setting = not current_setting
		self.hud_decision_dynamic.hint_box_is_open = new_setting

		if new_setting then
			-- if hint open then close 
			hint_button_label = "Hide Hint"
		else
			-- if hint closed then open
			hint_button_label = "Show Hint"
		end

		SimpleToggleHelper(self, controller_node, new_setting, true)
		gui.set_text(gui.get_node(Hud_info.node_hint_button_text), hint_button_label)

	end

	MY_GOO.radiogroup("radiogroup_answer_options", action_id, action, func_radiogroup)

	if self.hud_decision_dynamic.has_hint_available then
		MY_GOO.button_simple(Hud_info.goo_hint_name, action_id, action, func_hint_toggle)
	end

	if self.hud_decision_dynamic.goo_sumbit_isactive then
		MY_GOO.button_simple(Hud_info.goo_submit_name, action_id, action, func_submit)
	end

end


-- HUD Screen: Graph Plot (Section 2)
local function Screen_Plot_Reset(self, enabled_setting, run_sizing, item_group_key)

	-- reset Graph Plot screen of HUD

	-- default args
	if enabled_setting == nil then
		enabled_setting = false
	end

	-- set enabled status
	local constant = self.hud_plot_constant
	local controller_node = gui.get_node(constant.node_controller)

	-- run enabling status and possibly sizing
	local function func_done(self, node)

		gui.set_enabled(node, enabled_setting)

		-- if enabling 
			-- if decision tracker is active then disable decision node
		-- if disabling
			-- if decision tracker is active then enable decision node
		local reset_values = false
		if enabled_setting then
			local run_decision_sizer = false
			if self.hud_decision_dynamic.screen_isactive then
				Screen_Decision_Reset(self, false, run_decision_sizer, reset_values)
			end
			if self.hud_popup_dynamic.screen_isactive then
				Screen_Popup_Reset(self, false, run_decision_sizer, reset_values)
			end
		else
			local run_decision_sizer = true
			if self.hud_decision_dynamic.screen_isactive then
				Screen_Decision_Reset(self, true, run_decision_sizer, reset_values)
			end
			if self.hud_popup_dynamic.screen_isactive then
				Screen_Popup_Reset(self, true, run_decision_sizer, reset_values)
			end
		end

	end

	if run_sizing then
		if enabled_setting then
			func_done(self, controller_node)
			gui.set_scale(controller_node, MY_GOO.MINIMIZE)
			gui.animate(controller_node, "scale", MY_GOO.MAXIMIZE, gui.EASING_OUTBACK, 0.50, 0)
		else
			--gui.set_scale(controller_node, MY_GOO.MAXIMIZE)
			gui.animate(controller_node, "scale", MY_GOO.MINIMIZE, gui.EASING_INBACK, 0.50, 0, func_done)
		end
	else
		func_done(self, controller_node)
	end

	-- reset tracker variables
	self.hud_plot_dynamic.screen_isactive = enabled_setting
	self.hud_plot_dynamic.active_itemkey = item_group_key

	-- if enabling then update graph
	if not enabled_setting or item_group_key == nil then return end

	-- set the axis and labels depending on the specified item group
	local item_info = CV_item_groups[item_group_key]
	if item_info == nil then
		print("Error: the following key does not exist in the item groups list: "..item_group_key.."\n")
		return
	end

	-- get subname if human and we have chosen a character
	local opt_subitem_name
	if item_group_key == "item_humans" then
		opt_subitem_name = STR:Get_Subitem_from_Role(self.player_data_tbl.character_role_key)
		-- will be nil if has not selected character yet
	end

	local y_axis_label = INFO:Get_Y_Axis_Label(item_group_key, opt_subitem_name)

	-- set title
	local title = y_axis_label .. " through Time"
	title = string.gsub(title, " ", "   ")
	gui.set_text(gui.get_node(constant.node_title_name), title)

	-- set y axis label and ticks
	local y_label = string.gsub(y_axis_label, " ", "   ")
	gui.set_text(gui.get_node(constant.node_y_axis_label), y_label)

	-- set plot height and toggle
	local tick_labels = INFO:Get_Y_Tick_Labels(item_group_key, opt_subitem_name)
	for i_tickindex,v_node_y_tickname in ipairs(constant.node_y_ticks) do
		gui.set_text(gui.get_node(v_node_y_tickname), tick_labels[i_tickindex])
	end

	-- set subtitle helper text
	local subtitle_text = INFO:Get_Plot_Subtitle_Text(item_group_key, opt_subitem_name) or ""
	gui.set_text(gui.get_node(constant.node_helper_subtitle_text), subtitle_text)

	-- set x axis label (tick labels and bar visibility handled in 'plot tracker update function' below)
	gui.set_text(gui.get_node(constant.node_x_axis_label), INFO:Get_X_Axis_Label())

	-- enable and set graph bars accordingly
	-- get item key, and for each item bar progress and label to visible
	Plot_Data_TrackerUpdate(self, item_group_key)

end

local function Screen_Plot_Initialize(self, enabled_status)

	-- set constants and setup dynamic values and components

	local basename = "hud_timeplot"
	local plot_base = "/group_plot"

	self.hud_plot_constant = nil
	self.hud_plot_dynamic = nil

	-- set constants
	self.hud_plot_constant = {
		hud_basename = basename,
		node_controller = basename .. "/gnode_controller",
		goo_exit_name = basename .. "/group_button_submit",
		node_title_name = basename .. plot_base .. "/gui_text_title",
		node_y_axis_label = basename .. plot_base .. "/gui_text_label_yaxis",
		node_x_axis_label = basename .. plot_base .. "/gui_text_label_xaxis",
		-- add ytick labels
		-- must match number of labels specified in INFO module!
		node_y_ticks = {
			basename..plot_base.."/gui_text_label_ytick_p0",
			basename..plot_base.."/gui_text_label_ytick_p25",
			basename..plot_base.."/gui_text_label_ytick_p50",
			basename..plot_base.."/gui_text_label_ytick_p75",
			basename..plot_base.."/gui_text_label_ytick_p100",
		},
		max_number_bars = 11,
		node_groupplots_controller = basename..plot_base.."/group_plots",
		basename_individual_bar_group = basename..plot_base.."/group_plot_",
		basename_individual_bar_label = "/gui_label",
		specified_bar_labels = INFO:Get_X_Tick_Labels(),
		basename_individual_bar_max_y = "/group_bar_element/tracker_max_length",
		basename_individual_bar_progress = "/group_bar_element/gui_frame_progress",
		node_helper_subtitle_text = basename .. plot_base .. "/gui_text_subtitle"
	}

	-- set dynamics
	self.hud_plot_dynamic = {}
	Screen_Plot_Reset(self, enabled_status)

end

local function Screen_Plot_Input(self, action_id, action)

	-- runs 'On Input' for Decision screen on HUD

	-- early out if not allowed to use
	if not self.hud_plot_dynamic.screen_isactive then
		return
	end

	local Hud_info = self.hud_plot_constant

	local function func_exit(button)

		-- handle all the button functionality

		-- set that this screen is no longer interactive
		local run_sizer = false
		Screen_Plot_Reset(self, false, run_sizer)

		--print("Exit Button was pressed")

	end

	MY_GOO.button_simple(Hud_info.goo_exit_name, action_id, action, func_exit)

end


-- HUD Screen: Data (Section 2)
local function Screen_Data_Reset(self, enabled_setting, disable_items_for_starting_out)

	-- reset Data screen of HUD

	-- default args
	if enabled_setting == nil then
		enabled_setting = false
	end

	-- disable goto button and overall item for starting out
	if disable_items_for_starting_out then
		for k,_ in pairs(CV_item_groups) do
			ScreenData_ToggleItem(self, k, false, true, true)
		end
	end

	-- set enabled status
	local constant = self.hud_data_constant
	gui.set_enabled(gui.get_node(constant.node_controller), enabled_setting)

	-- reset tracking table
	self.hud_data_dynamic.screen_isactive = enabled_setting
	self.hud_data_dynamic.is_maximized = true
	self.hud_data_dynamic.goo_items_areactive = enabled_setting

	-- enable and set data summary bars accordingly
	Screen_Data_TrackerUpdate(self)

	if enabled_setting and not self.player_data_tbl.special_setup_data_hud_enabled then
		PlayerData_Set_Special(self, "special_setup_data_hud_enabled", true)
	end

end

local function Screen_Data_Initialize(self, enabled_status)

	-- set constants and setup dynamic values and components

	local basename = "hud_data"

	self.hud_data_constant = nil
	self.hud_data_dynamic = nil

	-- set constants
	self.hud_data_constant = {
		hud_basename = basename,
		node_frame_core = basename .. "/group_frame/gui_frame_core",
		node_controller = basename .. "/gnode_controller",
		node_subcontroller = basename .. "/gnode_subcontroller",
		node_max_length = basename .. "/tracker_max_length",
		node_min_length = basename .. "/tracker_min_length",
		goo_minimizer = basename .. "/group_button_sizer",
		goo_item_gotograph = "/group_button_goto",
		basename_item_bar_progress = "/group_healthbar/gui_frame_progress",
		basename_item_bar_max_x = "/group_healthbar/tracker_max_length",
		basename_item_bar_label = "/gnode_body_text",
		basename_item_button_core = "/gui_button_core",
		basename_item_controller = "/gnode_controller",
		goo_group_names = {},
		goo_group_goto_buttons = {},
	}

	-- add goto graph button strings
	-- also disable goto buttons and overall items until gameplay adds/reveals them
	for k,v in pairs(CV_item_groups) do
		local name = basename .. v.group_name
		self.hud_data_constant.goo_group_names[k] = name
		local button_name = name .. self.hud_data_constant.goo_item_gotograph
		self.hud_data_constant.goo_group_goto_buttons[k] = button_name
	end

	-- set dynamics
	self.hud_data_dynamic = {}
	Screen_Data_Reset(self, enabled_status, true)

end

local function Screen_Data_Input(self, action_id, action)

	-- runs 'On Input' for Data screen on HUD

	-- early out if not allowed to use
	if not self.hud_data_dynamic.screen_isactive then
		return
	end

	local Hud_info = self.hud_data_constant

	-- sizer button
	local function func_button_sizer(button)

		-- handle all the button functionality

		local function func_shrink(self, subcontroller_node)
			gui.set_enabled(subcontroller_node, false)
		end

		local function func_expand(self, subcontroller_node)
			gui.set_enabled(subcontroller_node, true)
		end

		-- if is currently maximized then shrink
		-- if is not currently maximized then expand

		local is_now_maximized
		local subcontroller_node = gui.get_node(Hud_info.node_subcontroller)

		local frame_node = gui.get_node(Hud_info.node_frame_core)

		if self.hud_data_dynamic.is_maximized then
			-- run shrink and disable
			is_now_maximized = false
			gui.animate(frame_node, "size.y", gui.get_size(gui.get_node(Hud_info.node_min_length)).y, gui.EASING_INBACK, 0.4)
			gui.animate(subcontroller_node, "scale", MY_GOO.MINIMIZE, gui.EASING_INBACK, 0.35, 0, func_shrink)
		else
			-- run expand and enable
			is_now_maximized = true
			-- needs to be enabled to have size change, 
			-- but since default is large, will already be set small when disabled
			gui.set_enabled(subcontroller_node, true)
			gui.animate(frame_node, "size.y", gui.get_size(gui.get_node(Hud_info.node_max_length)).y, gui.EASING_OUTBACK, 0.4)
			gui.animate(subcontroller_node, "scale", MY_GOO.MAXIMIZE, gui.EASING_OUTBACK, 0.35, 0, func_expand)
		end

		-- update booleans
		self.hud_data_dynamic.goo_items_areactive = is_now_maximized
		self.hud_data_dynamic.is_maximized = is_now_maximized

		--print("Sizer was toggled. Is now maximized is "..tostring(is_now_maximized))

	end

	MY_GOO.checkbox_sizer(Hud_info.goo_minimizer, action_id, action, func_button_sizer)


	-- goto buttons
	local function func_goto_core(table_key)

		-- handle all functionality for the goto graph buttons

		-- if active then just overwrite 
		-- if not active then expand
		local needs_expanding = not self.hud_plot_dynamic.screen_isactive

		Screen_Plot_Reset(self, true, needs_expanding, table_key)

		--print("Goto button was pressed for "..table_key)

	end

	local function func_goto_ph(button)
		func_goto_core("item_ph")
	end
	local function func_goto_plankton(button)
		func_goto_core("item_plankton")
	end
	local function func_goto_coral(button)
		func_goto_core("item_coral")
	end
	local function func_goto_fish(button)
		func_goto_core("item_fish")
	end
	local function func_goto_mollusks(button)
		func_goto_core("item_mollusks")
	end
	local function func_goto_crustaceans(button)
		func_goto_core("item_crustaceans")
	end
	local function func_goto_humans(button)
		func_goto_core("item_humans")
	end

	if self.hud_data_dynamic.goo_items_areactive then
		local gotos = Hud_info.goo_group_goto_buttons
		local needs_clicked = self.items_that_need_clicked_list

		local button_helper = {
			item_ph = func_goto_ph,
			item_plankton = func_goto_plankton,
			item_coral = func_goto_coral,
			item_fish = func_goto_fish,
			item_mollusks = func_goto_mollusks,
			item_crustaceans = func_goto_crustaceans,
			item_humans = func_goto_humans
		}

		--goal is to look like this
		--if not self.items_that_need_clicked_list.item_ph.item_was_clicked then
			--MY_GOO.button_goto(gotos.item_ph, action_id, action, func_goto_ph)
		--end

		-- only allow clicking on goto if item was clicked/selected and updated 

		for k_itemname, v_func_goto in pairs(button_helper) do
			local button_available = true
			if needs_clicked ~= nil and needs_clicked[k_itemname] ~= nil then
				if not needs_clicked[k_itemname].item_was_clicked then
					button_available = false
				end
			end
			if button_available then
				MY_GOO.button_goto(gotos[k_itemname], action_id, action, v_func_goto)
			end
		end

	end

end


--HUD Process: Reset Player Data Table
local function PlayerData_Reset(self, update_hud_screens, back_to_begining)

	-- resets player data
	-- #TODO add save to file here

	self.player_data_tbl = nil

	self.player_data_tbl = {
		unique_id_key = 1111,
		save_version = CV_Current_Save_Version,
		character_role_key = "NAN",
		num_best_answers = 0,
		gameplay_loop_i_key = 0,
		special_setup_goals_hud_enabled = false,
		special_setup_data_hud_enabled = false,
		special_setup_item_boat_present = false,
		special_setup_item_buoy_present = false,
		item_data_tbl = {},
		item_hud_status = {}
	}

	PlayerData_Update_SumBestChoices(self, 0, true)

	-- go through item keys and initialize table and add first entry of fully healthy
	for k_itemname,_ in pairs(CV_item_groups) do
		self.player_data_tbl.item_data_tbl[k_itemname] = {}
		self.player_data_tbl.item_hud_status[k_itemname] = {}

		PlayerData_UpdateScoreTracker(self, k_itemname, 1.0)

		PlayerData_UpdateHUDTracker(self, k_itemname, false, false)

	end

	-- we do not need to add reset of graph and data bars to full here, b/c it's done elsewhere:
	-- the init function initializes the plot and data screens, 
	-- and each of this initialization functions run the reset function for each
	-- which runs the health bar reset to whatever the value in this health tracker table is
	-- plus hud screens may not have been initialized yet

	-- recall this function is only run when starting or repeating game
	-- also recall, that bar plots are updated and checked for each bar within player table each time bar plot is opened,
	-- which means that if player table entry is not there, since it was reset, then bar will be hidden 
	-- so no need to enable or disable bars since it already does it when opening bar plot
	if update_hud_screens then

		Screen_Data_Reset(self, false, back_to_begining)
		-- ^^ recall data rest internally calls Screen_Data_TrackerUpdate( function 

		-- not really sure how we could get to this point, since plot would have to be closed to click on restart
		-- but update here for failsafe anyway
		if self.hud_plot_dynamic.screen_isactive then
			Plot_Data_TrackerUpdate(self, self.hud_plot_dynamic.active_itemkey)
		end
	end

end


-- HUD Process: Observe Items (Section 2)
local function On_GO_Item_Click_Labeled(self, screen_pos, unique_tbl)

	-- play sound and label of what was clicked on regardless
	sound.play("sound_controller#sound_button_1", {delay = 0, gain = 0.5, pan = 0, speed = 1.0})
	local clicked_label_node = gui.get_node("gnode_clicked_label")

	local labels_i_list = {}
	local num_unique = 0
	for k_itemname,_ in pairs(unique_tbl) do
		num_unique = num_unique + 1
		labels_i_list[num_unique] = CV_item_groups[k_itemname].object_clicked_label
	end

	local label_txt = ""
	if num_unique == 1 then
		label_txt = labels_i_list[1]
	elseif num_unique == 2 then
		label_txt = labels_i_list[1] .. " & ".. labels_i_list[2]
	else
		label_txt = table.concat(labels_i_list, ", ", 1, num_unique-1)
		label_txt = label_txt .. " & " .. labels_i_list[num_unique]
	end

	gui.set_text(clicked_label_node, label_txt)
	gui.set_position(clicked_label_node, vmath.vector3(screen_pos.x, screen_pos.y, 0))

	gui.set_enabled(clicked_label_node, true)
	gui.set_scale(clicked_label_node, MY_GOO.MAXIMIZE)

	local function func_shrink(self, subcontroller_node)
		gui.set_enabled(subcontroller_node, false)
	end

	gui.animate(clicked_label_node, "scale", MY_GOO.MINIMIZE, gui.EASING_LINEAR, 0.5, 1, func_shrink)

end

local function On_GO_Item_Clicked_Requested(self, action_id, action)

	-- send request to get object items clicked on

	-- if data window is open do not register click if it was within the data bounds
	-- otherwise player may accidentally click on item if item is behind one of the buttons on the data screen
	if action_id == nil or action == nil then return end
	if action_id ~= HSH.control_touch then return end
	if not action.pressed then return end

	-- also check side bars, and return if we clicked in those
	local data_node_controller = gui.get_node(self.hud_data_constant.node_controller)
	local data_node_frame = gui.get_node(self.hud_data_constant.node_frame_core)

	local goals_node_controller = gui.get_node(self.hud_goals_constant.node_controller)
	local goals_node_frame = gui.get_node(self.hud_goals_constant.node_frame_core)

	if gui.is_enabled(data_node_controller, false) and gui.pick_node(data_node_frame, action.x, action.y) then
		--print("Clicked within data frame, not checking rest...\n")
		return
	--elseif gui.is_enabled(goals_node_controller, false) and gui.pick_node(goals_node_frame, action.x, action.y) then
		--print("Clicked within data frame, not checking rest...\n")
		-- no need to worry about goals since they only overlap the boat and just barely and goals as no buttons
		-- also better to allow clicking through goals so players don't get confused 
		--   as to why they cannot click the boat when it comes on-screen
		--return
	end

	-- if valid ocean click then check if for item selecting or just something simple like bubbles

	if On_GO_Items_Clicked_Basic_Valid(self) then
		msg.post("ocean_level:/level_controller", HSH.msg_request_go_clicked, {minfo_action = action})
	else
		msg.post("ocean_level:/level_controller", HSH.msg_request_make_bubbles, {minfo_action = action})
	end

end

local function On_GO_Item_Click_InputEnd(self, item_name, first_time_click)

	-- runs once successful click on go item(s)

	-- check if actually on list, if so get data and continue
	local item_click_info = self.items_that_need_clicked_list[item_name]

	if item_click_info == nil then return end

	-- run debrief display and item enabling if first click

	local debrief_text = item_click_info.show_debrief_text
	local run_debrief = debrief_text ~= nil and debrief_text ~= ""
	if first_time_click then

		-- check and run item data view enabling
		local enable_goto = item_click_info.enable_goto_in_data_hud_onclick
		local enable_item = item_click_info.enable_item_in_data_hud_onclick
		if enable_goto or enable_item then
			-- failsafe to enable data gauge if not enabled
			if not self.hud_data_dynamic.screen_isactive then
				Screen_Data_Reset(self, true)
			end

			ScreenData_ToggleItem(self, item_name, true, enable_item, enable_goto)
		end

		-- have these updaters here in case things need enabled

		-- update score tracker variables 
		Screen_Data_TrackerUpdate(self, item_name)

		-- set data hud color
		Items_Set_Color_Tracking(self, item_name, false)

		-- check and run debrief 
		if run_debrief then
			local run_sizing_debrief = true
			local update_values_to_debrief = true
			self.gameplay_loop_status = CV_gameplay_loop.status_running_debrief
			self.gameplay_loop_completion_type_secondary = STR.CV.goal_completed_types.class_new_information
			Screen_Popup_Reset(self, true, run_sizing_debrief, update_values_to_debrief, debrief_text)
		end

	end

	-- run pop-up display
	if not run_debrief and item_click_info.show_data_popup then
		-- update graph plot
		--print("Item clicked and opening graph for <"..item_name..">. \n ")
		Screen_Plot_Reset(self, true, true, item_name) --also runs plot update
	end

end

local function On_GO_Item_Clicked_Received(self, clicked_info)

	-- runs process when player clicks on go item(s)

	-- in form 
	-- match_id_tbl[k_item_name] = {selected_go_url = k_goid, selected_go_subitem = k_subitem_name}

	-- early exits
	if not On_GO_Items_Clicked_Basic_Valid(self) then return end

	if type(clicked_info) ~= "table" then return end

	if clicked_info.minfo_match_tbl == nil then return end
	if clicked_info.minfo_match_count == nil then return end
	if clicked_info.minfo_match_count <= 0 then return end

	-- get which groups we are checking clicks for
	local needs_clicked = self.items_that_need_clicked_list
	if self.items_that_need_clicked_sum == 0 then return end

	-- might have clicked on more then one item if they were overlapping so
	-- find first group that is on 'needs to be clicked' list but not on 'is clicked list'
	local valid_item_clicked
	local back_item_clicked
	local not_allowed_click
	local clicked_unique_tbl = {}
	for _,v_clicked_info in ipairs(clicked_info.minfo_match_tbl) do
		-- on 'needs clicked list'
		local item_name = v_clicked_info.selected_go_item
		local needs_clicked_item = needs_clicked[item_name]
		if needs_clicked_item ~= nil then
			-- checked if it has been clicked or not, 
			-- items not clicked take priority so the list can actually be completed

			if not needs_clicked_item.item_was_clicked then
				-- has not yet been clicked, so add it
				valid_item_clicked = item_name
				clicked_unique_tbl[item_name] = true

				needs_clicked_item.item_was_clicked = true

				if self.items_that_were_clicked_sum < self.items_that_need_clicked_sum then
					self.items_that_were_clicked_sum = self.items_that_were_clicked_sum + 1
				end

				break
			else
				-- has been clicked and is on list, but maybe player wants to view graph again
				if needs_clicked_item.allow_duplicate_clicks then
					back_item_clicked = item_name
					clicked_unique_tbl[item_name] = true
				else
					not_allowed_click = item_name
					clicked_unique_tbl[item_name] = true
				end
			end
		else
			--not on needs clicked list 
			not_allowed_click = item_name
			clicked_unique_tbl[item_name] = true
		end
	end

	-- if this was last on list then set variable that all are done
	if self.items_that_were_clicked_sum >= self.items_that_need_clicked_sum then
		self.items_all_clicked = true
		--print("All items that need to be clicked were clicked. \n")
	end

	-- finish process to click on and save data on items
	-- popup graph, which will also disable ocean script clicking
	-- also set color in data view for color and bar
	local final_item = valid_item_clicked or back_item_clicked or not_allowed_click
	if final_item ~= nil then
		local first_time_click
		if valid_item_clicked then
			first_time_click = true
		end
		On_GO_Item_Click_Labeled(self, clicked_info.minfo_screen_position, clicked_unique_tbl)
		On_GO_Item_Click_InputEnd(self, final_item, first_time_click)
	end

end


-- HUD Process: Screen Fader
local function Run_Fader(self, fade_out, time)

	-- run either fade in or fade out

	-- setup variables
	local fader_node = gui.get_node("gnode_screen_fader")
	local alpha, disable_at_end
	if fade_out then
		gui.set_enabled(fader_node, true)
		alpha = 1.0
		disable_at_end = false
	else
		alpha = 0.0
		disable_at_end = true
	end

	time = time or 2.0

	-- cancel any current fades
	gui.cancel_animation(fader_node, "color.w")

	-- declare callback for readability and thought of optimization
	local function func_set_status()
		if disable_at_end then
			gui.set_enabled(fader_node, false)
		end
	end

	-- run fader animation
	gui.animate(fader_node, "color.w", alpha, go.EASING_LINEAR, time, 0, func_set_status)

end


local function Close_All_Center_Screens(self)

	-- close any open screens in center window

	local run_sizing = false
	local enabled_status = false
	local reset_values = false

	-- popup/new info
	if self.hud_popup_dynamic.screen_isactive then
		Screen_Popup_Reset(self, enabled_status, run_sizing, reset_values)
	end

	-- decision
	if self.hud_decision_dynamic.screen_isactive then
		Screen_Decision_Reset(self, enabled_status, run_sizing, reset_values)
	end

	-- plot
	if self.hud_plot_dynamic.screen_isactive then
		Screen_Plot_Reset(self, enabled_status, run_sizing)
	end

	-- #TODO minimize data screen?

end


-- HUD Process: Game Loop
local function GameLogic_Progress(self, i_stage_addition)

	-- setups and runs next gameplay event

	if i_stage_addition == nil then
		i_stage_addition = 1
	end

	PlayerData_Update_I_Key_Progress(self, i_stage_addition)

	local stage_key, substage_key = Get_Current_Stage_and_Substage(self)

	if stage_key == nil or substage_key == nil then
		--print("TRK: Game loop is completed! \n")
		return
	end

	-- get and update goal text
	local goal_text = STR:Get_Goal_Text(stage_key, substage_key)
	local run_goal_sizing = not self.hud_goals_dynamic.screen_isactive
	if self.player_data_tbl.special_setup_goals_hud_enabled then
		Screen_Goals_Reset(self, true, run_goal_sizing, goal_text)
	end

	-- run other logic
	self.gameplay_loop_status = CV_gameplay_loop.status_running_main

	-- close any other plots or popups or decisions
	Close_All_Center_Screens(self)

	-- get type of event and start associated screens
	local stage_type = STR:Get_Completion_Type(stage_key, substage_key)
	local st = STR.CV.goal_completed_types
	self.gameplay_loop_completion_type_primary = stage_type
	self.gameplay_loop_completion_type_secondary = stage_type

	--print("  TRK: Running stage <"..stage_key.."> with substage <"..substage_key.."> with completion type <"..stage_type.."> \n")

	if stage_type == st.class_click_items then
		-- setup clicking on items
		On_GO_Items_Clicked_Reset(self, true)
		local items_to_click = STR:Get_Items_to_Click(stage_key, substage_key)
		Items_Click_Status_Reset(self, items_to_click)

		local popup_text_body = STR:Get_NewInfo_Text_Body(stage_key, substage_key)
		local run_sizer = true
		local reset_values = true
		Screen_Popup_Reset(self, true, run_sizer, reset_values, popup_text_body)

	elseif stage_type == st.class_decisison then
		-- setup decision
		local role_key = self.player_data_tbl.character_role_key
		local q_text = STR:Get_Decision_Text_Question(stage_key, substage_key, role_key)
		local a_tbl = STR:Get_Decision_Text_Options(stage_key, substage_key, role_key)
		local hint_text = STR:Get_Decision_Text_Hint(stage_key, substage_key, role_key)
		local reset_values = true
		Screen_Decision_Reset(self, true, true, reset_values, #a_tbl, q_text, a_tbl, hint_text)

	elseif stage_type == st.class_new_information then
		-- setup new information
		local popup_text_body = STR:Get_NewInfo_Text_Body(stage_key, substage_key)
		local run_sizer = true
		local reset_values = true
		Screen_Popup_Reset(self, true, run_sizer, reset_values, popup_text_body)

	end

end


-- HUD Screen: Main Menu (Section 1)
local function Screen_MainMenu_Reset(self, enabled_setting, run_sizing)

	-- reset Main Menu screen of HUD

	-- default args
	if enabled_setting == nil then
		enabled_setting = false
	end

	-- set enabled status
	local constant = self.hud_mainmenu_constant
	local controller_node = gui.get_node(constant.node_controller)

	-- reset tracking table
	self.hud_mainmenu_dynamic.screen_isactive = enabled_setting

	SimpleToggleHelper(self, controller_node, enabled_setting, run_sizing)

end

local function Screen_MainMenu_Initialize(self, enabled_status)

	-- set constants and setup dynamic values and components

	local basename = "hud_startmenu"

	self.hud_mainmenu_constant = nil
	self.hud_mainmenu_dynamic = nil

	-- set constants
	self.hud_mainmenu_constant = {
		hud_basename = basename,
		node_controller = basename .. "/gnode_controller",
		goo_game_new_name = basename .. "/group_button_game_new",
		goo_game_resume_name = basename .. "/group_button_game_resume",
	}

	-- set dynamics
	self.hud_mainmenu_dynamic = {}
	Screen_MainMenu_Reset(self, enabled_status, true)

end

local function Screen_MainMenu_Input(self, action_id, action)

	-- runs 'On Input' for Main Menu screen on HUD

	-- early out if not allowed to use
	if not self.hud_mainmenu_dynamic.screen_isactive then
		return
	end

	local hudinfo = self.hud_mainmenu_constant

	local function func_new_game(button)

		-- handle all the button functionality

		-- set that this screen is no longer interactive
		local run_sizer = false
		Screen_MainMenu_Reset(self, false, run_sizer)

		GameLogic_Progress(self, 1)

		--print("New game started!")

	end

	local function func_resume_game(button)

		-- handle all the button functionality

		-- set that this screen is no longer interactive
		local run_sizer = false
		Screen_MainMenu_Reset(self, false, run_sizer)

		--#TODO add functionality
		--print("Game resumed!")

	end

	MY_GOO.button_simple(hudinfo.goo_game_new_name, action_id, action, func_new_game)

	--#TODO add resume game functionality
	--MY_GOO.button_simple(hudinfo.goo_game_resume_name, action_id, action, func_resume_game)

end


-- HUD Process: More Gameplay
local function GamePauseToggle_Internal(self)

	-- pause by setting game update factor to 0
	self.game_paused = not self.game_paused

	local factor
	if self.game_paused then
		factor = 0
	else
		factor = 1
	end

	msg.post("level_loader#collectionproxy", HSH.msg_builtin_set_timestep, {factor = factor, mode = 1})
	msg.post("ocean_level:/level_controller#script", HSH.msg_pause_game_msg_sent, {minfo_game_paused = self.game_paused})

end

local function GamePause_On(self)

	-- if game should be paused but is not paused, then pause it
	if not self.game_paused then
		GamePauseToggle_Internal(self)
	end

end

local function GamePause_Off(self)

	-- if game should be resumed but is paused, then resume it
	if self.game_paused then
		GamePauseToggle_Internal(self)
	end

end

local function GamePauseToggle_Input(self, action_id, action)

	--#TODO remove when done testing
	if action_id == HSH.control_down and action.released then
		GamePauseToggle_Internal(self)
	end

end

local function OceanScene_ChangeWeather(self, is_raining, wave_direction, run_coastal_oa_when_done)

	msg.post("ocean_level:/level_controller", HSH.msg_request_change_weather, {minfo_is_raining=is_raining, minfo_wave_direction=wave_direction, minfo_run_coastal_oa_too = run_coastal_oa_when_done})

end

local function OceanScene_RunCoastalOA(self, percent_coastal_oa_to_hide)

	msg.post("ocean_level:/level_controller", HSH.msg_request_run_coastal_oa, {minfo_percent_coastal_oa_hide = percent_coastal_oa_to_hide})

end

local function On_SpecialAction(self, special_action_name)

	if special_action_name == "special_setup_first_boat" or special_action_name == "special_setup_pH_buoy" then
		msg.post("ocean_level:/level_controller#script", HSH.msg_request_special_case_action, {minfo_special_case_key = special_action_name})
		if special_action_name == "special_setup_first_boat" then
			PlayerData_Set_Special(self, "special_setup_item_boat_present", true)
		elseif special_action_name == "special_setup_pH_buoy" then
			PlayerData_Set_Special(self, "special_setup_item_buoy_present", true)
		end
	elseif special_action_name == "special_setup_coastal_oa_1" then
		local is_raining = true
		local run_coastal_oa_when_done = true
		OceanScene_ChangeWeather(self, is_raining, INFO:Get_BaseWave_Direction(), run_coastal_oa_when_done)
		--start but then pause the game 
		timer.delay(5, false, GamePause_On)
	elseif special_action_name == "special_setup_start_goals_gauge" then
		-- function 'On Game Progress' checks this value then loads goals if it is on
		PlayerData_Set_Special(self, "special_setup_goals_hud_enabled", true)
	end

end

local function GameHandleButtonInput(self, action_id, action)

	--#TODO remove when done testing

	if not action.released then return end

	--change weather
	if action_id == HSH.control_right or action_id == HSH.control_left then
		local is_supposed_to_rain = action_id == HSH.control_right
		local wave_direction = 1
		OceanScene_ChangeWeather(self, is_supposed_to_rain, wave_direction)
	end

	--trigger nutrient influx
	if action_id == HSH.control_up then
		OceanScene_RunCoastalOA(self, 0)
	end

end

local function Game_RunRestart(self, reset_ply_data)

	-- reset save table
	if reset_ply_data then
		local update_hud_screens, back_to_begining
		if self.gameplay_initialized then
			update_hud_screens = true
			back_to_begining = true
		end
		PlayerData_Reset(self, update_hud_screens, back_to_begining)
	end

	PlayerData_Set_Character(self)
	local set_enabled = false
	On_GO_Items_Clicked_Reset(self, set_enabled)

	-- reset click items tracker
	Items_Click_Status_Reset(self)

	self.input_is_possible = true

	self.gameplay_loop_completion_type_primary = 0
	self.gameplay_loop_completion_type_secondary = 0
	self.final_debrief_shown = false

	-- get stage and substage list in order
	self.gameplay_loop_status = CV_gameplay_loop.status_unknown

	-- if game has already been initialized, that means this function was called as part of a game restart
	-- so close any menus that were open 

	-- go to starting stage
	PlayerData_Update_I_Key_Progress(self, 0, true)

	if self.gameplay_initialized then
		-- popup and others should have already been closed by 
		-- internal choice button logic that got us to this point
		Screen_Goals_Reset(self, set_enabled)

		-- Recall, 'Game logic progress' function runs after selecting 'Start Game' option in starting menu
		-- Which will occur if player is starting new game 
		-- so only run it here if game already initialized (ie repeating game)
		-- set this to 0 b/c if running repeat as part of debrief screen, 
		-- then debrief logic will kick in and auto update game progress after this function call
		GameLogic_Progress(self, 0)

		-- also if running game restart here then reset animals and buoy
		Run_Fader(self, true, 0.25)
		-- wait until fully dark/hidden, then reset, then fade back in
		timer.delay(0.35, false, function(self)
			msg.post("ocean_level:/level_controller#script", HSH.msg_request_special_case_action, {minfo_special_case_key = "special_restart_game"})
			--^ above takes 0.25 seconds at least so wait a bit 
			timer.delay(0.45, false, function(self)
				Run_Fader(self, false, 0.25)
			end)
		end)
	end

end

local function Game_First_Initialization(self)

	-- randomize random generator
	math.randomseed(socket.gettime())

	MY_GOO.acquire_input()

	msg.post("level_loader#collectionproxy", HSH.msg_builtin_load)
	GamePause_Off(self)

	local enabled_setting = false

	Initialize_Local_Info_Tbl()
	-- do not update HUD screens since they are not initialized yet, 
	-- need to initialize player table first though so HUD screen initialization works
	PlayerData_Reset(self)

	Screen_Goals_Initialize(self, enabled_setting)
	Screen_Decision_Initialize(self, enabled_setting)
	Screen_Popup_Initialize(self, enabled_setting)
	Screen_Data_Initialize(self, enabled_setting)
	Screen_Plot_Initialize(self, enabled_setting)

	self.num_player_affected_questions = STR:Get_Total_Choices()
	self.gameplay_loop_order = STR:GameOrder_CreateTable()

	Game_RunRestart(self)

	self.gameplay_initialized = true

	-- kick off first action 
	Screen_MainMenu_Initialize(self, true)

end


function init(self)

	Game_First_Initialization(self)

end

function on_message(self, message_id, message, sender)

	if message_id == HSH.msg_builtin_proxy_loaded then
		msg.post(sender, HSH.msg_builtin_enable)
	end

	if message_id == HSH.msg_request_fade_out or message_id == HSH.msg_request_fade_in then
		Run_Fader(self, message_id == HSH.msg_request_fade_out, message.minfo_fade_duration)
	elseif message_id == HSH.msg_report_go_clicked then
		On_GO_Item_Clicked_Received(self, message)
	elseif message_id == HSH.msg_request_game_progress then
		GameLogic_Progress(self, 1)
	elseif message_id == HSH.msg_request_game_repeat then
		Game_RunRestart(self, message.minfo_reset_player_save)
	elseif message_id == HSH.msg_set_player_character_role then
		PlayerData_Set_Character(self, message.minfo_role_name)
	elseif message_id == HSH.msg_update_item_value then
		PlayerData_RunScoreInput(self, message.minfo_item_score_update_tbl, message.minfo_overrides_instead_of_inserts, message.minfo_was_best_choice)
	elseif message_id == HSH.msg_request_special_case_action then
		On_SpecialAction(self, message.minfo_special_case_key)
	end

end

function on_input(self, action_id, action)

	if not self.input_is_possible then return end

	Screen_MainMenu_Input(self, action_id, action)

	Screen_Decision_Input(self, action_id, action)
	Screen_Data_Input(self, action_id, action)
	Screen_Plot_Input(self, action_id, action)
	Screen_Popup_Input(self, action_id, action)
	On_GO_Item_Clicked_Requested(self, action_id, action)

	GameHandleButtonInput(self, action_id, action)
	GamePauseToggle_Input(self, action_id, action)

end
