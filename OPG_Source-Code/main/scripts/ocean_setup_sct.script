-- OVERVIEW:
-- setups and controls the ocean visuals

-- dependencies
local CAM = require ("orthographic.camera")
local RES = require ("modules.screen_res_md")
local HSH = require ("modules.hashes_md")
local EXT = require ("modules.extend_md")
local INFO = require("modules.item_info_md")

-- properties
go.property("Obj_Percent_Coastal_OA_to_Hide", 0)

-- locals 
local CV_Update_Property = {
	method_overwrite = 0,
	method_multiply = 1,
	method_add = 2,
}

local CV_Weather_Reload_Time = 0.25
local CV_Animal_Reset_Time = 0.25
local CV_Total_Coastal_OA_Time = 30

-- functions

local function SetBins_X(t, disable_x_correction)

	-- get equal length bins given some options
	-- also corrects for center of screen being 0 by default

	-- get input and set default values
	local num_bins = t.num_bins or 1
	local yrange_table_unscaled = t.yrange_table_unscaled or {0 ,0}
	local scaling_y = t.scaling_y or RES.Scaling_Y
	local screen_width = t.screen_width or RES.Internal_X
	local use_center_bins = t.use_center_bins --default false
	local sort_y = t.sort_y --default false
	local z_base = t.z_base or 0
	local num_extra_bins_left_right_tbl = t.num_extra_bins_left_right_tbl or {1,1}
	local use_random_x = t.use_random_x --default false

	-- setup usage variables
	local bin_width = screen_width/num_bins
	local y_range = {math.floor(yrange_table_unscaled[1] * scaling_y), math.floor(yrange_table_unscaled[2] * scaling_y)}
	local bins = {}

	-- correction of x 0 as center of screen instead of far left
	local x_correction
	if disable_x_correction then
		x_correction = 0
	else
		x_correction = -(screen_width/2)
	end

	-- add extra bins on each side if specified 
	-- (ie increase number and x range)
	if num_extra_bins_left_right_tbl ~= nil then
		for i_side,v_num_bins in ipairs(num_extra_bins_left_right_tbl) do
			if v_num_bins > 0 then
				screen_width = screen_width + bin_width*v_num_bins
				num_bins = num_bins + v_num_bins
				--only have to add to x correction for bins on left side offscreen
				if i_side == 1 then
					x_correction = x_correction - ((bin_width/2)*v_num_bins)
				end
			end
		end
	end

	-- check and save if not using center bins
	local no_bins
	if not use_center_bins then
		local half_bins = num_bins / 2
		if (num_bins % 2 == 0) then
			--even
			no_bins = {half_bins, half_bins+1}
		else
			--odd
			local mid = num_bins - math.floor(half_bins)
			no_bins = {mid, mid}
		end
	end

	-- work through bins and choose and set positions
	local bins_j = 1
	for i=1,num_bins do
		local bin_center_x = (bin_width/2) + (bin_width)*(i-1)
		--plus or minus some random amount from bin center
		local x = bin_center_x + x_correction
		if use_random_x then
			local x_offset_range = math.floor(bin_width * 0.3)
			x = x + math.random(-x_offset_range, x_offset_range)
		end
		local y = math.random(y_range[1], y_range[2])
		-- add this bin to list 
		if ( use_center_bins ) or ( not use_center_bins and no_bins ~= nil and ( (i < no_bins[1]) or (i > no_bins[1]) ) ) then
			bins[bins_j] = {x, y, z_base}
			bins_j = bins_j + 1
		end
	end

	-- depth Y sort if specified
	if sort_y then
		-- sort with largest y first (ie highest up)
		local function compareY(a, b)
			return a[2] > b[2]
		end
		table.sort(bins, compareY)
		-- as we move down list add to z, cap at 1
		local current_z = z_base
		for i_bin,_ in ipairs(bins) do
			local new_z = current_z + ( 0.001 * (i_bin - 1) )
			if new_z > 1 then
				new_z = 1
			end
			bins[i_bin][3] = new_z
		end
	end

	return bins

end

local function Get_Z_from_Y(pos_y, scale_z)

	-- given a y value return a z value
	local abs_y = pos_y + RES.Correction_Y
	-- get percent height: 1 is top/most behind and 0 is bottom/most in front
	-- so subtract out z, from top down (cannot add to z since highest in front is 0)
	local percent_y = abs_y/RES.Screen_Y

	scale_z = scale_z or 1
	local final_z = -(percent_y * scale_z)

	return final_z

end

local function Get_Scale_from_Y(pos_y, yrange_table_unscaled, scaling_y, new_y_range)

	-- set depth y-scaling

	-- the smallest scales should correspond with the highest y (small things high up in background)
	-- smaller high up seems to look good...
		--recall positions are ordered from:
			--first: highest y/most in background
			--last: lowest y/most in foreground
	-- so get percentage of how high object is in y-range and scale within scaling bounds
	-- then randomize size a tiny bit

	local range_diff = (yrange_table_unscaled[2] - yrange_table_unscaled[1]) * scaling_y
	local percent_height = (pos_y - (yrange_table_unscaled[1] * scaling_y)) / range_diff -- AKA x in y m*x+b
	local m = ((new_y_range[2] - new_y_range[1]) * percent_height)

	-- y = m*x + b
	-- scale = m * percent_height + b
	return ( m * percent_height  + new_y_range[1]) * ((math.random(90, 110)/100) ) -- and some minor variation

end

local function GetGridPoints(range_tbl, cellsize_tbl, required_num, rand_offset_factors, use_center, y_stack_base, print_results)

    -- given an area and cell size, return a set of grid points

    -- setup variables
    if use_center == nil then
        use_center = true
    end

	required_num = required_num or 1
	y_stack_base = y_stack_base or 0.1

    local x_min = range_tbl.x[1]
    local x_max = range_tbl.x[2]
    local y_min = range_tbl.y[1]
    local y_max = range_tbl.y[2]

    local cell_width = cellsize_tbl.x
    local cell_height = cellsize_tbl.y
    local z_base = cellsize_tbl.z or 0

    -- validity checking
    if x_min > x_max or y_min > y_max then
        print("Error, values for grid are incongruent. X min, max "..x_min..", "..x_max..", Y min, max"..y_min..", "..y_max.."\n")
        return nil
    end

    if cell_width <= 0 or cell_height <= 0 then
        print("Error, values for cell are incongruent. Cell width, height are "..cell_width..", "..cell_height.."\n")
        return nil
    end

    -- setup ranges
    local x_range = math.abs(x_max - x_min)
    local y_range = math.abs(y_max - y_min)

    -- get max number of whole cells with these x and y ranges
    local number_cells_in_x_axis = math.floor(x_range/cell_width)
    local number_cells_in_y_axis = math.floor(y_range/cell_height)
    local total_number_cells = number_cells_in_x_axis * number_cells_in_y_axis

    -- make sure there are some cells to continue
    if total_number_cells <= 0 then
        print("Error, no grid cells are possible, number of cells for x, y are "..number_cells_in_x_axis..", "..number_cells_in_y_axis.."\n")
        return nil
    end

	-- check if this setup reaches the required number
	if required_num > total_number_cells then
		-- add cells in x direction until reach number
		local num_per_addition = number_cells_in_y_axis
		local extra_needed_cells = required_num - total_number_cells
		local extra_columns = 1
		if extra_needed_cells > num_per_addition then
			extra_columns = math.ceil(extra_needed_cells/num_per_addition)
		end
		-- add these values and recalculate
		number_cells_in_x_axis = number_cells_in_x_axis + extra_columns
		total_number_cells = number_cells_in_x_axis * number_cells_in_y_axis
	end

	if print_results then
		print("Grid contains "..total_number_cells.." cells with dimensions: "..number_cells_in_x_axis..","..number_cells_in_y_axis.."\n")
	end

    -- setup grid variables
    local cells_tbl = {}
    local center_cell_x, center_cell_y = 0, 0
    if use_center then
        center_cell_x = cell_width/2
        center_cell_y = cell_height/2
    end

	-- setup random offset if specified
	local rand_x, rand_y, use_random_offset
	if rand_offset_factors ~= nil and rand_offset_factors.x ~= nil and rand_offset_factors.y ~= nil then
        use_random_offset = true
		rand_x = math.floor(cell_width * rand_offset_factors.x)
		rand_y = math.floor(cell_height * rand_offset_factors.y)
    end


    -- run grid setting
    local num_cells = 0

    for num_row = 1, number_cells_in_y_axis do
        for num_column = 1, number_cells_in_x_axis do

			if num_cells < required_num then
				-- get base x and y
				local x = x_min + center_cell_x + (cell_width)*(num_column-1)
				local y = y_min + center_cell_y + (cell_height)*(num_row-1)

				-- add random offset if specified
				if use_random_offset then
					x = x + math.random(-rand_x, rand_x)
					y = y + math.random(-rand_y, rand_y)
				end

				-- save to table
				num_cells = num_cells + 1
				--remove z fighting + some global z based on height (somewhat in-case different groups overlap)
				local z = z_base + (num_cells*0.001) + Get_Z_from_Y(y, y_stack_base)
				cells_tbl[num_cells] = {x = x, y = y, z = z, i_index = num_cells}
				if print_results then
					print("x: "..x..",   y: "..y..",   z: "..z.."\n")
				end
			else
				break
			end

        end
    end

	return cells_tbl

end

local function GetDynamicGrid_IEntry(self, spawn_list_key, i_index)

	local dyn_grid = self.dynamic_grids[spawn_list_key]
	if dyn_grid == nil then
		print("Error: function 'Get Dynamic Grid' supplied with invalid spawn list key <"..tostring(spawn_list_key)..">")
		return {x=0, y=0, z=0}
	else
		return dyn_grid[i_index]
	end

end

local function Set_Sea_Particles(self, toggle_on, clear_instant)

	-- toggle sea dust on or off

	if toggle_on then
		-- tell bubbler to start, and it is only ever triggered once
		if not self.bubble_retimer_started then

			self.bubble_retimer_started = true

			msg.post("spawner_bubbles", "msg_request_make_bubbles")

			local function func_start_bubbler(self)
				if self.weather_changeable and math.random(0, 1) == 1 then
					msg.post("spawner_bubbles", "msg_request_make_bubbles")
				end
			end

			timer.delay(6, true, func_start_bubbler)
		end
		-- sea dust particle effect is set to loop already in the effect file
		particlefx.play("spawner_sea_dust#particlefx")
	else
		-- does not seem like there is an easy way to fade out tint of particles 
		-- tint can be set with `particlefx.set_constant` but that is instant
		particlefx.stop("spawner_bubbles#particlefx", { clear = clear_instant })
		particlefx.stop("spawner_sea_dust#particlefx", { clear = clear_instant })
	end

end

local function Spawned_RemoveObject(self, spawn_list_key, go_id, delete_go, ignore_stop_before_death, instant_stop_before_death)

	-- delete go object
	if delete_go then
		if go.exists(go_id) then
			--print("Deleting individual object "..go_id.."\n")
			go.delete(go_id)
		end
	else
		-- if not deleting then send expire message
		-- which will delete the go, just after a specified event
		-- for example, do not delete go until animation done
		-- but remove from tracker list
		-- so we can add more swimmers without incorrectly hitting max amount
		-- ignore stop allows translation to continue as death occurs
		-- instant stop stops instantly before death, otherwise comes to gradual stop then dies
		msg.post(go_id, HSH.msg_order_expire_start, {minfo_ignore_stop_before_death=ignore_stop_before_death, minfo_instant_stop_before_death=instant_stop_before_death})
	end

	-- remove from list if it was on list
	if self.spawned_objects_list[spawn_list_key] == nil then return end
	if self.spawned_objects_list[spawn_list_key][go_id] == nil then return end

	-- remove from list and update list sum
	self.spawned_objects_list[spawn_list_key][go_id] = nil
	self.spawned_objects_sum[spawn_list_key] = self.spawned_objects_sum[spawn_list_key] - 1

end

local function Spawned_ResetAll(self, spawn_list_key, delete_gos)

	-- reset all spawned objects from given list key

	-- if there have been objects spawned then delete and clear them all
	local key_list = self.spawned_objects_list[spawn_list_key]
	if key_list ~= nil then
		if self.spawned_objects_sum[spawn_list_key] > 0 then
			for k_gourl, _ in pairs(key_list) do
				if delete_gos then
					go.delete(k_gourl)
				else
					local delete_go = false
					local ignore_stop = false
					local instant_stop = true
					Spawned_RemoveObject(self, spawn_list_key, k_gourl, delete_go, ignore_stop, instant_stop)
				end
			end
		end
	end

	-- reset tracker variables
	self.spawned_objects_list[spawn_list_key] = nil
	self.spawned_objects_list[spawn_list_key] = {}
	self.spawned_objects_sum[spawn_list_key] = 0

	-- if running this function as part of a subgroup weather
	-- then recall clouds have internal script function that stops particle effects on death
	-- also recall that we do not have to disable
	-- particle effects on gos in the water such as bubbler and ocean duster, 
	-- since those are in the water and not affected by weather
	-- also, so far, things like the bubbler, sea dust, and sun and not in spawn list
	-- because they are always present in set amounts and easy to disable or change 

end

local function Spawned_AddObject(self, spawn_list_key, go_id)

	-- add spawned object to list key tracker tables

	local current_count = self.spawned_objects_sum[spawn_list_key]

	if current_count == nil then
		print("Note: Add Spawned Object provided with non-initalized spawn type key "..spawn_list_key..", initializing now...\n")
		Spawned_ResetAll(self, spawn_list_key, true)
		current_count = 0
	end

	local new_sum = current_count + 1
	self.spawned_objects_sum[spawn_list_key] = new_sum

	if self.spawned_objects_list[spawn_list_key] == nil then
		print("Error, spawn key list of "..tostring(spawn_list_key).." is nil, but this should not be possible! \n")
		return
	end

	if self.spawned_objects_list[spawn_list_key][go_id] ~= nil then
		print("Error, spawn game object id is already present! Overriding old value. \n")
	end

	--print("Add object "..tostring(go_id).." to spawn list key "..spawn_list_key.."\n")
	self.spawned_objects_list[spawn_list_key][go_id] = true

end


local function Spawned_UpdateProperty(self, spawn_list_key, list_prop_tbls) --{ {prop_name, prop_value, prop_method, prop_custom} }

	-- update a property of a given spawned game object

	-- validity checks
	local list = self.spawned_objects_list[spawn_list_key]

	if list == nil then
		print("Warning: Update property of spawned object provided with invalid key "..spawn_list_key.."...\n")
		return 
	end

	local method_multiply = CV_Update_Property.method_multiply
	local method_add = CV_Update_Property.method_add

	local function update_prop(obj_id, update_info)

		-- setup variables
		local new_val
		local obj_url 

		local is_custom_property = update_info.prop_custom
		local method = update_info.prop_method
		local property_to_update = update_info.prop_name
		local prop_val = update_info.prop_value

		-- if the property is custom then it has to be sent to script component
		if is_custom_property then
			obj_url = msg.url(nil, obj_id, "script")
		else
			obj_url = obj_id
		end
		-- get new value using method type
		if method == method_multiply then
			-- multiply
			new_val = go.get(obj_url, property_to_update) * prop_val
		elseif method == method_add then
			-- add
			new_val = go.get(obj_url, property_to_update) + prop_val
		else 
			-- overwrite
			new_val = prop_val
		end

		-- update the value
		go.set(obj_url, property_to_update, new_val)

	end

	-- work through all objects in this list and update that property 
	for _, v_id in ipairs(list) do

		for _,prop_info in ipairs(list_prop_tbls) do
			update_prop(v_id, prop_info)
		end

	end

end

local function Spawn_WaterLines(self, wave_direction, is_raining)

	-- add in the main water line

	local scaling_y = RES.Scaling_Y
	local screen_width = RES.Internal_X

	local s_item = INFO.item_info.item_weather
	local sgroup = s_item.subitem_info.subitem_waterlines

	local tint
	if is_raining then
		tint = {0.75, 0.75, 0.75}
	else
		tint = {1, 1, 1}
	end

	local side_bins
	if wave_direction > 0 then 
		side_bins = {1, 0}
	elseif wave_direction < 0 then
		side_bins = {0, 1}
	else
		side_bins = {1, 1}
	end

	local bin_t = {
		num_bins = 1,
		yrange_table_unscaled = sgroup.spawn_y_range,
		scaling_y = scaling_y,
		screen_width = screen_width,
		use_center_bins = true,
		sort_y = false,
		z_base = sgroup.spawn_z_base,
		num_extra_bins_left_right_tbl = side_bins,
		use_random_x = false
	}

	local bins = SetBins_X(bin_t)

	local movex_time = 30
	if wave_direction == 0 then
		-- if swaying there is a shorter distance so time tuning is trickier
		movex_time = math.floor(movex_time * 1.6) -- when using sway it was 0.7
		wave_direction = self.no_wind_default
		-- also main wave not moving in same direction as clouds is strange
		-- so either clouds do not move with wind direction 0, or we track what direction 0 actually is
	end

	local collfact_name = sgroup.spawn_coll_factory
	local spawn_listkey = sgroup.spawn_list_key

	for _,v_bin in ipairs(bins) do
		local pos = vmath.vector3(v_bin[1], v_bin[2], v_bin[3])
		local rot = nil

		local props = {
			[HSH.STR_go] = {
				Obj_Item_Enum = s_item.item_enum,
				Obj_Subitem_Enum = sgroup.subitem_enum,
				Obj_Wave_Movment_X_Buffer = false,
				Obj_Wave_Movment_X_Direction = wave_direction,
				Obj_Wave_Movment_X_Time = movex_time,
				Obj_Wave_Movment_X_Multiplier = 0.2, -- only valid if x direction == 0
				Obj_OG_Tint_R = tint[1],
				Obj_OG_Tint_G = tint[2],
				Obj_OG_Tint_B = tint[3]
			}
		}

		local new_collection = collectionfactory.create(collfact_name, pos, rot, props)
		Spawned_AddObject(self, spawn_listkey, new_collection[HSH.STR_go])
	end

end

local function Spawn_Clouds(self, wave_direction, is_raining)

	-- add in and arrange all clouds

	local scaling_y = RES.Scaling_Y
	local screen_width = RES.Internal_X

	local s_item = INFO.item_info.item_weather
	local sgroup = s_item.subitem_info.subitem_clouds

	local tint
	if is_raining then
		tint = {0.75, 0.75, 0.75}
	else
		tint = {1, 1, 1}
	end

	-- if sunny, then do not use middle one so sun can keep shining for now
	-- sorted by y-height, higher y is lower z/more in background
	local y_range = sgroup.spawn_y_range

	local y_override, z_override, scale_override
	local num_bins, sort_y, center_bins, bins_tbl
	if is_raining then
		y_override = (y_range[1]+60)*scaling_y
		z_override = sgroup.spawn_z_base
		num_bins = 8
		sort_y = false
		center_bins = true
		scale_override = 1.5 -- too large and it gets fuzzy
		bins_tbl = {1,1}
	else
		num_bins = 5
		sort_y = true
		center_bins = false
		bins_tbl = {0,0}
	end

	local bin_t = {
		num_bins = num_bins,
		yrange_table_unscaled = y_range,
		scaling_y = scaling_y,
		screen_width = screen_width,
		use_center_bins = center_bins,
		sort_y = sort_y,
		z_base = sgroup.spawn_z_base,
		num_extra_bins_left_right_tbl = bins_tbl,
		use_random_x = true
	}

	local bins = SetBins_X(bin_t)

	-- clouds either move in wave direction with wind, or choose a random direction
	local sign
	local mtime = 130
	if wave_direction > 0 then
		sign = 1
	elseif wave_direction < 0 then
		sign = -1
	else
		-- move slower if no large wind
		mtime = mtime * 1.7
		sign = self.no_wind_default
	end

	local collfact_name = sgroup.spawn_coll_factory
	local spawn_listkey = sgroup.spawn_list_key

	for _,v_bin in ipairs(bins) do
		local y = y_override or v_bin[2]
		local z = z_override or v_bin[3]
		local pos = vmath.vector3(v_bin[1], y, z)
		local rot = nil

		-- 0.0 -> 1.5 and 1.0 -> 0.5 
		local scale = scale_override or Get_Scale_from_Y(pos.y, y_range, scaling_y, {1.5, 0.5})

		-- smaller clouds appear to be in background, so they should move slower
		-- inverse the scale, so smaller scale is larger/slower travel time
		local movetime = mtime / scale
		if wave_direction == 0 then
			movetime = movetime * 1.6
		end

		local props = {
			[HSH.STR_go] = {
				Obj_Item_Enum = s_item.item_enum,
				Obj_Subitem_Enum = sgroup.subitem_enum,
				Obj_Selected_Sprite_Option = math.random(1, 3),
				Obj_Wave_Movment_X_Buffer = true,
				Obj_Wave_Movment_X_Direction = sign,
				Obj_Wave_Movment_X_Time = movetime,
				Obj_Wave_Movment_X_Multiplier = 2.0*sign, -- only valid if x direction == 0
				Obj_Wave_Sprite_FlipH = math.random(0,1) == 1,
				Obj_OG_Tint_R = tint[1],
				Obj_OG_Tint_G = tint[2],
				Obj_OG_Tint_B = tint[3],
				Obj_PlayParticleFX = is_raining
			}
		}

		local new_collection = collectionfactory.create(collfact_name, pos, rot, props, scale)
		Spawned_AddObject(self, spawn_listkey, new_collection[HSH.STR_go])

		if is_raining then
			-- spawn some new clouds with bit of random x, higher y, lower z
			local new_pos = {
				v_bin[1] * (math.random(80, 120)/100),
				y + (scaling_y * math.random(40, 60)),
				z - 0.01
			}

			-- these new clouds do not rain though
			props[HSH.STR_go].Obj_PlayParticleFX = false

			local extra_collection = collectionfactory.create(collfact_name, vmath.vector3(new_pos[1], new_pos[2], new_pos[3]), rot, props, scale)
			Spawned_AddObject(self, spawn_listkey, extra_collection[HSH.STR_go])
		end

	end

end

local function Spawn_Waves(self, wave_direction, is_raining)

	-- add in and arrange the surface waves

	local scaling_y = RES.Scaling_Y
	local screen_width = RES.Internal_X

	local s_item = INFO.item_info.item_weather
	local sgroup = s_item.subitem_info.subitem_waves

	local tint
	if is_raining then
		tint = {0.75, 0.75, 0.75}
	else
		tint = {1, 1, 1}
	end

	local y_range = sgroup.spawn_y_range
	local waves_t = {
		num_bins = 7,
		yrange_table_unscaled = y_range,
		scaling_y = scaling_y,
		screen_width = screen_width,
		use_center_bins = true,
		sort_y = true,
		z_base = sgroup.spawn_z_base,
		num_extra_bins_left_right_tbl = {1,1},
		use_random_x = true
	}

	local bins = SetBins_X(waves_t)

	local base_time_x = 30

	local collfact_name = sgroup.spawn_coll_factory
	local spawn_listkey = sgroup.spawn_list_key

	for _,v_bin in ipairs(bins) do
		local pos = vmath.vector3(v_bin[1], v_bin[2], v_bin[3])
		local rot = nil
		local fliph
		-- use uneven wave if there is a wave direction
		local move_time, move_x_multi

		-- 0.0 -> 1.1 and 1.0 -> 0.8 
		local scale = Get_Scale_from_Y(pos.y, y_range, scaling_y, {1.1, 0.8})

		local y_scale
		if wave_direction == 0 then
			-- bit of random time and offset of just swaying
			move_time = math.floor((math.random(85, 115)/100) * base_time_x)
			move_x_multi = math.random(70, 90)/100
			y_scale = 0.75
		else
			move_time = math.floor(base_time_x * 1.3)
			move_x_multi = 1
			y_scale = 0.70
		end

		local selected_sprite_i
		if wave_direction ~= 0 then
			selected_sprite_i = 2 -- uneven is sprite2
			fliph = wave_direction < 0
		else
			selected_sprite_i = 1
			fliph = math.random(0, 1) == 1
		end

		local props = {
			[HSH.STR_go] = {
				Obj_Item_Enum = s_item.item_enum,
				Obj_Subitem_Enum = sgroup.subitem_enum,
				Obj_Selected_Sprite_Option = selected_sprite_i,
				Obj_Wave_Movment_X_Buffer = true,
				Obj_Wave_Movment_X_Time = move_time,
				Obj_Wave_Movment_X_Direction = wave_direction,
				Obj_Wave_Movment_X_Multiplier = move_x_multi, -- only valid if x direction == 0
				Obj_Wave_Movment_Y_Use = true,
				Obj_Wave_Movment_Y_Time = 2.5,
				Obj_Wave_Movment_Y_Scale = y_scale,
				Obj_Wave_Sprite_FlipH = fliph,
				Obj_OG_Tint_R = tint[1],
				Obj_OG_Tint_G = tint[2],
				Obj_OG_Tint_B = tint[3]
			}
		}

		local new_collection = collectionfactory.create(collfact_name, pos, rot, props, scale)
		Spawned_AddObject(self, spawn_listkey, new_collection[HSH.STR_go])

	end

end

local function SetPlanktonViewer(self, toggle_option, is_instant)

	-- toggle the plankton viewer

	if self.plankton_viewer_enabled == toggle_option then return end

	self.plankton_viewer_enabled = toggle_option

	if toggle_option then
		-- if enabling
		local final_z = -1
		local final_scale = 0.05
		if is_instant then
			go.set("background_water_bottom_full_pane_hider", "position.z", final_z)
			go.set("background_water_bottom_full_pane_hider", "scale", final_scale)
		else
			go.animate("background_water_bottom_full_pane_hider", "scale", go.PLAYBACK_ONCE_FORWARD, final_scale, go.EASING_LINEAR, 0.23, 0)
			go.animate("background_water_bottom_full_pane_hider", "position.z", go.PLAYBACK_ONCE_FORWARD, final_z, go.EASING_LINEAR, 0, 0.23)
		end

	else
		-- if disabling
		local final_z = -0.8
		local final_scale = 1
		if is_instant then
			go.set("background_water_bottom_full_pane_hider", "position.z", final_z)
			go.set("background_water_bottom_full_pane_hider", "scale", final_scale)
		else
			go.animate("background_water_bottom_full_pane_hider", "scale", go.PLAYBACK_ONCE_FORWARD, final_scale, go.EASING_LINEAR, 0.25, 0)
			go.animate("background_water_bottom_full_pane_hider", "position.z", go.PLAYBACK_ONCE_FORWARD, final_z, go.EASING_LINEAR, 0, 0.1)
		end

	end

end

local function Run_Temporary_RainyClouds(self, start_offscreen)

	-- function to spawn temporary clouds that pass over with rain
	--   keep separate from coastal OA since that also can be called during permanent weather
	--   ?also has clouds that hit sun and add timed ocean water color and sky fade?

	-- bit of a hack since it does not use proper spawning tracking
	--   also does not use info saved in info module

	-- early out to disable or enable for testing
	if true then return end

	local x, duration
	if start_offscreen or true then
		x = -2000
		duration = 42
	else
		x = 0
		duration = 18
	end
	local y = 340
	local z = 0.1
	local scale = 1.3

	local new_collection = collectionfactory.create("spawner_weather_front#collectionfactory", vmath.vector3(x, y, z), nil, nil, scale)

	local function func_kill(self, url)
		go.delete(url)
	end

	local id = new_collection[HSH.STR_go]
	go.animate(id, "position.x", go.PLAYBACK_ONCE_FORWARD, 2500, go.EASING_LINEAR, duration, 0, func_kill)
	particlefx.play(msg.url(nil, id, "particlefx"))

end

local function Run_CoastalOA(self, update_percentage_to_hide, show_highlighter) -- percent ranges from 0.0 to 1.0

	-- plays particle effect for coastal acidification
	-- make sure weather going from left to right when OACoast is running
	-- to reduce amount shown just move spawner game object more off to the left
	-- full throttle coastal OA effect is when game object of "spawner_coastOA" is at x pos of -800

	if update_percentage_to_hide ~= nil then
		self.Obj_Percent_Coastal_OA_to_Hide = update_percentage_to_hide
	else
		update_percentage_to_hide = self.Obj_Percent_Coastal_OA_to_Hide
	end

	if self.coastal_oa_playing then
		print("Notice: Run Coastal OA function called while currently running, requested run will not occur...")
		return
	else
		print("Starting Coastal Acidification effect \n")
	end

	-- default args
	-- includes amount of effect to hide/show, 1 is fully hidden, 0 is show everything
	if type(update_percentage_to_hide) ~= "number" then
		update_percentage_to_hide = 0
	end

	-- if hiding entire effect then return early, otherwise clamp
	if update_percentage_to_hide >= 1 then
		return
	end
	update_percentage_to_hide = EXT:math_clamp(update_percentage_to_hide, 0, 1)

	-- play particle effect suite and save status
	self.coastal_oa_playing = true
	SetPlanktonViewer(self, false)

	-- move spawner object to starting position based on amount of effect to show
	local runoff_emitter_length = 800
	local runoff_offset = 100
	local amount_to_hide = runoff_emitter_length * update_percentage_to_hide
	local start_x = RES.Boundary_X[1] - (runoff_emitter_length/2) - amount_to_hide + runoff_offset
	local end_x = start_x + runoff_emitter_length
	local duration = 10
	local delay = 1.0 --gives time for runoff to spawn and to say something if needed

	-- set some variables
	local anim_duration = CV_Total_Coastal_OA_Time

	local spawner_id = "spawner_coastOA"
	local highlighter_sprite = "spawner_coastOA#highlighter_sprite"

	-- set positions and start movement
	go.set(spawner_id, "position.x", start_x)
	go.animate(spawner_id, "position.x", go.PLAYBACK_ONCE_FORWARD, end_x, go.EASING_OUTSINE, duration, delay)

	-- deal with highlighter
	-- note, we use a separate, non GUI highlighter, 
	--   since it can parent and move with coastal OA spawner
	--   and since coastal OA spawner has different starting positions based on amount to show
	if show_highlighter then
		msg.post(highlighter_sprite, "enable")

		-- animation style copied from gui highlighter
		go.set(highlighter_sprite, "tint", INFO.common_info.color_red_full)
		go.animate(highlighter_sprite, "tint", go.PLAYBACK_LOOP_PINGPONG, INFO.common_info.color_red_flicker, gui.EASING_LINEAR, 1.5, 0)

		-- fine to have large rectangle whole time, as it shows where to look in upcoming seconds
		-- plus moving and scaling highlighter might distract from watching algae and decomposition

		-- remove highlighter as decomposition is getting thin
		local function func_disable_highlighter(self)
			go.cancel_animations(highlighter_sprite)
			msg.post(highlighter_sprite, "disable")
		end

		timer.delay(anim_duration-5, false, func_disable_highlighter)
	else
		msg.post(highlighter_sprite, "disable")
	end

	-- play effect while moving object
	particlefx.play("spawner_coastOA#particlefx")

	-- wait until particle effects are done before being able to do again
	local function func_set_oa(self)
		self.coastal_oa_playing = false
		SetPlanktonViewer(self, true)
	end

	timer.delay(anim_duration, false, func_set_oa)

end

local function SetStatic_Weather(self, is_raining)

	-- set the visuals for static sprites specific to the weather
	-- does not spawn anything, changes tint and simply starts particle fx
	-- so can be called repeatedly without having to worry about spawning objects first

	-- setup 
	local vmath1 = vmath.vector4(1.0, 1.0, 1.0, 1.0)
	local tint_sky, tint_watertop, tint_waterbottom
	local str_set
	if is_raining then
		-- also darken sky a bit and hide sun and light
		-- disable sprites of light and also shadow collisions
		str_set = "disable"
		tint_sky = vmath.vector4(0.50, 0.50, 0.50, 1)
		tint_watertop = vmath.vector4(0.75, 0.75, 0.75, 1)
		tint_waterbottom = vmath.vector4(0.80, 0.80, 0.80, 1)
	else
		str_set = "enable"
	end

	-- run
	go.set("background_sky_ocean#sprite", "tint", tint_sky or vmath1)
	go.set("background_water_top#sprite", "tint", tint_watertop or vmath1)

	go.set("background_water_bottom_full_window#sprite", "tint", tint_waterbottom or vmath1)
	go.set("background_water_bottom_full_pane_base#sprite", "tint", tint_waterbottom or vmath1)
	go.set("background_water_bottom_full_pane_hider#sprite", "tint", tint_waterbottom or vmath1)

	go.set("background_water_bottom_lower#sprite", "tint", tint_waterbottom or vmath1)
	go.set("background_water_bottom_upper#sprite", "tint", tint_waterbottom or vmath1)

	msg.post("background_sun#sprite", str_set)
	msg.post("background_water_light_rays_bottom#sprite", str_set)
	msg.post("background_water_light_rays_top#sprite", str_set)
	msg.post("background_water_light_collision#shade_inner", str_set)
	msg.post("background_water_light_collision#shade_middle", str_set)
	msg.post("background_water_light_collision#shade_outer", str_set)

	msg.post("background_water_light_collision", "msg_request_reset_shadows")

end

local function Setup_Weather(self, at_scene_start, is_supposed_to_rain, wave_direction)

	-- setup all aspects involved with the weather 

	-- note, weather is setup all at once and has objects reused
	--   this is b/c knowing what all objects are at once allows script 
	--   to arrange them in a nice looking way, whereas if objects created at intervals
	--   then it might be more random and not look as nice

	-- setup default args
	if is_supposed_to_rain == nil then
		is_supposed_to_rain = false
	end
	if type(wave_direction) ~= "number" then
		wave_direction = INFO:Get_BaseWave_Direction()
	end

	-- clear anything that was around previously
	-- note, cannot delete objects then spawn more in same frame, 
	-- as that overrides buffer and makes other bugs
	for _, v_groupkey in pairs(INFO.item_info.item_weather.subitem_info) do
		Spawned_ResetAll(self, v_groupkey.spawn_list_key, true)
	end

	local function loader_helper(self)
		-- setup the ocean water and lights, does not spawn
		SetStatic_Weather(self, is_supposed_to_rain)

		-- spawn the water lines
		Spawn_WaterLines(self, wave_direction, is_supposed_to_rain)

		-- spawn some clouds
		Spawn_Clouds(self, wave_direction, is_supposed_to_rain)

		-- spawn some waves, sorted by y-height, 
		-- higher y is lower z/more in background
		Spawn_Waves(self, wave_direction, is_supposed_to_rain)

		-- sparkle light rays? works, 
		-- but shows artifacts with the transparency
		-- plus will not always have light rays

		-- start spawning some bubbles and sea dust
		if at_scene_start then
			Set_Sea_Particles(self, true)
		end

		-- set what the weather variable is, also
		-- stop any raining sound then play if needed sound

		-- if it is supposed to rain (is_supposed_to_rain == true)
			-- if already raining (self.weather_is_raining == true)
				-- no need to change sound
			-- if not raining (self.weather_is_raining == false)
				-- play sound
		-- if it is supposed to not rain (is_supposed_to_rain == false)
			-- if already raining (self.weather_is_raining == true)
				-- stop sound
			-- if not raining (self.weather_is_raining == false)
				-- no need to change sound
		if is_supposed_to_rain then
			if not self.weather_is_raining then

				self.weather_is_raining = true

				sound.play("sound_controller#sound_rain", {delay = 0, gain = 0.01, pan = 0, speed = 1.0})
				go.animate("sound_controller#sound_rain", "gain", go.PLAYBACK_ONCE_FORWARD, 0.3, go.EASING_LINEAR, 0.25)

			end
		else
			if self.weather_is_raining then

				local function func_stop_sound(self)
					sound.stop("sound_controller#sound_rain")
					self.weather_is_raining = false
				end

				go.animate("sound_controller#sound_rain", "gain", go.PLAYBACK_ONCE_FORWARD, 0.01, go.EASING_LINEAR, 0.25, 0, func_stop_sound)
			end
		end

	end

	-- if at scene start then load right away
	-- otherwise give time for unloading
	if at_scene_start then
		loader_helper(self)
	else
		timer.delay(self.weather_reload_time, false, loader_helper)
	end

end

local function Weather_Change(self, is_supposed_to_rain, wave_direction, run_coastal_oa_at_end)

	-- change the weather to raining or sunny

	-- do not change weather if currently doing a weather change
	if not self.weather_changeable then
		print("Notice: Change Weather function called while weather was undergoing change, proposed change will not occur...")
		return
	end

	-- if it is raining and we want it to rain then do nothing
	-- if it is not raining and we do not want it to rain then do nothing
	if (is_supposed_to_rain and self.weather_is_raining) or (not is_supposed_to_rain and not self.weather_is_raining) then
		return
	end

	-- switch weather
	self.weather_changeable = false

	-- fade out, then run Setup Scene with weather arguments
	-- recall particles are above GO sprites, so use GUI fader
	local fader_time = 0.75
	msg.post("main:/hud#gui", HSH.msg_request_fade_out, {minfo_fade_duration = fader_time})

	-- once fadeout done and fully black and hiding view, then update scene
	timer.delay(fader_time + 0.25 , false, function(self)

		-- run weather setup again
		-- recall the overall setup clears out anything that was spawned, 
		-- then spawns in new stuff a few moments later
		Setup_Weather(self, false, is_supposed_to_rain, wave_direction)

		-- fade back in, wait enough time for setup scene to clear and reload
		timer.delay(self.weather_reload_time*2, false, function(self)

			-- fade back in
			msg.post("main:/hud#gui", HSH.msg_request_fade_in, {minfo_fade_duration = fader_time})

			-- once fully visible again allow weather to be changed again
			timer.delay(1.0, false, function(self)
				self.weather_changeable = true
				if run_coastal_oa_at_end then
					Run_CoastalOA(self)
				end
			end)
		end)

	end)

end

local function Spawn_Animal_Static(self, item_name, subitem_name, i_position_in_grid, health_val)

	-- spawn a static individual
	local s_item = INFO.item_info[item_name]
	local subitem_tbl = s_item.subitem_info[subitem_name]

	-- setup
	local spawn_list_key_name = subitem_tbl.spawn_list_key
	local collfact_name = subitem_tbl.spawn_coll_factory
	--local obj_dimensions = subitem_tbl.object_dimensions
	local pos_tbl = GetDynamicGrid_IEntry(self, spawn_list_key_name, i_position_in_grid)

	local flip_h = pos_tbl.flip_sprite
	local sprite_selection = pos_tbl.sprite_selection_i
	local rot = vmath.quat_rotation_z(math.rad(pos_tbl.rotation_z_euler))

	local rand_base = (math.random(90,100)/100)
	local scale = subitem_tbl.object_scale_base * rand_base

	-- compile into properties table
	local spanwn_pos = vmath.vector3(pos_tbl.x, pos_tbl.y, pos_tbl.z)

	local props = {
		[HSH.STR_go] = {
			Obj_Item_Enum = s_item.item_enum,
			Obj_Subitem_Enum = subitem_tbl.subitem_enum,
			Obj_Wave_Sprite_FlipH = flip_h,
			Obj_Selected_Sprite_Option = sprite_selection,
			Obj_Current_Health = health_val or 1.0
		}
	}

	-- create collection with GO
	local new_collection = collectionfactory.create(collfact_name, spanwn_pos, rot, props, scale)

	-- add GO to tracker
	Spawned_AddObject(self, spawn_list_key_name, new_collection[HSH.STR_go])

end

local function Animal_Order_GoTo(self, go_id, swimto_x, swimto_y, on_init, stop_is_instant)

	-- default is to go to waypoint 2
	-- and to not be on_init

	-- early out if invalid
	if not go.exists(go_id) then
		return
	end

	local go_url = msg.url(nil, go_id, "script")
	local start_swimming_info = {
		minfo_swim_to_x = swimto_x or go.get(go_url, "Obj_Waypoint_2_X"),
		minfo_swim_to_y = swimto_y or go.get(go_url, "Obj_Waypoint_2_Y"),
		minfo_stop_is_instant = stop_is_instant,
		minfo_is_on_init = on_init --used for instant face to waypoint
	}

	-- send message to start 'swim to' with these coordinates
	msg.post(go_id, HSH.msg_order_swim_to_pos, start_swimming_info)

end

local function Spawn_Animal_Swimmer(self, item_name, subitem_name, i_position_in_grid, spawn_offscreen, is_spawn_flipped, go_autopatrol)

	-- spawn an individual swimmer
	local s_item = INFO.item_info[item_name]
	local subitem_tbl = s_item.subitem_info[subitem_name]

	-- default arguments
	if spawn_offscreen == nil then
		spawn_offscreen = false
	end

	-- setup
	local spawn_list_key_name = subitem_tbl.spawn_list_key
	local collfact_name = subitem_tbl.spawn_coll_factory
	local obj_dimensions = subitem_tbl.object_dimensions
	local obj_scale_base = subitem_tbl.object_scale_base
	local obj_rot_speed_base = subitem_tbl.object_rotation_speed_base
	local obj_translate_speed_base = subitem_tbl.object_translation_speed_base
	if subitem_tbl.object_translation_speed_can_vary then
		obj_translate_speed_base = obj_translate_speed_base * (math.random(60,120)/100)
	end
	local pos_tbl = GetDynamicGrid_IEntry(self, spawn_list_key_name, i_position_in_grid)
	local anim_multi = subitem_tbl.object_anim_multi or {rate_moving = 1, rate_idle = 0.5, rate_float = 1.0, rate_extra = 0.5}
	local anim_multi_moving = anim_multi.rate_moving or 1
	local anim_multi_idle = anim_multi.rate_idle or 0.02
	local anim_multi_float = anim_multi.rate_float or 0.5
	local anim_multi_extra = anim_multi.rate_extra or 0.5
	anim_multi_moving = anim_multi_moving * (math.random(80,110)/100)
	anim_multi_float = anim_multi_float * (math.random(80,110)/100)
	anim_multi_extra = anim_multi_extra * (math.random(80,110)/100)

	local easing_opts = subitem_tbl.movement_easing_options or {move_go = 1, move_stop = 2}
	local easing_move_go = easing_opts.move_go or 1
	local easing_move_stop = easing_opts.move_stop or 2

	local extra_death_type = subitem_tbl.extra_death_effect or -1

	-- prepare properties
	-- smaller blurrier ones be in back? size range represents age, not really distance from camera..
	-- but would still visually make more sense to save slightly blurrier/smaller fish be slightly in background?
	-- could also say they are too much in the foreground and that's why they are blurry, too...
	local rand_base = (math.random(75,100)/100)
	local scale = obj_scale_base * rand_base
	local slowdown_distance = scale * obj_dimensions.x * 1.5 --1.5 fish lengths to slowdown

	-- set patrol location along x-axis somewhere to start fish movement
	-- want half the x dimension plus a bit more so when flipping we don't see rotation?
	--   so far rotation is fine to view, 
	--   if it turns out not to be then just use subtract instead of add here
	local waypoint1_pos_x = pos_tbl.x
	local waypoint1_pos_y = pos_tbl.y
	local waypoint2_pos_x = waypoint1_pos_x + (-RES.Internal_X/1.5)
	local waypoint2_pos_y = waypoint1_pos_y

	--possibly flip ?
	if is_spawn_flipped then
		waypoint1_pos_x, waypoint2_pos_x = waypoint2_pos_x, waypoint1_pos_x
		waypoint1_pos_y, waypoint2_pos_y = waypoint2_pos_y, waypoint1_pos_y
	end

	-- set spawn position, possibly offscreen
	local spanwn_pos = vmath.vector3(waypoint1_pos_x, waypoint1_pos_y, pos_tbl.z)
	if spawn_offscreen then
		-- deal with new swimmers joining school in random position
		--   find way to deal with swimming in from offscreen to join current direction of school, 
		--   or stop all school at wp1
		--   also find way to get offscreen swimmer caught up with school but then slowed down
		--   actually it's easiest to just reset everyone at wp1 and do not order to move
		-- also find closest waypoint to offscreen
		local distance_to_offscreen_left = math.abs(waypoint1_pos_x - RES.Boundary_X[1])
		local distance_to_offscreen_right = math.abs(waypoint1_pos_x - RES.Boundary_X[2])
		if distance_to_offscreen_left < distance_to_offscreen_right then
			--wp 1 is closer to left side
			spanwn_pos.x = RES.Boundary_X[1] - slowdown_distance
		else
			--wp 1 is closer to right side
			spanwn_pos.x = RES.Boundary_X[2] + slowdown_distance
		end
	end
	local rot

	-- for the pixel based arguments using the scale value, too
	-- though it may seem we want to keep movements equal so that fish stay together
	-- if speeds get high or low, over time swimmer will fall behind or be too far ahead
	-- custom easing though allows for internal variation in this speed while keeping overall duration
	local move_speed_multi = 1

	-- compile into properties table
	local props = {
		[HSH.STR_go] = {
			Obj_Item_Enum = s_item.item_enum,
			Obj_Subitem_Enum = subitem_tbl.subitem_enum,
			Obj_Translation_Speed_Max = move_speed_multi * obj_translate_speed_base,
			Obj_Rotation_Speed_Max = move_speed_multi * obj_rot_speed_base,
			Obj_On_Force_Stop_Slowdown_Distance = slowdown_distance,
			Obj_On_Done_Loop_Waypoints = true,
			-- give some minor variation in flip time in case they all flip at once
			Obj_Flip_Time = 0.6 * rand_base * 2, -- recall flip time incorporates random delay then actual flip time
			Obj_Formation_Position_Index = i_position_in_grid,
			Obj_Waypoint_1_X = waypoint1_pos_x,
			Obj_Waypoint_1_Y = waypoint1_pos_y,
			Obj_Waypoint_2_X = waypoint2_pos_x,
			Obj_Waypoint_2_Y = waypoint2_pos_y,
			Obj_Extra_Death_Effect_Type = extra_death_type,
			Obj_Anim_Multi_Moving = anim_multi_moving,
			Obj_Anim_Multi_Idle = anim_multi_idle,
			Obj_Anim_Multi_Float = anim_multi_float,
			Obj_Anim_Multi_Extra = anim_multi_extra,
			Obj_TranslationGo_Easing_Options = easing_move_go,
			Obj_TranslationStop_Easing_Options = easing_move_stop
		}
	}

	-- create collection with GO
	local new_collection = collectionfactory.create(collfact_name, spanwn_pos, rot, props, scale)

	-- add GO to tracker
	Spawned_AddObject(self, spawn_list_key_name, new_collection[HSH.STR_go])

	-- start swimming, go to waypoint 1 if spawned offscreen, otherwise go to waypoint 2
	local swimto_x, swimto_y

	if spawn_offscreen then
		swimto_x = waypoint1_pos_x
		swimto_y = waypoint1_pos_y
	else
		swimto_x = waypoint2_pos_x
		swimto_y = waypoint2_pos_y
	end

	if spawn_offscreen or go_autopatrol then
		local on_init = true
		local instant_stop = true
		Animal_Order_GoTo(self, new_collection[HSH.STR_go], swimto_x, swimto_y, on_init, instant_stop)
	end

end

local function Spawn_Animal_Micro(self, item_name, subitem_name, i_position_in_grid, spawn_offscreen, health_val)

	-- spawn an individual plankton
	local s_item = INFO.item_info[item_name]
	local subitem_tbl = s_item.subitem_info[subitem_name]

	-- default arguments
	if spawn_offscreen == nil then
		spawn_offscreen = false
	end

	-- setup
	local spawn_list_key_name = subitem_tbl.spawn_list_key
	local collfact_name = subitem_tbl.spawn_coll_factory
	local obj_scale_base = subitem_tbl.object_scale_base
	local obj_rot_speed_base = subitem_tbl.object_rotation_speed_base
	local obj_translate_speed_base = subitem_tbl.object_translation_speed_base
	local pos_tbl =  GetDynamicGrid_IEntry(self, spawn_list_key_name, i_position_in_grid)

	local rand_base = (math.random(75,100)/100)
	local scale = obj_scale_base * rand_base

	--print("x, y, z = ".. pos_tbl.x..", ".. pos_tbl.y..",".. pos_tbl.z.."\n")
	local spanwn_pos = vmath.vector3(pos_tbl.x, pos_tbl.y, pos_tbl.z)
	local rot

	-- compile into properties table
	local props = {
		[HSH.STR_go] = {
			Obj_Item_Enum = s_item.item_enum,
			Obj_Subitem_Enum = subitem_tbl.subitem_enum,
			Obj_Translation_Speed_Max = obj_translate_speed_base,
			Obj_Rotation_Speed_Max = obj_rot_speed_base,
			Obj_Formation_Position_Index = i_position_in_grid,
			Obj_BaseGrid_Y_Height = subitem_tbl.object_dimensions.y,
			Obj_BaseGrid_Y_Coordinate = pos_tbl.y,
			Obj_Current_Health = health_val or 1.0
		}
	}

	-- create collection with GO
	local new_collection = collectionfactory.create(collfact_name, spanwn_pos, rot, props, scale)

	-- add GO to tracker
	Spawned_AddObject(self, spawn_list_key_name, new_collection[HSH.STR_go])

end

local function Setup_Animal(self, item_name, subitem_name, new_health, skip_reset, spawn_offscreen, go_auto_patrol)

	local s_item = INFO.item_info[item_name]
	local subitem_tbl = s_item.subitem_info[subitem_name]

	-- get count to spawn
	-- update number if health variable
	local health_val = new_health or 1.0
	local max_number_to_spawn = subitem_tbl.spawn_max_count

	-- only continue if spawn count > 0
	if max_number_to_spawn == nil then
		return
	end
	if max_number_to_spawn <= 0 then
		return
	end

	if not skip_reset then
		Spawned_ResetAll(self, subitem_tbl.spawn_list_key, true)
	end

	local flip_h = self.dynamic_spawn_sides[subitem_tbl.spawn_list_key]
	local logic_typ = subitem_tbl.object_logic_type

	if INFO:Logic_is_Swimmer(logic_typ) then

		--spawn in swimmers
		local num_swimmers = math.max(1, math.ceil(health_val*max_number_to_spawn))
		for i=1,num_swimmers do
			Spawn_Animal_Swimmer(self, item_name, subitem_name, i, spawn_offscreen, flip_h, go_auto_patrol)
		end

	elseif INFO:Logic_is_Static(logic_typ) then

		--spawn in, recall dynamic grid takes care of sprite flipping and setting
		for i=1,max_number_to_spawn do
			Spawn_Animal_Static(self, item_name, subitem_name, i, health_val)
		end

	elseif INFO:Logic_is_Micro(logic_typ) then

		--spawn plankton
		for i=1,max_number_to_spawn do
			Spawn_Animal_Micro(self, item_name, subitem_name, i, false, health_val)
		end

	end

end

local function Setup_AllAnimals(self)

	-- spawn in all the animals 

	-- run compiled spawning
	for k_item, v_item in pairs(INFO.item_info) do

		if INFO:Logic_is_Alive(k_item) then

			local skip_reset = false
			local spawn_offscreen = false
			local go_autopatrol = true
			for k_subitem, _ in pairs(v_item.subitem_info) do
				Setup_Animal(self, k_item, k_subitem, 1, skip_reset, spawn_offscreen, go_autopatrol)
			end

		end

	end

end

local function Spawn_Boat(self, boat_type_name)

	-- defaults
	boat_type_name = boat_type_name or "subitem_captain"
	local s_item = INFO.item_info.item_humans
	local subitem_tbl = s_item.subitem_info[boat_type_name]

	if subitem_tbl == nil then
		print("Error boat_type_name of <"..tostring(boat_type_name).."> does not exist! \n")
		return
	end

	-- create collection with GO, and spawn off-screen
	local scale = 1
	local rot = nil
	local props = {
		[HSH.STR_go] = {
			Obj_Item_Enum = s_item.item_enum,
			Obj_Subitem_Enum = subitem_tbl.subitem_enum,
			Obj_Translation_Speed_Max = 100,
			Obj_Dimension_X = subitem_tbl.object_dimensions.x
		}
	}

	local collfact_name = subitem_tbl.spawn_coll_factory
	local x = subitem_tbl.spawn_x_min
	local y = EXT:Random_fromTable(subitem_tbl.spawn_y_range)
	local z = subitem_tbl.spawn_z_base
	local spanwn_pos = vmath.vector3(x,y,z)
	local new_collection = collectionfactory.create(collfact_name, spanwn_pos, rot, props, scale)

	-- add GO to tracker
	Spawned_AddObject(self, subitem_tbl.spawn_list_key, new_collection[HSH.STR_go])

	-- call boat move
	local msg_info = {minfo_swim_to_x = RES.Center_X}

	msg.post(new_collection[HSH.STR_go], HSH.msg_order_swim_to_pos, msg_info)

end

local function Boat_Change_Character(self, boat_subitem_name)

	-- clear all current boats with expire message
	for _,v_subiteminfo in pairs(INFO.item_info.item_humans.subitem_info) do
		Spawned_ResetAll(self, v_subiteminfo.spawn_list_key, false)
	end

	-- request new boat 
	-- use subitem name instead of role so 
	-- we do not need to require STR to use role to subitem converter
	Spawn_Boat(self, boat_subitem_name)

end

local function SetupBuoy(self, hide_buoy)

	-- starts looping buoy movement and adds to tracker table as way to measure pH

	local buoy_list_key = INFO.item_info.item_ph.subitem_info.subitem_buoy.spawn_list_key

	if hide_buoy then
		local hide_rot = 35
		go.cancel_animations("/ph_buoy/go_rope")
		go.cancel_animations("/ph_buoy/go_body")
		go.set("/ph_buoy/go_rope", "euler.z", hide_rot)
		Spawned_ResetAll(self, buoy_list_key, true)
	else
		Spawned_AddObject(self, buoy_list_key, "/ph_buoy/go_clickme")
		-- reposition to proper spot then float back and forth
		local og_rot = 0
		local setup_time = 3
		local float_loop_start = setup_time + 0.2
		go.animate("/ph_buoy/go_rope", "euler.z", go.PLAYBACK_ONCE_FORWARD, og_rot, go.EASING_OUTSINE, setup_time)
		go.animate("/ph_buoy/go_rope", "euler.z", go.PLAYBACK_LOOP_PINGPONG, -1, go.EASING_INOUTQUAD, 3, float_loop_start)
		go.animate("/ph_buoy/go_body", "euler.z", go.PLAYBACK_LOOP_PINGPONG, -3, go.EASING_INOUTSINE, 3, float_loop_start)
	end

end

local function Make_Bubbles(self, x_pos)

	-- trigger some bubbles at given x position

	-- initialize if empty 
	if 	self.bubbles_playable == nil then
		self.bubbles_playable = true
	end

	-- exit early if not able to do
	if not self.bubbles_playable then return end

	-- set scale and status
	self.bubbles_playable = false
	local scale = math.random(75, 115)/100
	go.set_scale(scale, "spawner_bubbles")

	-- set x position, default is random
	local x_bounds = RES.Boundary_X
	local x = x_pos or math.random(x_bounds[1], x_bounds[2])
	go.set("spawner_bubbles", "position.x", x)

	-- play bubbles
	particlefx.play("spawner_bubbles#particlefx")

	-- play sound
	sound.play("sound_controller#sound_bubbles", {delay = 0, gain = 0.5, pan = 0, speed = 1.0})

	-- declare callback for readability and thought of optimization
	local function func_reset_playable(self)
		self.bubbles_playable = true
	end

	-- wait duration of bubble time them allow to play again 
	timer.delay(3.0, false, func_reset_playable)

end

local function Get_Item_Clicked_On(self, screen_pos)

	-- sends message for item that was clicked on, or nil/"" if no item was clicked

	local world_pos = CAM.screen_to_world(nil, vmath.vector3(screen_pos.x, screen_pos.y, 0))

	-- go through all items of spawn key lists
	-- get position of each and compare distance to this click position
	-- if overlap found break and return that item

	local match_id_tbl = {}
	local match_item_key = {}
	local match_sum = 0

	local function add_to_tbl(item_name, go_id, subitem_name)

		-- only add it to take if the z value is higher or if distance is shorter
		-- fine to just track all of them, not that expensive...?

		local this_z_val = go.get_position(go_id).z
		local prev_z_val = match_item_key[item_name] or -99
		if this_z_val <= prev_z_val then
			return
		else
			match_item_key[item_name] = this_z_val
		end

		-- add to table
		match_sum = match_sum + 1

		local pos = go.get_position(go_id)
		match_id_tbl[match_sum] = {
			selected_go_url = go_id,
			selected_go_item = item_name,
			selected_go_subitem = subitem_name,
			selected_go_click_proximity = -pos.z
		}
		--print("  Clicked on item "..item_name)

	end

	local function in_bounding_box(click_pos, go_id, go_base_dimensions)

		local pos = go.get_position(go_id)
		local scale = go.get_scale(go_id)
		--recall scale can be -1 when object gets flipped
		local x_range = (math.abs(scale.x) * go_base_dimensions.x)/2
		local y_range = (math.abs(scale.y) * go_base_dimensions.y)/2

		local bb_x_min = pos.x - x_range
		local bb_x_max = pos.x + x_range
		local bb_y_min = pos.y - y_range
		local bb_y_max = pos.y + y_range

		return (click_pos.x >= bb_x_min and click_pos.x <= bb_x_max) and (click_pos.y >= bb_y_min and click_pos.y <= bb_y_max)

	end

	--print("Starting match check")

	for k_item_name, v_item_info in pairs(INFO.item_info) do
		--for each subitem in item
		local subitem_info = v_item_info.subitem_info or {}
		for k_subitem_name, v_subitem_info in pairs(subitem_info) do
			local object_dimensions = v_subitem_info.object_dimensions
			--only continue if this has object dimensions, which means we can click on it
			--and if we have not clicked on it yet?
			--  which is fine is using only z depth for picking, since subitems generally have same z?
			--  except coral though, which has large bounding box limits..
			if object_dimensions ~= nil then

				-- go through list and get position and scale and check distance
				local spawn_tbl = self.spawned_objects_list[v_subitem_info.spawn_list_key]

				--first check if can just do whole bounding box check 
				local bb = v_subitem_info.use_click_by_bounding_box
				if bb ~= nil then
					if (world_pos.x >= bb.x[1] and world_pos.x <= bb.x[2]) and (world_pos.y >= bb.y[1] and world_pos.y <= bb.y[2]) then
						add_to_tbl(k_item_name, nil, k_subitem_name)
					end
				elseif spawn_tbl ~= nil then
					local subitems_clicked = false
					for k_goid, _ in pairs(spawn_tbl) do
						if not subitems_clicked and in_bounding_box(world_pos, k_goid, object_dimensions) then
							subitems_clicked = true
							add_to_tbl(k_item_name, k_goid, k_subitem_name)
						end
					end
				end

			end
		end
	end

	--send message to gui saying we clicked this
	if match_sum > 0 then
		--print("  Match sum is "..match_sum)
		--for k,_ in pairs(match_id_tbl) do print("  "..k) end
		--sort match table ID by distance then by z
		--first in list is closest with highest z

		--sort with smallest distance last (largest first)
		local function sort_click_proximity(a, b)
			return a.selected_go_click_proximity > b.selected_go_click_proximity
		end

		table.sort(match_id_tbl, sort_click_proximity)

		msg.post("main:/hud#gui", HSH.msg_report_go_clicked, {minfo_screen_position = screen_pos, minfo_match_tbl = match_id_tbl, minfo_match_count = match_sum})
	--else
		--print("No items found to click on!\n")
	end

	--return match_id_tbl

end

local function OnPauseToggle_SoundHelper(self, game_pause_toggle)

	-- pauses all sounds since they do not seem to pause when dt is 0

	sound.pause("sound_controller#sound_bubbles", game_pause_toggle)
	sound.pause("sound_controller#sound_rain", game_pause_toggle)
	sound.pause("sound_controller#sound_underwater", game_pause_toggle)
	sound.pause("sound_controller#sound_waves", game_pause_toggle)
	sound.pause("sound_controller#sound_bubbles", game_pause_toggle)

	-- make sure to pause all boat sounds too with loop
	for _,v_boat_typ_info in pairs(INFO.item_info.item_humans.subitem_info) do
		local boat_list = self.spawned_objects_list[v_boat_typ_info.spawn_list_key]
		if boat_list ~= nil then
			for k_go_id, _ in pairs(boat_list) do
				msg.post(k_go_id, HSH.msg_pause_game_msg_sent, {minfo_game_paused = game_pause_toggle})
			end
		end
	end

end

local function ExpireObjectCheck(self, spawn_list_key, go_id)

	local delete_go = true
	local ignore_stop = false
	local instant_stop = false
	Spawned_RemoveObject(self, spawn_list_key, go_id, delete_go, ignore_stop, instant_stop)

end

local function DynamicObject_Reset(self)

	-- reset animals, either just swimmers or all (includes humans) and buoy

	-- run for animals
	local delete_gos = true
	for _, v_iteminfo in pairs(INFO.item_info) do
		if v_iteminfo.item_is_alive then
			for _,v_subiteminfo in pairs(v_iteminfo.subitem_info) do
				Spawned_ResetAll(self, v_subiteminfo.spawn_list_key, delete_gos)
			end
		end
	end

	-- hide buoy
	SetupBuoy(self, true)

	-- setup animals with fresh values
	-- use timer to prevent buffer overflow
	timer.delay(CV_Animal_Reset_Time, false, Setup_AllAnimals)

end

local function ResetDynamicGrids(self)

	-- gets baseline grid positions for animals
	-- since they only really need calculated once

	self.dynamic_grids = nil
	self.dynamic_spawn_sides = nil
	self.dynamic_grids = {}
	self.dynamic_spawn_sides = {}

	-- setup some helper functions
	-- easy grid for swimmers
	local function func_grid_swimmers(spawn_subgroup, rand_offset_factor, y_stack_base)

		-- get grid points from just a few variables

		local scale = spawn_subgroup.object_scale_base
		local count = spawn_subgroup.spawn_max_count
		local obj_size = spawn_subgroup.object_dimensions
		local obj_grid_mult = spawn_subgroup.object_gridsize_multiplier or {x=1, y=1}
		local local_size_x = obj_size.x * scale * obj_grid_mult.x
		local local_size_y = obj_size.y * scale * obj_grid_mult.y

		local min_x = spawn_subgroup.spawn_x_min or 0
		local max_x = min_x + (local_size_x*1.2)

		local min_y = spawn_subgroup.spawn_y_range[1]
		local max_y = spawn_subgroup.spawn_y_range[2]
		if max_y + local_size_y < min_y then
			max_y = min_y + local_size_y*1.2
		end

		local rand_offset_factor = rand_offset_factor or {x=0.25, y=0.3}

		local range_tbl = {x={min_x, max_x}, y={min_y, max_y}}
		local cell_size_table = {x = local_size_x, y = local_size_y, z = spawn_subgroup.spawn_z_base}
		local use_center = true
		local grid_points = GetGridPoints(range_tbl, cell_size_table, count, rand_offset_factor, use_center, y_stack_base)
		return grid_points

	end

	local function func_grid_static(spawn_subgroup)

		local max_count_value = spawn_subgroup.spawn_max_count
		local static_tbl = spawn_subgroup.static_spawner_tbl
		local max_count_static_tbl = #static_tbl

		if max_count_value > max_count_static_tbl then
			print("Error: max_count_value is > max_count_static_tbl, there will not be enough grid slots! Setting max count value to table length max. \n")
			max_count_value = max_count_static_tbl
		end

		local cells_tbl = {}
		for i=1,max_count_value do
			local info = static_tbl[i]
			local x = info[1]
			local y = info[2]
			local z = info[3] + (i*0.001) + Get_Z_from_Y(y, 0.1)
			local flip = info.flip_sprite
			local rot_z = info.rotation_z_euler or 0
			local sprite_i = info.sprite_selection_i or 1
			cells_tbl[i] = {x = x, y = y, z = z, i_index = i, flip_sprite = flip, rotation_z_euler = rot_z, sprite_selection_i = sprite_i}
		end

		return cells_tbl

	end

	-- run compiled grid setup
	for k_item, v_item in pairs(INFO.item_info) do

		if INFO:Logic_is_Alive(k_item) then
			for _, v_subitem in pairs(v_item.subitem_info) do
				local spawnlist_keyname = v_subitem.spawn_list_key
				self.dynamic_grids[spawnlist_keyname] = {}
				local flip_side = false

				-- get count to spawn
				local max_spawn_possible = v_subitem.spawn_max_count

				-- only continue if spawn count > 0
				if max_spawn_possible ~= nil and max_spawn_possible > 0 then

					if INFO:Logic_is_Swimmer(v_subitem.object_logic_type) then
						--swimmers are the ones with dynamic starting sides
						flip_side = (math.random(0,1) == 1)
						self.dynamic_grids[spawnlist_keyname] = func_grid_swimmers(v_subitem)
					elseif INFO:Logic_is_Static(v_subitem.object_logic_type) then
						self.dynamic_grids[spawnlist_keyname] = func_grid_static(v_subitem)
					elseif INFO:Logic_is_Micro(v_subitem.object_logic_type) then
						self.dynamic_grids[spawnlist_keyname] = func_grid_swimmers(v_subitem, {x=0.2, y=0.0}, 0.01)
					end

				end

				self.dynamic_spawn_sides[spawnlist_keyname] = flip_side
			end
		end

	end

end

local function Update_Micro_or_Static(self, item_name, subitem_name, local_oa_outcome_tbl, run_visual_change)

	-- update health of a micro or static subitem
	-- since these have cumulative visuals

	local spawn_list_name = INFO.item_info[item_name].subitem_info[subitem_name].spawn_list_key
	local key_list = self.spawned_objects_list[spawn_list_name]
	if key_list ~= nil then
		local item_health_info = local_oa_outcome_tbl[item_name]
		if item_health_info ~= nil then
			for k_gourl, _ in pairs(key_list) do
				msg.post(k_gourl, HSH.msg_order_update_health, {minfo_new_health_value = item_health_info.health_value_new or 0.5, minfo_run_visual_update = run_visual_change})
				-- recall static and micro gos each internally track their own health
				-- so the script will know what the overall delta is from this new value and the self current value
			end
		end
	end

end

local function CatchUp_Micro_or_Static(self, oa_outcome_tbl)

	-- instantly catch up for static or micro since they use cumulative visuals

	-- coral
	local item_coral = INFO.item_info.item_coral
	for k_subitem_coral_name, _ in pairs(item_coral.subitem_info) do
		Update_Micro_or_Static(self, "item_coral", k_subitem_coral_name, oa_outcome_tbl, false)
	end

	-- plankton
	Update_Micro_or_Static(self, "item_plankton", "subitem_phytoplankton", oa_outcome_tbl, false)

	-- oysters
	Update_Micro_or_Static(self, "item_mollusks", "subitem_oyster", oa_outcome_tbl, false)

end

local function On_OA_OutcomeEffects(self, oa_outcome_tbl, run_swimmer_reset, show_highlighter, percent_coastal_oa_to_run) --oa_outcome_tbl in form { item_plankton = {health_value_previous, health_value_new} }

	-- reset all swimmers at full count then add or kill given %
	-- also send messages to static and micro to update

	-- setup timer values
	local fader_time
	local reset_time
	local reset_buffer
	local run_coastal_oa
	local coastal_oa_spawns_offscreen

	-- setup values for if running swimmer reset or not
	if run_swimmer_reset then
		-- recall if running swimmer reset then we are fading out then back in
		fader_time = 0.5
		reset_buffer = 0.1
		reset_time = CV_Animal_Reset_Time
		coastal_oa_spawns_offscreen = false
	else
		-- not fading out or back in, so set fader times to low for use in timers
		fader_time = 0.01
		reset_time = 0.01
		reset_buffer = 0.01
		coastal_oa_spawns_offscreen = true
	end

	local stage_done_plankton_or_oa
	local stage_done_ocean_benthic
	local stage_done_ocean_pelagic
	local full_oa_done_wait = 0.1

	if show_highlighter then
		stage_done_plankton_or_oa = 2
		stage_done_ocean_benthic = 3
		stage_done_ocean_pelagic = 4
	else
		stage_done_plankton_or_oa = 1
		stage_done_ocean_benthic = 1
		stage_done_ocean_pelagic = 1
	end

	-- add extra time to plankton to do coastal OA
	if type(percent_coastal_oa_to_run) == "number" then
		if percent_coastal_oa_to_run > 0 then
			-- give some time for coastal effect to start
			run_coastal_oa = true
			stage_done_plankton_or_oa = stage_done_plankton_or_oa + CV_Total_Coastal_OA_Time/3
		end
	else
		run_coastal_oa = false
		percent_coastal_oa_to_run = 0
	end

	-- ^^ give time for new swimmers to join formation before ordering school to patrol
	-- also update this time if no swimmers are needed to add or subtract

	local function reset_swimmers_start(screen_fader_time)

		-- start swimmer resetting to maximize visual change

		if run_swimmer_reset then
			msg.post("main:/hud#gui", HSH.msg_request_fade_out, {minfo_fade_duration = screen_fader_time})
		end

	end

	local function reset_swimmers_mid()

		if run_swimmer_reset then

			-- reset swimmer spawn keys
			for k_spawnlistkey,_ in pairs(self.helper_spawn_lists_swimmers) do
				Spawned_ResetAll(self, k_spawnlistkey, true)
			end

		end

	end

	local function reset_swimmers_end(screen_fader_time)

		-- reset swimmers to maximize visual change

		-- ^^ reset should be somewhat reflective of previous health for item?
		-- if previous health 0.2 and new health 0.1, visual should be 0.6 to 0.2
		-- if previous health 0.2 and new health 0.3, visual should be 0.2 to 0.6 or 0.6 to 1.0
		--   then next time, 0.3 to 0.4 will be 0.6 to 1.0 in both above cases? or drop it back down to previous value?
		-- if previous health 0.7 and new health 0.6, visual should be 0.7 to 0.3 or 0.6 to 0.2 or 1.0 to 0.6
		-- if previous health 0.7 and new health 0.8, visual should be 0.6 to 1.0
		-- still has potential to be large difference between previous and reset fade

		-- priority should be having the final value match whatever the actual health is
		-- example: was 1.0 -> now 0.5: starts at 1 and goes down to 0.5
		--   0.5 -> 0.6: starts at 0.2 and goes up to 0.6
		--   0.5 -> 0.4: starts at 0.8 and goes down to 0.4
		-- formula is: reset is final/new value +- visual change 
		-- downside is from previous to reset at fade it could change a lot and would depend on answer
		-- also having new value be low and then going only slightly higher may not look like much
		--   for example, 0.15 -> 0.25: starts at 0 (0.25 - 0.4 -> -0.15, clamped at 0) and goes to 0.25
		-- benefit is it matches reality, just like the static and micro

		-- or priority is starting reset matches previous value and new value is just some visual change from that
		-- downside is does not match reality and still has potential to be large difference between previous and reset fade

		-- or priority is always at 0.6 for reset and goes to 1 or 0.2 if up or down
		-- upside is always get effect that is very noticeable
		-- downside is does not match reality and still has potential to be large difference between previous and reset fade

		-- if swimmer health same do nothing and do not reset to 50%
		-- if swimmer health going up
		--   want swimmer count to go up by at least 40% for noticeable visual effect
		--   if health > 0.5 (reset) then set to reset and then run effect up to 40%
		--   if health <= 0.5 (reset) then run effect up to 40%

		if not run_swimmer_reset then return end

		-- what percent population should visual change alter (for example, visual changer is 40%)
		local reset_health_delta = 0.4

		local skip_reset = true
		local spawn_offscreen = false
		local go_auto_patrol = false

		for k_spawnlist_name,v_info in pairs(self.helper_spawn_lists_swimmers) do
			-- randomize side so fish don't always appear on same side
			self.dynamic_spawn_sides[k_spawnlist_name] = (math.random(0,1) == 1)

			-- calculate reset value based on new value, delta change, and visualization size
			local item_name = v_info.l_item_name
			local oa_item_tbl = oa_outcome_tbl[item_name]
			local new_health = oa_item_tbl.health_value_new
			if oa_item_tbl == nil then
				print("Error: Checking within function 'Finish Reset Swimmers' OA Table does not have key <"..tostring(item_name)..">\n")
				return
			end
			local old_health = oa_item_tbl.health_value_previous

			-- get population health for visual change
			local reset_health_val
			if new_health > old_health then
				-- got more healthy
				reset_health_val = new_health - reset_health_delta
			elseif new_health < old_health then
				-- got less healthy
				reset_health_val = new_health + reset_health_delta
			--else
				-- remained same
				reset_health_val = new_health
			end

			-- reminder, animal setup already forces there to be at least 1 animal

			-- spawn subitems with updated population health
			Setup_Animal(self, item_name, v_info.l_subitem_name, reset_health_val, skip_reset, spawn_offscreen, go_auto_patrol)
		end

		-- Fade back in 
		msg.post("main:/hud#gui", HSH.msg_request_fade_in, {minfo_fade_duration = screen_fader_time})

	end

	local function update_swimmer(item_name, subitem_name, death_ignore_stop, death_instant_stop)

		-- update health of a swimmer subitem

		-- setup
		local s_item = INFO.item_info[item_name]
		local subitem_tbl = s_item.subitem_info[subitem_name]

		local spawn_list_name = subitem_tbl.spawn_list_key
		local key_list = self.spawned_objects_list[spawn_list_name]

		-- early out if invalid
		if key_list == nil then
			return 0, 0
		end

		-- calculate amount to change
		local number_added, number_subtracted = 0, 0

		local new_health = oa_outcome_tbl[item_name].health_value_new
		-- recall, we need to externally track the previous and new health 
		-- b/c gos are added and deleted with swimmers and b/c health is reset to middle value for visualization
		-- recall if delta change equals 0 ('old' == 'new') then the reset health also equals 'new'

		-- get current health of spawned animals
		local current_count = self.spawned_objects_sum[spawn_list_name]
		local max_count = subitem_tbl.spawn_max_count
		local current_health = EXT:math_round(current_count/max_count, 4)

		-- get amount needed to add or subtract (use math.ceil for maximum effect)
		local delta_change = new_health - current_health
		local delta_count_change = EXT:math_sign(delta_change) * math.ceil(math.abs(delta_change) * subitem_tbl.spawn_max_count)

		-- early out if:
		--   if change count + current_count > max_count then do not add
		--   if change count + current_count < 0 then do not add
		local final_count_possible = delta_change + current_count
		if (final_count_possible > max_count) or (final_count_possible <= 0) then
			return 0, 0
		end

		-- finally actually spawn or remove animals
		-- also record amount for wait time updating
		if delta_count_change > 0 then
			-- add
			number_added = math.abs(delta_count_change)
			local spawn_offscreen = true
			local is_spawn_flipped = self.dynamic_spawn_sides[spawn_list_name]

			-- go through number and add 
			for i=1,number_added do
				local i_position_in_grid = current_count + i
				Spawn_Animal_Swimmer(self, item_name, subitem_name, i_position_in_grid, spawn_offscreen, is_spawn_flipped)
			end

		elseif delta_count_change < 0 then
			-- subtract
			number_subtracted = math.abs(delta_count_change)

			-- go through go list and add gos to a i table 
			-- then pick index and remove randomly
			local remove_options = {}
			local num_i = 0
			for k_go_url, _ in pairs(key_list) do
				num_i = num_i + 1
				remove_options[num_i] = k_go_url
			end

			-- failsafe check, make sure we never have 0 of item
			if number_subtracted >= num_i then
				--print("Warning: too many numbers to subtract <"..number_subtracted.."> out of total list <"..num_i.."> for subitem <"..subitem_name..">, reducing by 1\n")
				number_subtracted = num_i - 1
			end

			-- shuffle table and remove first entries (makes it a random removal overall)
			local delete_go = false
			if number_subtracted >= 1 then
				local rand_tbl = EXT:Table_Shuffle(remove_options)
				for i=1,number_subtracted do
					local go_url = rand_tbl[i]
					Spawned_RemoveObject(self, spawn_list_name, go_url, delete_go, death_ignore_stop, death_instant_stop)
				end
			end

		end

		return number_added, number_subtracted

	end

	-- update helper functions
	local function update_plankton_or_coastal_oa()

		-- trigger highlighter, but only if coastal OA is not running
		if show_highlighter and not run_coastal_oa then
			msg.post("main:/hud#gui", HSH.msg_request_update_highlighter, {minfo_hud_highlighter_type="show_area_plankton"})
		end

		-- update plankton, which uses health update message
		Update_Micro_or_Static(self, "item_plankton", "subitem_phytoplankton", oa_outcome_tbl, true)

		-- also do optional coastal OA
		-- health effects can still occur with plankton even if disabling b/c of coastal OA
		-- recall coastal OA hides plankton viewer, 
		--  fine if some have shrank already it's likely not noticeable
		--  and questions that use coastal OA also have co2 effects 
		--   which can be used as justification for why plankton change before coastal OA kicks in
		if run_coastal_oa then
			local percent_coastal_oa_to_hide = 1 - percent_coastal_oa_to_run
			-- add third arg as true to enable coastal oa highlighter
			Run_CoastalOA(self, percent_coastal_oa_to_hide)
		end

	end

	local function update_ocean_floor()

		-- update all static (all corals, oysters), which use health update message
		-- update some swimmers (crabs and conches), which use kill or add

		-- trigger highlighter
		if show_highlighter then
			msg.post("main:/hud#gui", HSH.msg_request_update_highlighter, {minfo_hud_highlighter_type="show_area_benthic"})
		end

		-- coral
		local item_coral = INFO.item_info.item_coral
		for k_subitem_coral_name, _ in pairs(item_coral.subitem_info) do
			Update_Micro_or_Static(self, "item_coral", k_subitem_coral_name, oa_outcome_tbl, true)
		end

		-- oysters
		Update_Micro_or_Static(self, "item_mollusks", "subitem_oyster", oa_outcome_tbl, true)

		-- on seafloor so stop, and stop quickly so effect is viewable
		local death_ignore_stop = false
		local death_instant_stop = true

		--conches
		update_swimmer("item_mollusks", "subitem_conch", death_ignore_stop, death_instant_stop)

		--crabs
		update_swimmer("item_crustaceans", "subitem_crab", death_ignore_stop, death_instant_stop)

		-- recall conch and crab timing not needed to track since they do not go in formation
	end

	local function update_ocean_water()
		-- update most swimmers (all fish, shrimp), which use kill or add

		-- trigger highlighter
		if show_highlighter then
			msg.post("main:/hud#gui", HSH.msg_request_update_highlighter, {minfo_hud_highlighter_type="show_area_pelagic"})
		end

		-- swimming, so do not stop since we want momentum to continue when dying
		local death_ignore_stop = true
		local death_instant_stop = false

		--shrimp
		local number_added, number_subtracted = update_swimmer("item_crustaceans", "subitem_shrimp", death_ignore_stop, death_instant_stop)

		--fish
		local item_fish = INFO.item_info.item_fish
		for k_subitem_fish_name, _ in pairs(item_fish.subitem_info) do
			local fish_added, fish_subtracted = update_swimmer("item_fish", k_subitem_fish_name, death_ignore_stop, death_instant_stop)
			number_added = number_added + fish_added
			number_subtracted = number_subtracted + fish_subtracted
		end

		-- return amount of extra time to wait (added to stage_done_ocean_pelagic)
		if number_added > 0 then
			-- wait for joins
			return 4
		elseif number_subtracted > 0 then
			-- wait for decays
			return 1
		else
			return 0
		end

	end


	-- 1. setup:
	--   1a. fade out
	--   1b. reset swimmers to state where changes will be noticeable (for example, 50% health)
	--   1c. fade in
	-- 2. highlight region and order update (use oa_outcome_tbl)
	--   2a. highlight micro and request health update or highlight ocean top and run OA (also still request health update)
	--   2b. highlight static and request update
	--   2c. highlight swimmers and request update
	-- 3. send message back to gui that OA effects are done

	-- recall: if resetting then fade out, remove all, spawn in new base, fade in, then finally run added or removed

	-- if running swimmer reset then fade out
	reset_swimmers_start(fader_time)

	timer.delay(fader_time + reset_buffer, false, function()

		-- if running swimmer reset then that means we are faded out
		reset_swimmers_mid()

		-- if resetting add swimmers back in at reset population (for example, 50% health)
		-- wait a fraction of a second though so to not overwhelm system

		timer.delay(fader_time + reset_buffer + reset_time, false, function()

			-- if running swimmer reset then that means we are faded out
			-- so reset to base and fade back in
			reset_swimmers_end(fader_time)

			-- before fading back in also add rainy clouds if needed
			if run_coastal_oa then
				-- recall, if using fade in and fade out with reset swimmers, 
				-- then coastal oa can start in center of screen and does not have to start offscreen
				Run_Temporary_RainyClouds(self, coastal_oa_spawns_offscreen)
			end

			-- once faded back in, run through OA effects, including adding or removing
			timer.delay(fader_time*1.5, false, function()

				-- highlight plankton or OA and request update and coastal OA if needed
				update_plankton_or_coastal_oa()

				timer.delay(stage_done_plankton_or_oa, false, function()

					-- highlight ocean floor and request update
					update_ocean_floor()

					timer.delay(stage_done_ocean_benthic, false, function()

						-- highlight ocean middle and request update
						local extra_swimmer_catch_up_time = update_ocean_water()
						local full_ocean_mid_done = stage_done_ocean_pelagic + extra_swimmer_catch_up_time

						timer.delay(full_ocean_mid_done, false, function()

							-- also send message to all animals to start auto patrol
							if run_swimmer_reset then
								for k_spawnlistkey,_ in pairs(self.helper_spawn_lists_swimmers) do
									local key_list = self.spawned_objects_list[k_spawnlistkey]
									for k_gourl, _ in pairs(key_list) do
										Animal_Order_GoTo(self, k_gourl) --default is waypoint 2
									end
								end
							end

							-- end OA effects when all animals done and coastal OA is done
							-- IE if there is still time left on coastal OA then wait until it's done
							if run_coastal_oa then
								local time_used = stage_done_plankton_or_oa + stage_done_ocean_benthic + full_ocean_mid_done
								if CV_Total_Coastal_OA_Time > time_used then
									full_oa_done_wait = CV_Total_Coastal_OA_Time - time_used
								end
							end

							-- report that OA effects are done
							-- recall this message will also disable highlighter
							timer.delay(full_oa_done_wait, false, function()

								msg.post("main:/hud#gui", HSH.msg_report_oa_outcomes_done)

							end)

						end)
					end)
				end)
			end)
		end)

	end)


end

local function SceneStart(self)

	-- setup the scene variables and objects

	-- set base variables
	self.weather_changeable = true
	self.weather_is_raining = false
	self.weather_reload_time = CV_Weather_Reload_Time
	self.no_wind_default = 1
	self.spawned_objects_list = nil
	self.spawned_objects_list = {}
	self.spawned_objects_sum = nil
	self.spawned_objects_sum = {}

	-- setup swimmer spawn list keys for quicker access later
	self.helper_spawn_lists_swimmers = {}
	for k_itemname, v_iteminfo in pairs(INFO.item_info) do
		if v_iteminfo.item_is_alive then
			for k_subitemname,v_subiteminfo in pairs(v_iteminfo.subitem_info) do
				if INFO:Logic_is_Swimmer(v_subiteminfo.object_logic_type) then
					self.helper_spawn_lists_swimmers[v_subiteminfo.spawn_list_key] = {l_item_name = k_itemname, l_subitem_name = k_subitemname}
				end
			end
		end
	end

	ResetDynamicGrids(self)

	SetPlanktonViewer(self, true)

	Make_Bubbles(self)

	-- setup animals
	Setup_AllAnimals(self)

	-- setup weather (after animals for some reason...)
	Setup_Weather(self, true)

	-- setup buoy by first just hiding it
	SetupBuoy(self, true)

	-- play sounds 
	sound.play("sound_controller#sound_underwater", {delay = 0, gain = 0.15, pan = 0, speed = 1.0})
	sound.play("sound_controller#sound_waves", {delay = 0, gain = 0.08, pan = 0, speed = 1.0})

	-- set coastal OA tracking
	self.Obj_Percent_Coastal_OA_to_Hide = 0

end

local function On_SpecialAction(self, special_action_name)

	if special_action_name == HSH.special_setup_first_boat then
		Spawn_Boat(self)
	elseif special_action_name == HSH.special_setup_pH_buoy then
		SetupBuoy(self)
	elseif special_action_name == HSH.special_restart_game then
		DynamicObject_Reset(self)
	end

end


function init(self)

	SceneStart(self)

end

function on_message(self, message_id, message, sender)

	if message_id == HSH.msg_pause_game_msg_sent then
		OnPauseToggle_SoundHelper(self, message.minfo_game_paused)
	end
	if message_id == HSH.msg_request_change_weather then
		Weather_Change(self, message.minfo_is_raining, message.minfo_wave_direction, message.minfo_run_coastal_oa_too)
	elseif message_id == HSH.msg_request_run_coastal_oa then
		Run_CoastalOA(self, message.minfo_percent_coastal_oa_hide, message.minfo_coastal_oa_show_highlighter)
	elseif message_id == HSH.msg_request_run_temporary_rain then
		Run_Temporary_RainyClouds(self, message.minfo_spawn_rain_offscreen)
	--elseif message_id == HSH.msg_report_swim_run_started then --can use message.minfo_spawn_list_key
	--elseif message_id == HSH.msg_report_swim_run_completed then --can use message.minfo_spawn_list_key
	elseif message_id == HSH.msg_request_make_bubbles then
		local world_pos = CAM.screen_to_world(nil, vmath.vector3(message.minfo_action.x, message.minfo_action.y, 0))
		Make_Bubbles(self, world_pos.x)
	elseif message_id == HSH.msg_request_go_clicked then
		Get_Item_Clicked_On(self, message.minfo_action)
	elseif message_id == HSH.msg_reported_expire_done then
		ExpireObjectCheck(self, message.minfo_spawn_list_key, sender)
	elseif message_id == HSH.msg_request_special_case_action then
		On_SpecialAction(self, message.minfo_special_case_key)
	elseif message_id == HSH.msg_request_oa_outcomes_started then
		On_OA_OutcomeEffects(self, message.minfo_oa_outcome_item_health_values, message.minfo_oa_outcome_reset_swimmers, message.minfo_oa_outcomes_show_highlighter, message.minfo_run_coastal_oa_percent)
	elseif message_id == HSH.msg_request_oa_catchup_micro_or_static then
		CatchUp_Micro_or_Static(self, message.minfo_oa_outcome_item_health_values)
	elseif message_id == HSH.msg_set_player_character_subitem then
		Boat_Change_Character(self, message.minfo_subitem_boat_name)
	end

end